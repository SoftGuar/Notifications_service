
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Commercial
 * 
 */
export type Commercial = $Result.DefaultSelection<Prisma.$CommercialPayload>
/**
 * Model Decider
 * 
 */
export type Decider = $Result.DefaultSelection<Prisma.$DeciderPayload>
/**
 * Model DispoIssue
 * 
 */
export type DispoIssue = $Result.DefaultSelection<Prisma.$DispoIssuePayload>
/**
 * Model Dispositive
 * 
 */
export type Dispositive = $Result.DefaultSelection<Prisma.$DispositivePayload>
/**
 * Model Helper
 * 
 */
export type Helper = $Result.DefaultSelection<Prisma.$HelperPayload>
/**
 * Model Intervention
 * 
 */
export type Intervention = $Result.DefaultSelection<Prisma.$InterventionPayload>
/**
 * Model Maintainer
 * 
 */
export type Maintainer = $Result.DefaultSelection<Prisma.$MaintainerPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductQuotation
 * 
 */
export type ProductQuotation = $Result.DefaultSelection<Prisma.$ProductQuotationPayload>
/**
 * Model ProductTransaction
 * 
 */
export type ProductTransaction = $Result.DefaultSelection<Prisma.$ProductTransactionPayload>
/**
 * Model Quotation
 * 
 */
export type Quotation = $Result.DefaultSelection<Prisma.$QuotationPayload>
/**
 * Model SuperAdmin
 * 
 */
export type SuperAdmin = $Result.DefaultSelection<Prisma.$SuperAdminPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model InterventionReport
 * 
 */
export type InterventionReport = $Result.DefaultSelection<Prisma.$InterventionReportPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const InterventionStatus: {
  done: 'done',
  inProgress: 'inProgress',
  pending: 'pending',
  rescheduled: 'rescheduled'
};

export type InterventionStatus = (typeof InterventionStatus)[keyof typeof InterventionStatus]

}

export type InterventionStatus = $Enums.InterventionStatus

export const InterventionStatus: typeof $Enums.InterventionStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admin.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admin.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commercial`: Exposes CRUD operations for the **Commercial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commercials
    * const commercials = await prisma.commercial.findMany()
    * ```
    */
  get commercial(): Prisma.CommercialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.decider`: Exposes CRUD operations for the **Decider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deciders
    * const deciders = await prisma.decider.findMany()
    * ```
    */
  get decider(): Prisma.DeciderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dispoIssue`: Exposes CRUD operations for the **DispoIssue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DispoIssues
    * const dispoIssues = await prisma.dispoIssue.findMany()
    * ```
    */
  get dispoIssue(): Prisma.DispoIssueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dispositive`: Exposes CRUD operations for the **Dispositive** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dispositives
    * const dispositives = await prisma.dispositive.findMany()
    * ```
    */
  get dispositive(): Prisma.DispositiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.helper`: Exposes CRUD operations for the **Helper** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Helpers
    * const helpers = await prisma.helper.findMany()
    * ```
    */
  get helper(): Prisma.HelperDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.intervention`: Exposes CRUD operations for the **Intervention** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interventions
    * const interventions = await prisma.intervention.findMany()
    * ```
    */
  get intervention(): Prisma.InterventionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintainer`: Exposes CRUD operations for the **Maintainer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maintainers
    * const maintainers = await prisma.maintainer.findMany()
    * ```
    */
  get maintainer(): Prisma.MaintainerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productQuotation`: Exposes CRUD operations for the **ProductQuotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductQuotations
    * const productQuotations = await prisma.productQuotation.findMany()
    * ```
    */
  get productQuotation(): Prisma.ProductQuotationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productTransaction`: Exposes CRUD operations for the **ProductTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductTransactions
    * const productTransactions = await prisma.productTransaction.findMany()
    * ```
    */
  get productTransaction(): Prisma.ProductTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quotation`: Exposes CRUD operations for the **Quotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotations
    * const quotations = await prisma.quotation.findMany()
    * ```
    */
  get quotation(): Prisma.QuotationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.superAdmin`: Exposes CRUD operations for the **SuperAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuperAdmins
    * const superAdmins = await prisma.superAdmin.findMany()
    * ```
    */
  get superAdmin(): Prisma.SuperAdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interventionReport`: Exposes CRUD operations for the **InterventionReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterventionReports
    * const interventionReports = await prisma.interventionReport.findMany()
    * ```
    */
  get interventionReport(): Prisma.InterventionReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Admin: 'Admin',
    Commercial: 'Commercial',
    Decider: 'Decider',
    DispoIssue: 'DispoIssue',
    Dispositive: 'Dispositive',
    Helper: 'Helper',
    Intervention: 'Intervention',
    Maintainer: 'Maintainer',
    Product: 'Product',
    ProductQuotation: 'ProductQuotation',
    ProductTransaction: 'ProductTransaction',
    Quotation: 'Quotation',
    SuperAdmin: 'SuperAdmin',
    Transaction: 'Transaction',
    User: 'User',
    InterventionReport: 'InterventionReport',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "admin" | "commercial" | "decider" | "dispoIssue" | "dispositive" | "helper" | "intervention" | "maintainer" | "product" | "productQuotation" | "productTransaction" | "quotation" | "superAdmin" | "transaction" | "user" | "interventionReport" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Commercial: {
        payload: Prisma.$CommercialPayload<ExtArgs>
        fields: Prisma.CommercialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommercialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommercialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload>
          }
          findFirst: {
            args: Prisma.CommercialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommercialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload>
          }
          findMany: {
            args: Prisma.CommercialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload>[]
          }
          create: {
            args: Prisma.CommercialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload>
          }
          createMany: {
            args: Prisma.CommercialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommercialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload>[]
          }
          delete: {
            args: Prisma.CommercialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload>
          }
          update: {
            args: Prisma.CommercialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload>
          }
          deleteMany: {
            args: Prisma.CommercialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommercialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommercialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload>[]
          }
          upsert: {
            args: Prisma.CommercialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload>
          }
          aggregate: {
            args: Prisma.CommercialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommercial>
          }
          groupBy: {
            args: Prisma.CommercialGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommercialGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommercialCountArgs<ExtArgs>
            result: $Utils.Optional<CommercialCountAggregateOutputType> | number
          }
        }
      }
      Decider: {
        payload: Prisma.$DeciderPayload<ExtArgs>
        fields: Prisma.DeciderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeciderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeciderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload>
          }
          findFirst: {
            args: Prisma.DeciderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeciderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload>
          }
          findMany: {
            args: Prisma.DeciderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload>[]
          }
          create: {
            args: Prisma.DeciderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload>
          }
          createMany: {
            args: Prisma.DeciderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeciderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload>[]
          }
          delete: {
            args: Prisma.DeciderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload>
          }
          update: {
            args: Prisma.DeciderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload>
          }
          deleteMany: {
            args: Prisma.DeciderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeciderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeciderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload>[]
          }
          upsert: {
            args: Prisma.DeciderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload>
          }
          aggregate: {
            args: Prisma.DeciderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDecider>
          }
          groupBy: {
            args: Prisma.DeciderGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeciderGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeciderCountArgs<ExtArgs>
            result: $Utils.Optional<DeciderCountAggregateOutputType> | number
          }
        }
      }
      DispoIssue: {
        payload: Prisma.$DispoIssuePayload<ExtArgs>
        fields: Prisma.DispoIssueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DispoIssueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispoIssuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DispoIssueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispoIssuePayload>
          }
          findFirst: {
            args: Prisma.DispoIssueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispoIssuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DispoIssueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispoIssuePayload>
          }
          findMany: {
            args: Prisma.DispoIssueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispoIssuePayload>[]
          }
          create: {
            args: Prisma.DispoIssueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispoIssuePayload>
          }
          createMany: {
            args: Prisma.DispoIssueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DispoIssueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispoIssuePayload>[]
          }
          delete: {
            args: Prisma.DispoIssueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispoIssuePayload>
          }
          update: {
            args: Prisma.DispoIssueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispoIssuePayload>
          }
          deleteMany: {
            args: Prisma.DispoIssueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DispoIssueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DispoIssueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispoIssuePayload>[]
          }
          upsert: {
            args: Prisma.DispoIssueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispoIssuePayload>
          }
          aggregate: {
            args: Prisma.DispoIssueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDispoIssue>
          }
          groupBy: {
            args: Prisma.DispoIssueGroupByArgs<ExtArgs>
            result: $Utils.Optional<DispoIssueGroupByOutputType>[]
          }
          count: {
            args: Prisma.DispoIssueCountArgs<ExtArgs>
            result: $Utils.Optional<DispoIssueCountAggregateOutputType> | number
          }
        }
      }
      Dispositive: {
        payload: Prisma.$DispositivePayload<ExtArgs>
        fields: Prisma.DispositiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DispositiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispositivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DispositiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispositivePayload>
          }
          findFirst: {
            args: Prisma.DispositiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispositivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DispositiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispositivePayload>
          }
          findMany: {
            args: Prisma.DispositiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispositivePayload>[]
          }
          create: {
            args: Prisma.DispositiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispositivePayload>
          }
          createMany: {
            args: Prisma.DispositiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DispositiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispositivePayload>[]
          }
          delete: {
            args: Prisma.DispositiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispositivePayload>
          }
          update: {
            args: Prisma.DispositiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispositivePayload>
          }
          deleteMany: {
            args: Prisma.DispositiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DispositiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DispositiveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispositivePayload>[]
          }
          upsert: {
            args: Prisma.DispositiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispositivePayload>
          }
          aggregate: {
            args: Prisma.DispositiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDispositive>
          }
          groupBy: {
            args: Prisma.DispositiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<DispositiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.DispositiveCountArgs<ExtArgs>
            result: $Utils.Optional<DispositiveCountAggregateOutputType> | number
          }
        }
      }
      Helper: {
        payload: Prisma.$HelperPayload<ExtArgs>
        fields: Prisma.HelperFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HelperFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HelperFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload>
          }
          findFirst: {
            args: Prisma.HelperFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HelperFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload>
          }
          findMany: {
            args: Prisma.HelperFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload>[]
          }
          create: {
            args: Prisma.HelperCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload>
          }
          createMany: {
            args: Prisma.HelperCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HelperCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload>[]
          }
          delete: {
            args: Prisma.HelperDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload>
          }
          update: {
            args: Prisma.HelperUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload>
          }
          deleteMany: {
            args: Prisma.HelperDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HelperUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HelperUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload>[]
          }
          upsert: {
            args: Prisma.HelperUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload>
          }
          aggregate: {
            args: Prisma.HelperAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelper>
          }
          groupBy: {
            args: Prisma.HelperGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelperGroupByOutputType>[]
          }
          count: {
            args: Prisma.HelperCountArgs<ExtArgs>
            result: $Utils.Optional<HelperCountAggregateOutputType> | number
          }
        }
      }
      Intervention: {
        payload: Prisma.$InterventionPayload<ExtArgs>
        fields: Prisma.InterventionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterventionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterventionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          findFirst: {
            args: Prisma.InterventionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterventionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          findMany: {
            args: Prisma.InterventionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>[]
          }
          create: {
            args: Prisma.InterventionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          createMany: {
            args: Prisma.InterventionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterventionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>[]
          }
          delete: {
            args: Prisma.InterventionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          update: {
            args: Prisma.InterventionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          deleteMany: {
            args: Prisma.InterventionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterventionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterventionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>[]
          }
          upsert: {
            args: Prisma.InterventionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          aggregate: {
            args: Prisma.InterventionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntervention>
          }
          groupBy: {
            args: Prisma.InterventionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterventionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterventionCountArgs<ExtArgs>
            result: $Utils.Optional<InterventionCountAggregateOutputType> | number
          }
        }
      }
      Maintainer: {
        payload: Prisma.$MaintainerPayload<ExtArgs>
        fields: Prisma.MaintainerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintainerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintainerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload>
          }
          findFirst: {
            args: Prisma.MaintainerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintainerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload>
          }
          findMany: {
            args: Prisma.MaintainerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload>[]
          }
          create: {
            args: Prisma.MaintainerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload>
          }
          createMany: {
            args: Prisma.MaintainerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintainerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload>[]
          }
          delete: {
            args: Prisma.MaintainerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload>
          }
          update: {
            args: Prisma.MaintainerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload>
          }
          deleteMany: {
            args: Prisma.MaintainerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintainerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaintainerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload>[]
          }
          upsert: {
            args: Prisma.MaintainerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload>
          }
          aggregate: {
            args: Prisma.MaintainerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintainer>
          }
          groupBy: {
            args: Prisma.MaintainerGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintainerGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintainerCountArgs<ExtArgs>
            result: $Utils.Optional<MaintainerCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductQuotation: {
        payload: Prisma.$ProductQuotationPayload<ExtArgs>
        fields: Prisma.ProductQuotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductQuotationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQuotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductQuotationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQuotationPayload>
          }
          findFirst: {
            args: Prisma.ProductQuotationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQuotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductQuotationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQuotationPayload>
          }
          findMany: {
            args: Prisma.ProductQuotationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQuotationPayload>[]
          }
          create: {
            args: Prisma.ProductQuotationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQuotationPayload>
          }
          createMany: {
            args: Prisma.ProductQuotationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductQuotationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQuotationPayload>[]
          }
          delete: {
            args: Prisma.ProductQuotationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQuotationPayload>
          }
          update: {
            args: Prisma.ProductQuotationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQuotationPayload>
          }
          deleteMany: {
            args: Prisma.ProductQuotationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductQuotationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductQuotationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQuotationPayload>[]
          }
          upsert: {
            args: Prisma.ProductQuotationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQuotationPayload>
          }
          aggregate: {
            args: Prisma.ProductQuotationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductQuotation>
          }
          groupBy: {
            args: Prisma.ProductQuotationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductQuotationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductQuotationCountArgs<ExtArgs>
            result: $Utils.Optional<ProductQuotationCountAggregateOutputType> | number
          }
        }
      }
      ProductTransaction: {
        payload: Prisma.$ProductTransactionPayload<ExtArgs>
        fields: Prisma.ProductTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransactionPayload>
          }
          findFirst: {
            args: Prisma.ProductTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransactionPayload>
          }
          findMany: {
            args: Prisma.ProductTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransactionPayload>[]
          }
          create: {
            args: Prisma.ProductTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransactionPayload>
          }
          createMany: {
            args: Prisma.ProductTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransactionPayload>[]
          }
          delete: {
            args: Prisma.ProductTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransactionPayload>
          }
          update: {
            args: Prisma.ProductTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransactionPayload>
          }
          deleteMany: {
            args: Prisma.ProductTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransactionPayload>[]
          }
          upsert: {
            args: Prisma.ProductTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTransactionPayload>
          }
          aggregate: {
            args: Prisma.ProductTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductTransaction>
          }
          groupBy: {
            args: Prisma.ProductTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<ProductTransactionCountAggregateOutputType> | number
          }
        }
      }
      Quotation: {
        payload: Prisma.$QuotationPayload<ExtArgs>
        fields: Prisma.QuotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuotationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuotationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          findFirst: {
            args: Prisma.QuotationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuotationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          findMany: {
            args: Prisma.QuotationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>[]
          }
          create: {
            args: Prisma.QuotationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          createMany: {
            args: Prisma.QuotationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuotationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>[]
          }
          delete: {
            args: Prisma.QuotationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          update: {
            args: Prisma.QuotationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          deleteMany: {
            args: Prisma.QuotationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuotationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuotationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>[]
          }
          upsert: {
            args: Prisma.QuotationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          aggregate: {
            args: Prisma.QuotationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuotation>
          }
          groupBy: {
            args: Prisma.QuotationGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuotationGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuotationCountArgs<ExtArgs>
            result: $Utils.Optional<QuotationCountAggregateOutputType> | number
          }
        }
      }
      SuperAdmin: {
        payload: Prisma.$SuperAdminPayload<ExtArgs>
        fields: Prisma.SuperAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuperAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuperAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          findFirst: {
            args: Prisma.SuperAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuperAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          findMany: {
            args: Prisma.SuperAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>[]
          }
          create: {
            args: Prisma.SuperAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          createMany: {
            args: Prisma.SuperAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SuperAdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>[]
          }
          delete: {
            args: Prisma.SuperAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          update: {
            args: Prisma.SuperAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          deleteMany: {
            args: Prisma.SuperAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuperAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SuperAdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>[]
          }
          upsert: {
            args: Prisma.SuperAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          aggregate: {
            args: Prisma.SuperAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuperAdmin>
          }
          groupBy: {
            args: Prisma.SuperAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuperAdminCountArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      InterventionReport: {
        payload: Prisma.$InterventionReportPayload<ExtArgs>
        fields: Prisma.InterventionReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterventionReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterventionReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionReportPayload>
          }
          findFirst: {
            args: Prisma.InterventionReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterventionReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionReportPayload>
          }
          findMany: {
            args: Prisma.InterventionReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionReportPayload>[]
          }
          create: {
            args: Prisma.InterventionReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionReportPayload>
          }
          createMany: {
            args: Prisma.InterventionReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterventionReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionReportPayload>[]
          }
          delete: {
            args: Prisma.InterventionReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionReportPayload>
          }
          update: {
            args: Prisma.InterventionReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionReportPayload>
          }
          deleteMany: {
            args: Prisma.InterventionReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterventionReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterventionReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionReportPayload>[]
          }
          upsert: {
            args: Prisma.InterventionReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionReportPayload>
          }
          aggregate: {
            args: Prisma.InterventionReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterventionReport>
          }
          groupBy: {
            args: Prisma.InterventionReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterventionReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterventionReportCountArgs<ExtArgs>
            result: $Utils.Optional<InterventionReportCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    admin?: AdminOmit
    commercial?: CommercialOmit
    decider?: DeciderOmit
    dispoIssue?: DispoIssueOmit
    dispositive?: DispositiveOmit
    helper?: HelperOmit
    intervention?: InterventionOmit
    maintainer?: MaintainerOmit
    product?: ProductOmit
    productQuotation?: ProductQuotationOmit
    productTransaction?: ProductTransactionOmit
    quotation?: QuotationOmit
    superAdmin?: SuperAdminOmit
    transaction?: TransactionOmit
    user?: UserOmit
    interventionReport?: InterventionReportOmit
    notification?: NotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CommercialCountOutputType
   */

  export type CommercialCountOutputType = {
    Transaction: number
  }

  export type CommercialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Transaction?: boolean | CommercialCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * CommercialCountOutputType without action
   */
  export type CommercialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommercialCountOutputType
     */
    select?: CommercialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommercialCountOutputType without action
   */
  export type CommercialCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type DispositiveCountOutputType
   */

  export type DispositiveCountOutputType = {
    DispotiveIssue: number
    Intervention: number
    ProductTransaction: number
  }

  export type DispositiveCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DispotiveIssue?: boolean | DispositiveCountOutputTypeCountDispotiveIssueArgs
    Intervention?: boolean | DispositiveCountOutputTypeCountInterventionArgs
    ProductTransaction?: boolean | DispositiveCountOutputTypeCountProductTransactionArgs
  }

  // Custom InputTypes
  /**
   * DispositiveCountOutputType without action
   */
  export type DispositiveCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispositiveCountOutputType
     */
    select?: DispositiveCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DispositiveCountOutputType without action
   */
  export type DispositiveCountOutputTypeCountDispotiveIssueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispoIssueWhereInput
  }

  /**
   * DispositiveCountOutputType without action
   */
  export type DispositiveCountOutputTypeCountInterventionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionWhereInput
  }

  /**
   * DispositiveCountOutputType without action
   */
  export type DispositiveCountOutputTypeCountProductTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTransactionWhereInput
  }


  /**
   * Count Type HelperCountOutputType
   */

  export type HelperCountOutputType = {
    User: number
  }

  export type HelperCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | HelperCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * HelperCountOutputType without action
   */
  export type HelperCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelperCountOutputType
     */
    select?: HelperCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HelperCountOutputType without action
   */
  export type HelperCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type MaintainerCountOutputType
   */

  export type MaintainerCountOutputType = {
    DispoIssue: number
    Intervention: number
  }

  export type MaintainerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DispoIssue?: boolean | MaintainerCountOutputTypeCountDispoIssueArgs
    Intervention?: boolean | MaintainerCountOutputTypeCountInterventionArgs
  }

  // Custom InputTypes
  /**
   * MaintainerCountOutputType without action
   */
  export type MaintainerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintainerCountOutputType
     */
    select?: MaintainerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaintainerCountOutputType without action
   */
  export type MaintainerCountOutputTypeCountDispoIssueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispoIssueWhereInput
  }

  /**
   * MaintainerCountOutputType without action
   */
  export type MaintainerCountOutputTypeCountInterventionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    Dispositive: number
    ProductQuotation: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Dispositive?: boolean | ProductCountOutputTypeCountDispositiveArgs
    ProductQuotation?: boolean | ProductCountOutputTypeCountProductQuotationArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountDispositiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispositiveWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductQuotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductQuotationWhereInput
  }


  /**
   * Count Type QuotationCountOutputType
   */

  export type QuotationCountOutputType = {
    ProductQuotation: number
  }

  export type QuotationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductQuotation?: boolean | QuotationCountOutputTypeCountProductQuotationArgs
  }

  // Custom InputTypes
  /**
   * QuotationCountOutputType without action
   */
  export type QuotationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationCountOutputType
     */
    select?: QuotationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuotationCountOutputType without action
   */
  export type QuotationCountOutputTypeCountProductQuotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductQuotationWhereInput
  }


  /**
   * Count Type SuperAdminCountOutputType
   */

  export type SuperAdminCountOutputType = {
    Admin: number
  }

  export type SuperAdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Admin?: boolean | SuperAdminCountOutputTypeCountAdminArgs
  }

  // Custom InputTypes
  /**
   * SuperAdminCountOutputType without action
   */
  export type SuperAdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminCountOutputType
     */
    select?: SuperAdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SuperAdminCountOutputType without action
   */
  export type SuperAdminCountOutputTypeCountAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }


  /**
   * Count Type TransactionCountOutputType
   */

  export type TransactionCountOutputType = {
    ProductTransaction: number
  }

  export type TransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductTransaction?: boolean | TransactionCountOutputTypeCountProductTransactionArgs
  }

  // Custom InputTypes
  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCountOutputType
     */
    select?: TransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountProductTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTransactionWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Dispositive: number
    Quotation: number
    Transaction: number
    Helper: number
    Notification: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Dispositive?: boolean | UserCountOutputTypeCountDispositiveArgs
    Quotation?: boolean | UserCountOutputTypeCountQuotationArgs
    Transaction?: boolean | UserCountOutputTypeCountTransactionArgs
    Helper?: boolean | UserCountOutputTypeCountHelperArgs
    Notification?: boolean | UserCountOutputTypeCountNotificationArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDispositiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispositiveWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHelperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelperWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
    add_by: number | null
    privilege: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
    add_by: number | null
    privilege: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
    phone: string | null
    add_by: number | null
    privilege: number | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
    phone: string | null
    add_by: number | null
    privilege: number | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    email: number
    password: number
    phone: number
    add_by: number
    privilege: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
    add_by?: true
    privilege?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
    add_by?: true
    privilege?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
    add_by?: true
    privilege?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
    add_by?: true
    privilege?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
    add_by?: true
    privilege?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone: string | null
    add_by: number
    privilege: number
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    add_by?: boolean
    privilege?: boolean
    SuperAdmin?: boolean | SuperAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    add_by?: boolean
    privilege?: boolean
    SuperAdmin?: boolean | SuperAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    add_by?: boolean
    privilege?: boolean
    SuperAdmin?: boolean | SuperAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    add_by?: boolean
    privilege?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "first_name" | "last_name" | "email" | "password" | "phone" | "add_by" | "privilege", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SuperAdmin?: boolean | SuperAdminDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SuperAdmin?: boolean | SuperAdminDefaultArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SuperAdmin?: boolean | SuperAdminDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      SuperAdmin: Prisma.$SuperAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      first_name: string
      last_name: string
      email: string
      password: string
      phone: string | null
      add_by: number
      privilege: number
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SuperAdmin<T extends SuperAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SuperAdminDefaultArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'Int'>
    readonly first_name: FieldRef<"Admin", 'String'>
    readonly last_name: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly password: FieldRef<"Admin", 'String'>
    readonly phone: FieldRef<"Admin", 'String'>
    readonly add_by: FieldRef<"Admin", 'Int'>
    readonly privilege: FieldRef<"Admin", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Commercial
   */

  export type AggregateCommercial = {
    _count: CommercialCountAggregateOutputType | null
    _avg: CommercialAvgAggregateOutputType | null
    _sum: CommercialSumAggregateOutputType | null
    _min: CommercialMinAggregateOutputType | null
    _max: CommercialMaxAggregateOutputType | null
  }

  export type CommercialAvgAggregateOutputType = {
    id: number | null
  }

  export type CommercialSumAggregateOutputType = {
    id: number | null
  }

  export type CommercialMinAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
    phone: string | null
  }

  export type CommercialMaxAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
    phone: string | null
  }

  export type CommercialCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    email: number
    password: number
    phone: number
    _all: number
  }


  export type CommercialAvgAggregateInputType = {
    id?: true
  }

  export type CommercialSumAggregateInputType = {
    id?: true
  }

  export type CommercialMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
  }

  export type CommercialMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
  }

  export type CommercialCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
    _all?: true
  }

  export type CommercialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commercial to aggregate.
     */
    where?: CommercialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commercials to fetch.
     */
    orderBy?: CommercialOrderByWithRelationInput | CommercialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommercialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commercials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commercials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Commercials
    **/
    _count?: true | CommercialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommercialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommercialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommercialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommercialMaxAggregateInputType
  }

  export type GetCommercialAggregateType<T extends CommercialAggregateArgs> = {
        [P in keyof T & keyof AggregateCommercial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommercial[P]>
      : GetScalarType<T[P], AggregateCommercial[P]>
  }




  export type CommercialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommercialWhereInput
    orderBy?: CommercialOrderByWithAggregationInput | CommercialOrderByWithAggregationInput[]
    by: CommercialScalarFieldEnum[] | CommercialScalarFieldEnum
    having?: CommercialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommercialCountAggregateInputType | true
    _avg?: CommercialAvgAggregateInputType
    _sum?: CommercialSumAggregateInputType
    _min?: CommercialMinAggregateInputType
    _max?: CommercialMaxAggregateInputType
  }

  export type CommercialGroupByOutputType = {
    id: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone: string | null
    _count: CommercialCountAggregateOutputType | null
    _avg: CommercialAvgAggregateOutputType | null
    _sum: CommercialSumAggregateOutputType | null
    _min: CommercialMinAggregateOutputType | null
    _max: CommercialMaxAggregateOutputType | null
  }

  type GetCommercialGroupByPayload<T extends CommercialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommercialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommercialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommercialGroupByOutputType[P]>
            : GetScalarType<T[P], CommercialGroupByOutputType[P]>
        }
      >
    >


  export type CommercialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    Transaction?: boolean | Commercial$TransactionArgs<ExtArgs>
    _count?: boolean | CommercialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commercial"]>

  export type CommercialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
  }, ExtArgs["result"]["commercial"]>

  export type CommercialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
  }, ExtArgs["result"]["commercial"]>

  export type CommercialSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
  }

  export type CommercialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "first_name" | "last_name" | "email" | "password" | "phone", ExtArgs["result"]["commercial"]>
  export type CommercialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Transaction?: boolean | Commercial$TransactionArgs<ExtArgs>
    _count?: boolean | CommercialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommercialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CommercialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CommercialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Commercial"
    objects: {
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      first_name: string
      last_name: string
      email: string
      password: string
      phone: string | null
    }, ExtArgs["result"]["commercial"]>
    composites: {}
  }

  type CommercialGetPayload<S extends boolean | null | undefined | CommercialDefaultArgs> = $Result.GetResult<Prisma.$CommercialPayload, S>

  type CommercialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommercialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommercialCountAggregateInputType | true
    }

  export interface CommercialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Commercial'], meta: { name: 'Commercial' } }
    /**
     * Find zero or one Commercial that matches the filter.
     * @param {CommercialFindUniqueArgs} args - Arguments to find a Commercial
     * @example
     * // Get one Commercial
     * const commercial = await prisma.commercial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommercialFindUniqueArgs>(args: SelectSubset<T, CommercialFindUniqueArgs<ExtArgs>>): Prisma__CommercialClient<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Commercial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommercialFindUniqueOrThrowArgs} args - Arguments to find a Commercial
     * @example
     * // Get one Commercial
     * const commercial = await prisma.commercial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommercialFindUniqueOrThrowArgs>(args: SelectSubset<T, CommercialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommercialClient<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Commercial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommercialFindFirstArgs} args - Arguments to find a Commercial
     * @example
     * // Get one Commercial
     * const commercial = await prisma.commercial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommercialFindFirstArgs>(args?: SelectSubset<T, CommercialFindFirstArgs<ExtArgs>>): Prisma__CommercialClient<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Commercial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommercialFindFirstOrThrowArgs} args - Arguments to find a Commercial
     * @example
     * // Get one Commercial
     * const commercial = await prisma.commercial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommercialFindFirstOrThrowArgs>(args?: SelectSubset<T, CommercialFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommercialClient<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Commercials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommercialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commercials
     * const commercials = await prisma.commercial.findMany()
     * 
     * // Get first 10 Commercials
     * const commercials = await prisma.commercial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commercialWithIdOnly = await prisma.commercial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommercialFindManyArgs>(args?: SelectSubset<T, CommercialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Commercial.
     * @param {CommercialCreateArgs} args - Arguments to create a Commercial.
     * @example
     * // Create one Commercial
     * const Commercial = await prisma.commercial.create({
     *   data: {
     *     // ... data to create a Commercial
     *   }
     * })
     * 
     */
    create<T extends CommercialCreateArgs>(args: SelectSubset<T, CommercialCreateArgs<ExtArgs>>): Prisma__CommercialClient<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Commercials.
     * @param {CommercialCreateManyArgs} args - Arguments to create many Commercials.
     * @example
     * // Create many Commercials
     * const commercial = await prisma.commercial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommercialCreateManyArgs>(args?: SelectSubset<T, CommercialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Commercials and returns the data saved in the database.
     * @param {CommercialCreateManyAndReturnArgs} args - Arguments to create many Commercials.
     * @example
     * // Create many Commercials
     * const commercial = await prisma.commercial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Commercials and only return the `id`
     * const commercialWithIdOnly = await prisma.commercial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommercialCreateManyAndReturnArgs>(args?: SelectSubset<T, CommercialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Commercial.
     * @param {CommercialDeleteArgs} args - Arguments to delete one Commercial.
     * @example
     * // Delete one Commercial
     * const Commercial = await prisma.commercial.delete({
     *   where: {
     *     // ... filter to delete one Commercial
     *   }
     * })
     * 
     */
    delete<T extends CommercialDeleteArgs>(args: SelectSubset<T, CommercialDeleteArgs<ExtArgs>>): Prisma__CommercialClient<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Commercial.
     * @param {CommercialUpdateArgs} args - Arguments to update one Commercial.
     * @example
     * // Update one Commercial
     * const commercial = await prisma.commercial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommercialUpdateArgs>(args: SelectSubset<T, CommercialUpdateArgs<ExtArgs>>): Prisma__CommercialClient<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Commercials.
     * @param {CommercialDeleteManyArgs} args - Arguments to filter Commercials to delete.
     * @example
     * // Delete a few Commercials
     * const { count } = await prisma.commercial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommercialDeleteManyArgs>(args?: SelectSubset<T, CommercialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commercials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommercialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commercials
     * const commercial = await prisma.commercial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommercialUpdateManyArgs>(args: SelectSubset<T, CommercialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commercials and returns the data updated in the database.
     * @param {CommercialUpdateManyAndReturnArgs} args - Arguments to update many Commercials.
     * @example
     * // Update many Commercials
     * const commercial = await prisma.commercial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Commercials and only return the `id`
     * const commercialWithIdOnly = await prisma.commercial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommercialUpdateManyAndReturnArgs>(args: SelectSubset<T, CommercialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Commercial.
     * @param {CommercialUpsertArgs} args - Arguments to update or create a Commercial.
     * @example
     * // Update or create a Commercial
     * const commercial = await prisma.commercial.upsert({
     *   create: {
     *     // ... data to create a Commercial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Commercial we want to update
     *   }
     * })
     */
    upsert<T extends CommercialUpsertArgs>(args: SelectSubset<T, CommercialUpsertArgs<ExtArgs>>): Prisma__CommercialClient<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Commercials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommercialCountArgs} args - Arguments to filter Commercials to count.
     * @example
     * // Count the number of Commercials
     * const count = await prisma.commercial.count({
     *   where: {
     *     // ... the filter for the Commercials we want to count
     *   }
     * })
    **/
    count<T extends CommercialCountArgs>(
      args?: Subset<T, CommercialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommercialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Commercial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommercialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommercialAggregateArgs>(args: Subset<T, CommercialAggregateArgs>): Prisma.PrismaPromise<GetCommercialAggregateType<T>>

    /**
     * Group by Commercial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommercialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommercialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommercialGroupByArgs['orderBy'] }
        : { orderBy?: CommercialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommercialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommercialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Commercial model
   */
  readonly fields: CommercialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Commercial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommercialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Transaction<T extends Commercial$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, Commercial$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Commercial model
   */
  interface CommercialFieldRefs {
    readonly id: FieldRef<"Commercial", 'Int'>
    readonly first_name: FieldRef<"Commercial", 'String'>
    readonly last_name: FieldRef<"Commercial", 'String'>
    readonly email: FieldRef<"Commercial", 'String'>
    readonly password: FieldRef<"Commercial", 'String'>
    readonly phone: FieldRef<"Commercial", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Commercial findUnique
   */
  export type CommercialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
    /**
     * Filter, which Commercial to fetch.
     */
    where: CommercialWhereUniqueInput
  }

  /**
   * Commercial findUniqueOrThrow
   */
  export type CommercialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
    /**
     * Filter, which Commercial to fetch.
     */
    where: CommercialWhereUniqueInput
  }

  /**
   * Commercial findFirst
   */
  export type CommercialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
    /**
     * Filter, which Commercial to fetch.
     */
    where?: CommercialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commercials to fetch.
     */
    orderBy?: CommercialOrderByWithRelationInput | CommercialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commercials.
     */
    cursor?: CommercialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commercials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commercials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commercials.
     */
    distinct?: CommercialScalarFieldEnum | CommercialScalarFieldEnum[]
  }

  /**
   * Commercial findFirstOrThrow
   */
  export type CommercialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
    /**
     * Filter, which Commercial to fetch.
     */
    where?: CommercialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commercials to fetch.
     */
    orderBy?: CommercialOrderByWithRelationInput | CommercialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commercials.
     */
    cursor?: CommercialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commercials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commercials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commercials.
     */
    distinct?: CommercialScalarFieldEnum | CommercialScalarFieldEnum[]
  }

  /**
   * Commercial findMany
   */
  export type CommercialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
    /**
     * Filter, which Commercials to fetch.
     */
    where?: CommercialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commercials to fetch.
     */
    orderBy?: CommercialOrderByWithRelationInput | CommercialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Commercials.
     */
    cursor?: CommercialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commercials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commercials.
     */
    skip?: number
    distinct?: CommercialScalarFieldEnum | CommercialScalarFieldEnum[]
  }

  /**
   * Commercial create
   */
  export type CommercialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
    /**
     * The data needed to create a Commercial.
     */
    data: XOR<CommercialCreateInput, CommercialUncheckedCreateInput>
  }

  /**
   * Commercial createMany
   */
  export type CommercialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Commercials.
     */
    data: CommercialCreateManyInput | CommercialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Commercial createManyAndReturn
   */
  export type CommercialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * The data used to create many Commercials.
     */
    data: CommercialCreateManyInput | CommercialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Commercial update
   */
  export type CommercialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
    /**
     * The data needed to update a Commercial.
     */
    data: XOR<CommercialUpdateInput, CommercialUncheckedUpdateInput>
    /**
     * Choose, which Commercial to update.
     */
    where: CommercialWhereUniqueInput
  }

  /**
   * Commercial updateMany
   */
  export type CommercialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Commercials.
     */
    data: XOR<CommercialUpdateManyMutationInput, CommercialUncheckedUpdateManyInput>
    /**
     * Filter which Commercials to update
     */
    where?: CommercialWhereInput
    /**
     * Limit how many Commercials to update.
     */
    limit?: number
  }

  /**
   * Commercial updateManyAndReturn
   */
  export type CommercialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * The data used to update Commercials.
     */
    data: XOR<CommercialUpdateManyMutationInput, CommercialUncheckedUpdateManyInput>
    /**
     * Filter which Commercials to update
     */
    where?: CommercialWhereInput
    /**
     * Limit how many Commercials to update.
     */
    limit?: number
  }

  /**
   * Commercial upsert
   */
  export type CommercialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
    /**
     * The filter to search for the Commercial to update in case it exists.
     */
    where: CommercialWhereUniqueInput
    /**
     * In case the Commercial found by the `where` argument doesn't exist, create a new Commercial with this data.
     */
    create: XOR<CommercialCreateInput, CommercialUncheckedCreateInput>
    /**
     * In case the Commercial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommercialUpdateInput, CommercialUncheckedUpdateInput>
  }

  /**
   * Commercial delete
   */
  export type CommercialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
    /**
     * Filter which Commercial to delete.
     */
    where: CommercialWhereUniqueInput
  }

  /**
   * Commercial deleteMany
   */
  export type CommercialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commercials to delete
     */
    where?: CommercialWhereInput
    /**
     * Limit how many Commercials to delete.
     */
    limit?: number
  }

  /**
   * Commercial.Transaction
   */
  export type Commercial$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Commercial without action
   */
  export type CommercialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
  }


  /**
   * Model Decider
   */

  export type AggregateDecider = {
    _count: DeciderCountAggregateOutputType | null
    _avg: DeciderAvgAggregateOutputType | null
    _sum: DeciderSumAggregateOutputType | null
    _min: DeciderMinAggregateOutputType | null
    _max: DeciderMaxAggregateOutputType | null
  }

  export type DeciderAvgAggregateOutputType = {
    id: number | null
  }

  export type DeciderSumAggregateOutputType = {
    id: number | null
  }

  export type DeciderMinAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
    phone: string | null
  }

  export type DeciderMaxAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
    phone: string | null
  }

  export type DeciderCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    email: number
    password: number
    phone: number
    _all: number
  }


  export type DeciderAvgAggregateInputType = {
    id?: true
  }

  export type DeciderSumAggregateInputType = {
    id?: true
  }

  export type DeciderMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
  }

  export type DeciderMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
  }

  export type DeciderCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
    _all?: true
  }

  export type DeciderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Decider to aggregate.
     */
    where?: DeciderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deciders to fetch.
     */
    orderBy?: DeciderOrderByWithRelationInput | DeciderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeciderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deciders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deciders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deciders
    **/
    _count?: true | DeciderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeciderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeciderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeciderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeciderMaxAggregateInputType
  }

  export type GetDeciderAggregateType<T extends DeciderAggregateArgs> = {
        [P in keyof T & keyof AggregateDecider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDecider[P]>
      : GetScalarType<T[P], AggregateDecider[P]>
  }




  export type DeciderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeciderWhereInput
    orderBy?: DeciderOrderByWithAggregationInput | DeciderOrderByWithAggregationInput[]
    by: DeciderScalarFieldEnum[] | DeciderScalarFieldEnum
    having?: DeciderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeciderCountAggregateInputType | true
    _avg?: DeciderAvgAggregateInputType
    _sum?: DeciderSumAggregateInputType
    _min?: DeciderMinAggregateInputType
    _max?: DeciderMaxAggregateInputType
  }

  export type DeciderGroupByOutputType = {
    id: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone: string | null
    _count: DeciderCountAggregateOutputType | null
    _avg: DeciderAvgAggregateOutputType | null
    _sum: DeciderSumAggregateOutputType | null
    _min: DeciderMinAggregateOutputType | null
    _max: DeciderMaxAggregateOutputType | null
  }

  type GetDeciderGroupByPayload<T extends DeciderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeciderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeciderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeciderGroupByOutputType[P]>
            : GetScalarType<T[P], DeciderGroupByOutputType[P]>
        }
      >
    >


  export type DeciderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
  }, ExtArgs["result"]["decider"]>

  export type DeciderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
  }, ExtArgs["result"]["decider"]>

  export type DeciderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
  }, ExtArgs["result"]["decider"]>

  export type DeciderSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
  }

  export type DeciderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "first_name" | "last_name" | "email" | "password" | "phone", ExtArgs["result"]["decider"]>

  export type $DeciderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Decider"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      first_name: string
      last_name: string
      email: string
      password: string
      phone: string | null
    }, ExtArgs["result"]["decider"]>
    composites: {}
  }

  type DeciderGetPayload<S extends boolean | null | undefined | DeciderDefaultArgs> = $Result.GetResult<Prisma.$DeciderPayload, S>

  type DeciderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeciderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeciderCountAggregateInputType | true
    }

  export interface DeciderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Decider'], meta: { name: 'Decider' } }
    /**
     * Find zero or one Decider that matches the filter.
     * @param {DeciderFindUniqueArgs} args - Arguments to find a Decider
     * @example
     * // Get one Decider
     * const decider = await prisma.decider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeciderFindUniqueArgs>(args: SelectSubset<T, DeciderFindUniqueArgs<ExtArgs>>): Prisma__DeciderClient<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Decider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeciderFindUniqueOrThrowArgs} args - Arguments to find a Decider
     * @example
     * // Get one Decider
     * const decider = await prisma.decider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeciderFindUniqueOrThrowArgs>(args: SelectSubset<T, DeciderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeciderClient<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Decider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeciderFindFirstArgs} args - Arguments to find a Decider
     * @example
     * // Get one Decider
     * const decider = await prisma.decider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeciderFindFirstArgs>(args?: SelectSubset<T, DeciderFindFirstArgs<ExtArgs>>): Prisma__DeciderClient<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Decider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeciderFindFirstOrThrowArgs} args - Arguments to find a Decider
     * @example
     * // Get one Decider
     * const decider = await prisma.decider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeciderFindFirstOrThrowArgs>(args?: SelectSubset<T, DeciderFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeciderClient<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deciders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeciderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deciders
     * const deciders = await prisma.decider.findMany()
     * 
     * // Get first 10 Deciders
     * const deciders = await prisma.decider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deciderWithIdOnly = await prisma.decider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeciderFindManyArgs>(args?: SelectSubset<T, DeciderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Decider.
     * @param {DeciderCreateArgs} args - Arguments to create a Decider.
     * @example
     * // Create one Decider
     * const Decider = await prisma.decider.create({
     *   data: {
     *     // ... data to create a Decider
     *   }
     * })
     * 
     */
    create<T extends DeciderCreateArgs>(args: SelectSubset<T, DeciderCreateArgs<ExtArgs>>): Prisma__DeciderClient<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Deciders.
     * @param {DeciderCreateManyArgs} args - Arguments to create many Deciders.
     * @example
     * // Create many Deciders
     * const decider = await prisma.decider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeciderCreateManyArgs>(args?: SelectSubset<T, DeciderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deciders and returns the data saved in the database.
     * @param {DeciderCreateManyAndReturnArgs} args - Arguments to create many Deciders.
     * @example
     * // Create many Deciders
     * const decider = await prisma.decider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deciders and only return the `id`
     * const deciderWithIdOnly = await prisma.decider.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeciderCreateManyAndReturnArgs>(args?: SelectSubset<T, DeciderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Decider.
     * @param {DeciderDeleteArgs} args - Arguments to delete one Decider.
     * @example
     * // Delete one Decider
     * const Decider = await prisma.decider.delete({
     *   where: {
     *     // ... filter to delete one Decider
     *   }
     * })
     * 
     */
    delete<T extends DeciderDeleteArgs>(args: SelectSubset<T, DeciderDeleteArgs<ExtArgs>>): Prisma__DeciderClient<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Decider.
     * @param {DeciderUpdateArgs} args - Arguments to update one Decider.
     * @example
     * // Update one Decider
     * const decider = await prisma.decider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeciderUpdateArgs>(args: SelectSubset<T, DeciderUpdateArgs<ExtArgs>>): Prisma__DeciderClient<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Deciders.
     * @param {DeciderDeleteManyArgs} args - Arguments to filter Deciders to delete.
     * @example
     * // Delete a few Deciders
     * const { count } = await prisma.decider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeciderDeleteManyArgs>(args?: SelectSubset<T, DeciderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deciders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeciderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deciders
     * const decider = await prisma.decider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeciderUpdateManyArgs>(args: SelectSubset<T, DeciderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deciders and returns the data updated in the database.
     * @param {DeciderUpdateManyAndReturnArgs} args - Arguments to update many Deciders.
     * @example
     * // Update many Deciders
     * const decider = await prisma.decider.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Deciders and only return the `id`
     * const deciderWithIdOnly = await prisma.decider.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeciderUpdateManyAndReturnArgs>(args: SelectSubset<T, DeciderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Decider.
     * @param {DeciderUpsertArgs} args - Arguments to update or create a Decider.
     * @example
     * // Update or create a Decider
     * const decider = await prisma.decider.upsert({
     *   create: {
     *     // ... data to create a Decider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Decider we want to update
     *   }
     * })
     */
    upsert<T extends DeciderUpsertArgs>(args: SelectSubset<T, DeciderUpsertArgs<ExtArgs>>): Prisma__DeciderClient<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Deciders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeciderCountArgs} args - Arguments to filter Deciders to count.
     * @example
     * // Count the number of Deciders
     * const count = await prisma.decider.count({
     *   where: {
     *     // ... the filter for the Deciders we want to count
     *   }
     * })
    **/
    count<T extends DeciderCountArgs>(
      args?: Subset<T, DeciderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeciderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Decider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeciderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeciderAggregateArgs>(args: Subset<T, DeciderAggregateArgs>): Prisma.PrismaPromise<GetDeciderAggregateType<T>>

    /**
     * Group by Decider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeciderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeciderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeciderGroupByArgs['orderBy'] }
        : { orderBy?: DeciderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeciderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeciderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Decider model
   */
  readonly fields: DeciderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Decider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeciderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Decider model
   */
  interface DeciderFieldRefs {
    readonly id: FieldRef<"Decider", 'Int'>
    readonly first_name: FieldRef<"Decider", 'String'>
    readonly last_name: FieldRef<"Decider", 'String'>
    readonly email: FieldRef<"Decider", 'String'>
    readonly password: FieldRef<"Decider", 'String'>
    readonly phone: FieldRef<"Decider", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Decider findUnique
   */
  export type DeciderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * Filter, which Decider to fetch.
     */
    where: DeciderWhereUniqueInput
  }

  /**
   * Decider findUniqueOrThrow
   */
  export type DeciderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * Filter, which Decider to fetch.
     */
    where: DeciderWhereUniqueInput
  }

  /**
   * Decider findFirst
   */
  export type DeciderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * Filter, which Decider to fetch.
     */
    where?: DeciderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deciders to fetch.
     */
    orderBy?: DeciderOrderByWithRelationInput | DeciderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deciders.
     */
    cursor?: DeciderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deciders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deciders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deciders.
     */
    distinct?: DeciderScalarFieldEnum | DeciderScalarFieldEnum[]
  }

  /**
   * Decider findFirstOrThrow
   */
  export type DeciderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * Filter, which Decider to fetch.
     */
    where?: DeciderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deciders to fetch.
     */
    orderBy?: DeciderOrderByWithRelationInput | DeciderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deciders.
     */
    cursor?: DeciderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deciders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deciders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deciders.
     */
    distinct?: DeciderScalarFieldEnum | DeciderScalarFieldEnum[]
  }

  /**
   * Decider findMany
   */
  export type DeciderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * Filter, which Deciders to fetch.
     */
    where?: DeciderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deciders to fetch.
     */
    orderBy?: DeciderOrderByWithRelationInput | DeciderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deciders.
     */
    cursor?: DeciderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deciders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deciders.
     */
    skip?: number
    distinct?: DeciderScalarFieldEnum | DeciderScalarFieldEnum[]
  }

  /**
   * Decider create
   */
  export type DeciderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * The data needed to create a Decider.
     */
    data: XOR<DeciderCreateInput, DeciderUncheckedCreateInput>
  }

  /**
   * Decider createMany
   */
  export type DeciderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deciders.
     */
    data: DeciderCreateManyInput | DeciderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Decider createManyAndReturn
   */
  export type DeciderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * The data used to create many Deciders.
     */
    data: DeciderCreateManyInput | DeciderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Decider update
   */
  export type DeciderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * The data needed to update a Decider.
     */
    data: XOR<DeciderUpdateInput, DeciderUncheckedUpdateInput>
    /**
     * Choose, which Decider to update.
     */
    where: DeciderWhereUniqueInput
  }

  /**
   * Decider updateMany
   */
  export type DeciderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deciders.
     */
    data: XOR<DeciderUpdateManyMutationInput, DeciderUncheckedUpdateManyInput>
    /**
     * Filter which Deciders to update
     */
    where?: DeciderWhereInput
    /**
     * Limit how many Deciders to update.
     */
    limit?: number
  }

  /**
   * Decider updateManyAndReturn
   */
  export type DeciderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * The data used to update Deciders.
     */
    data: XOR<DeciderUpdateManyMutationInput, DeciderUncheckedUpdateManyInput>
    /**
     * Filter which Deciders to update
     */
    where?: DeciderWhereInput
    /**
     * Limit how many Deciders to update.
     */
    limit?: number
  }

  /**
   * Decider upsert
   */
  export type DeciderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * The filter to search for the Decider to update in case it exists.
     */
    where: DeciderWhereUniqueInput
    /**
     * In case the Decider found by the `where` argument doesn't exist, create a new Decider with this data.
     */
    create: XOR<DeciderCreateInput, DeciderUncheckedCreateInput>
    /**
     * In case the Decider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeciderUpdateInput, DeciderUncheckedUpdateInput>
  }

  /**
   * Decider delete
   */
  export type DeciderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * Filter which Decider to delete.
     */
    where: DeciderWhereUniqueInput
  }

  /**
   * Decider deleteMany
   */
  export type DeciderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deciders to delete
     */
    where?: DeciderWhereInput
    /**
     * Limit how many Deciders to delete.
     */
    limit?: number
  }

  /**
   * Decider without action
   */
  export type DeciderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
  }


  /**
   * Model DispoIssue
   */

  export type AggregateDispoIssue = {
    _count: DispoIssueCountAggregateOutputType | null
    _avg: DispoIssueAvgAggregateOutputType | null
    _sum: DispoIssueSumAggregateOutputType | null
    _min: DispoIssueMinAggregateOutputType | null
    _max: DispoIssueMaxAggregateOutputType | null
  }

  export type DispoIssueAvgAggregateOutputType = {
    id: number | null
    dispositiveId: number | null
    maintainerId: number | null
  }

  export type DispoIssueSumAggregateOutputType = {
    id: number | null
    dispositiveId: number | null
    maintainerId: number | null
  }

  export type DispoIssueMinAggregateOutputType = {
    id: number | null
    dispositiveId: number | null
    description: string | null
    date: Date | null
    status: string | null
    maintainerId: number | null
  }

  export type DispoIssueMaxAggregateOutputType = {
    id: number | null
    dispositiveId: number | null
    description: string | null
    date: Date | null
    status: string | null
    maintainerId: number | null
  }

  export type DispoIssueCountAggregateOutputType = {
    id: number
    dispositiveId: number
    description: number
    date: number
    status: number
    maintainerId: number
    _all: number
  }


  export type DispoIssueAvgAggregateInputType = {
    id?: true
    dispositiveId?: true
    maintainerId?: true
  }

  export type DispoIssueSumAggregateInputType = {
    id?: true
    dispositiveId?: true
    maintainerId?: true
  }

  export type DispoIssueMinAggregateInputType = {
    id?: true
    dispositiveId?: true
    description?: true
    date?: true
    status?: true
    maintainerId?: true
  }

  export type DispoIssueMaxAggregateInputType = {
    id?: true
    dispositiveId?: true
    description?: true
    date?: true
    status?: true
    maintainerId?: true
  }

  export type DispoIssueCountAggregateInputType = {
    id?: true
    dispositiveId?: true
    description?: true
    date?: true
    status?: true
    maintainerId?: true
    _all?: true
  }

  export type DispoIssueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DispoIssue to aggregate.
     */
    where?: DispoIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispoIssues to fetch.
     */
    orderBy?: DispoIssueOrderByWithRelationInput | DispoIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DispoIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispoIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispoIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DispoIssues
    **/
    _count?: true | DispoIssueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DispoIssueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DispoIssueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DispoIssueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DispoIssueMaxAggregateInputType
  }

  export type GetDispoIssueAggregateType<T extends DispoIssueAggregateArgs> = {
        [P in keyof T & keyof AggregateDispoIssue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDispoIssue[P]>
      : GetScalarType<T[P], AggregateDispoIssue[P]>
  }




  export type DispoIssueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispoIssueWhereInput
    orderBy?: DispoIssueOrderByWithAggregationInput | DispoIssueOrderByWithAggregationInput[]
    by: DispoIssueScalarFieldEnum[] | DispoIssueScalarFieldEnum
    having?: DispoIssueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DispoIssueCountAggregateInputType | true
    _avg?: DispoIssueAvgAggregateInputType
    _sum?: DispoIssueSumAggregateInputType
    _min?: DispoIssueMinAggregateInputType
    _max?: DispoIssueMaxAggregateInputType
  }

  export type DispoIssueGroupByOutputType = {
    id: number
    dispositiveId: number
    description: string
    date: Date
    status: string
    maintainerId: number | null
    _count: DispoIssueCountAggregateOutputType | null
    _avg: DispoIssueAvgAggregateOutputType | null
    _sum: DispoIssueSumAggregateOutputType | null
    _min: DispoIssueMinAggregateOutputType | null
    _max: DispoIssueMaxAggregateOutputType | null
  }

  type GetDispoIssueGroupByPayload<T extends DispoIssueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DispoIssueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DispoIssueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DispoIssueGroupByOutputType[P]>
            : GetScalarType<T[P], DispoIssueGroupByOutputType[P]>
        }
      >
    >


  export type DispoIssueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dispositiveId?: boolean
    description?: boolean
    date?: boolean
    status?: boolean
    maintainerId?: boolean
    Dispositive?: boolean | DispositiveDefaultArgs<ExtArgs>
    Maintainer?: boolean | DispoIssue$MaintainerArgs<ExtArgs>
  }, ExtArgs["result"]["dispoIssue"]>

  export type DispoIssueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dispositiveId?: boolean
    description?: boolean
    date?: boolean
    status?: boolean
    maintainerId?: boolean
    Dispositive?: boolean | DispositiveDefaultArgs<ExtArgs>
    Maintainer?: boolean | DispoIssue$MaintainerArgs<ExtArgs>
  }, ExtArgs["result"]["dispoIssue"]>

  export type DispoIssueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dispositiveId?: boolean
    description?: boolean
    date?: boolean
    status?: boolean
    maintainerId?: boolean
    Dispositive?: boolean | DispositiveDefaultArgs<ExtArgs>
    Maintainer?: boolean | DispoIssue$MaintainerArgs<ExtArgs>
  }, ExtArgs["result"]["dispoIssue"]>

  export type DispoIssueSelectScalar = {
    id?: boolean
    dispositiveId?: boolean
    description?: boolean
    date?: boolean
    status?: boolean
    maintainerId?: boolean
  }

  export type DispoIssueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dispositiveId" | "description" | "date" | "status" | "maintainerId", ExtArgs["result"]["dispoIssue"]>
  export type DispoIssueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Dispositive?: boolean | DispositiveDefaultArgs<ExtArgs>
    Maintainer?: boolean | DispoIssue$MaintainerArgs<ExtArgs>
  }
  export type DispoIssueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Dispositive?: boolean | DispositiveDefaultArgs<ExtArgs>
    Maintainer?: boolean | DispoIssue$MaintainerArgs<ExtArgs>
  }
  export type DispoIssueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Dispositive?: boolean | DispositiveDefaultArgs<ExtArgs>
    Maintainer?: boolean | DispoIssue$MaintainerArgs<ExtArgs>
  }

  export type $DispoIssuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DispoIssue"
    objects: {
      Dispositive: Prisma.$DispositivePayload<ExtArgs>
      Maintainer: Prisma.$MaintainerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dispositiveId: number
      description: string
      date: Date
      status: string
      maintainerId: number | null
    }, ExtArgs["result"]["dispoIssue"]>
    composites: {}
  }

  type DispoIssueGetPayload<S extends boolean | null | undefined | DispoIssueDefaultArgs> = $Result.GetResult<Prisma.$DispoIssuePayload, S>

  type DispoIssueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DispoIssueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DispoIssueCountAggregateInputType | true
    }

  export interface DispoIssueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DispoIssue'], meta: { name: 'DispoIssue' } }
    /**
     * Find zero or one DispoIssue that matches the filter.
     * @param {DispoIssueFindUniqueArgs} args - Arguments to find a DispoIssue
     * @example
     * // Get one DispoIssue
     * const dispoIssue = await prisma.dispoIssue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DispoIssueFindUniqueArgs>(args: SelectSubset<T, DispoIssueFindUniqueArgs<ExtArgs>>): Prisma__DispoIssueClient<$Result.GetResult<Prisma.$DispoIssuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DispoIssue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DispoIssueFindUniqueOrThrowArgs} args - Arguments to find a DispoIssue
     * @example
     * // Get one DispoIssue
     * const dispoIssue = await prisma.dispoIssue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DispoIssueFindUniqueOrThrowArgs>(args: SelectSubset<T, DispoIssueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DispoIssueClient<$Result.GetResult<Prisma.$DispoIssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DispoIssue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispoIssueFindFirstArgs} args - Arguments to find a DispoIssue
     * @example
     * // Get one DispoIssue
     * const dispoIssue = await prisma.dispoIssue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DispoIssueFindFirstArgs>(args?: SelectSubset<T, DispoIssueFindFirstArgs<ExtArgs>>): Prisma__DispoIssueClient<$Result.GetResult<Prisma.$DispoIssuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DispoIssue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispoIssueFindFirstOrThrowArgs} args - Arguments to find a DispoIssue
     * @example
     * // Get one DispoIssue
     * const dispoIssue = await prisma.dispoIssue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DispoIssueFindFirstOrThrowArgs>(args?: SelectSubset<T, DispoIssueFindFirstOrThrowArgs<ExtArgs>>): Prisma__DispoIssueClient<$Result.GetResult<Prisma.$DispoIssuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DispoIssues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispoIssueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DispoIssues
     * const dispoIssues = await prisma.dispoIssue.findMany()
     * 
     * // Get first 10 DispoIssues
     * const dispoIssues = await prisma.dispoIssue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dispoIssueWithIdOnly = await prisma.dispoIssue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DispoIssueFindManyArgs>(args?: SelectSubset<T, DispoIssueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispoIssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DispoIssue.
     * @param {DispoIssueCreateArgs} args - Arguments to create a DispoIssue.
     * @example
     * // Create one DispoIssue
     * const DispoIssue = await prisma.dispoIssue.create({
     *   data: {
     *     // ... data to create a DispoIssue
     *   }
     * })
     * 
     */
    create<T extends DispoIssueCreateArgs>(args: SelectSubset<T, DispoIssueCreateArgs<ExtArgs>>): Prisma__DispoIssueClient<$Result.GetResult<Prisma.$DispoIssuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DispoIssues.
     * @param {DispoIssueCreateManyArgs} args - Arguments to create many DispoIssues.
     * @example
     * // Create many DispoIssues
     * const dispoIssue = await prisma.dispoIssue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DispoIssueCreateManyArgs>(args?: SelectSubset<T, DispoIssueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DispoIssues and returns the data saved in the database.
     * @param {DispoIssueCreateManyAndReturnArgs} args - Arguments to create many DispoIssues.
     * @example
     * // Create many DispoIssues
     * const dispoIssue = await prisma.dispoIssue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DispoIssues and only return the `id`
     * const dispoIssueWithIdOnly = await prisma.dispoIssue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DispoIssueCreateManyAndReturnArgs>(args?: SelectSubset<T, DispoIssueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispoIssuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DispoIssue.
     * @param {DispoIssueDeleteArgs} args - Arguments to delete one DispoIssue.
     * @example
     * // Delete one DispoIssue
     * const DispoIssue = await prisma.dispoIssue.delete({
     *   where: {
     *     // ... filter to delete one DispoIssue
     *   }
     * })
     * 
     */
    delete<T extends DispoIssueDeleteArgs>(args: SelectSubset<T, DispoIssueDeleteArgs<ExtArgs>>): Prisma__DispoIssueClient<$Result.GetResult<Prisma.$DispoIssuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DispoIssue.
     * @param {DispoIssueUpdateArgs} args - Arguments to update one DispoIssue.
     * @example
     * // Update one DispoIssue
     * const dispoIssue = await prisma.dispoIssue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DispoIssueUpdateArgs>(args: SelectSubset<T, DispoIssueUpdateArgs<ExtArgs>>): Prisma__DispoIssueClient<$Result.GetResult<Prisma.$DispoIssuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DispoIssues.
     * @param {DispoIssueDeleteManyArgs} args - Arguments to filter DispoIssues to delete.
     * @example
     * // Delete a few DispoIssues
     * const { count } = await prisma.dispoIssue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DispoIssueDeleteManyArgs>(args?: SelectSubset<T, DispoIssueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DispoIssues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispoIssueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DispoIssues
     * const dispoIssue = await prisma.dispoIssue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DispoIssueUpdateManyArgs>(args: SelectSubset<T, DispoIssueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DispoIssues and returns the data updated in the database.
     * @param {DispoIssueUpdateManyAndReturnArgs} args - Arguments to update many DispoIssues.
     * @example
     * // Update many DispoIssues
     * const dispoIssue = await prisma.dispoIssue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DispoIssues and only return the `id`
     * const dispoIssueWithIdOnly = await prisma.dispoIssue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DispoIssueUpdateManyAndReturnArgs>(args: SelectSubset<T, DispoIssueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispoIssuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DispoIssue.
     * @param {DispoIssueUpsertArgs} args - Arguments to update or create a DispoIssue.
     * @example
     * // Update or create a DispoIssue
     * const dispoIssue = await prisma.dispoIssue.upsert({
     *   create: {
     *     // ... data to create a DispoIssue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DispoIssue we want to update
     *   }
     * })
     */
    upsert<T extends DispoIssueUpsertArgs>(args: SelectSubset<T, DispoIssueUpsertArgs<ExtArgs>>): Prisma__DispoIssueClient<$Result.GetResult<Prisma.$DispoIssuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DispoIssues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispoIssueCountArgs} args - Arguments to filter DispoIssues to count.
     * @example
     * // Count the number of DispoIssues
     * const count = await prisma.dispoIssue.count({
     *   where: {
     *     // ... the filter for the DispoIssues we want to count
     *   }
     * })
    **/
    count<T extends DispoIssueCountArgs>(
      args?: Subset<T, DispoIssueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DispoIssueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DispoIssue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispoIssueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DispoIssueAggregateArgs>(args: Subset<T, DispoIssueAggregateArgs>): Prisma.PrismaPromise<GetDispoIssueAggregateType<T>>

    /**
     * Group by DispoIssue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispoIssueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DispoIssueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DispoIssueGroupByArgs['orderBy'] }
        : { orderBy?: DispoIssueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DispoIssueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDispoIssueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DispoIssue model
   */
  readonly fields: DispoIssueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DispoIssue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DispoIssueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Dispositive<T extends DispositiveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DispositiveDefaultArgs<ExtArgs>>): Prisma__DispositiveClient<$Result.GetResult<Prisma.$DispositivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Maintainer<T extends DispoIssue$MaintainerArgs<ExtArgs> = {}>(args?: Subset<T, DispoIssue$MaintainerArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DispoIssue model
   */
  interface DispoIssueFieldRefs {
    readonly id: FieldRef<"DispoIssue", 'Int'>
    readonly dispositiveId: FieldRef<"DispoIssue", 'Int'>
    readonly description: FieldRef<"DispoIssue", 'String'>
    readonly date: FieldRef<"DispoIssue", 'DateTime'>
    readonly status: FieldRef<"DispoIssue", 'String'>
    readonly maintainerId: FieldRef<"DispoIssue", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DispoIssue findUnique
   */
  export type DispoIssueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispoIssue
     */
    select?: DispoIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispoIssue
     */
    omit?: DispoIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispoIssueInclude<ExtArgs> | null
    /**
     * Filter, which DispoIssue to fetch.
     */
    where: DispoIssueWhereUniqueInput
  }

  /**
   * DispoIssue findUniqueOrThrow
   */
  export type DispoIssueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispoIssue
     */
    select?: DispoIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispoIssue
     */
    omit?: DispoIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispoIssueInclude<ExtArgs> | null
    /**
     * Filter, which DispoIssue to fetch.
     */
    where: DispoIssueWhereUniqueInput
  }

  /**
   * DispoIssue findFirst
   */
  export type DispoIssueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispoIssue
     */
    select?: DispoIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispoIssue
     */
    omit?: DispoIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispoIssueInclude<ExtArgs> | null
    /**
     * Filter, which DispoIssue to fetch.
     */
    where?: DispoIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispoIssues to fetch.
     */
    orderBy?: DispoIssueOrderByWithRelationInput | DispoIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DispoIssues.
     */
    cursor?: DispoIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispoIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispoIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DispoIssues.
     */
    distinct?: DispoIssueScalarFieldEnum | DispoIssueScalarFieldEnum[]
  }

  /**
   * DispoIssue findFirstOrThrow
   */
  export type DispoIssueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispoIssue
     */
    select?: DispoIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispoIssue
     */
    omit?: DispoIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispoIssueInclude<ExtArgs> | null
    /**
     * Filter, which DispoIssue to fetch.
     */
    where?: DispoIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispoIssues to fetch.
     */
    orderBy?: DispoIssueOrderByWithRelationInput | DispoIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DispoIssues.
     */
    cursor?: DispoIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispoIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispoIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DispoIssues.
     */
    distinct?: DispoIssueScalarFieldEnum | DispoIssueScalarFieldEnum[]
  }

  /**
   * DispoIssue findMany
   */
  export type DispoIssueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispoIssue
     */
    select?: DispoIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispoIssue
     */
    omit?: DispoIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispoIssueInclude<ExtArgs> | null
    /**
     * Filter, which DispoIssues to fetch.
     */
    where?: DispoIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispoIssues to fetch.
     */
    orderBy?: DispoIssueOrderByWithRelationInput | DispoIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DispoIssues.
     */
    cursor?: DispoIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispoIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispoIssues.
     */
    skip?: number
    distinct?: DispoIssueScalarFieldEnum | DispoIssueScalarFieldEnum[]
  }

  /**
   * DispoIssue create
   */
  export type DispoIssueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispoIssue
     */
    select?: DispoIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispoIssue
     */
    omit?: DispoIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispoIssueInclude<ExtArgs> | null
    /**
     * The data needed to create a DispoIssue.
     */
    data: XOR<DispoIssueCreateInput, DispoIssueUncheckedCreateInput>
  }

  /**
   * DispoIssue createMany
   */
  export type DispoIssueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DispoIssues.
     */
    data: DispoIssueCreateManyInput | DispoIssueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DispoIssue createManyAndReturn
   */
  export type DispoIssueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispoIssue
     */
    select?: DispoIssueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DispoIssue
     */
    omit?: DispoIssueOmit<ExtArgs> | null
    /**
     * The data used to create many DispoIssues.
     */
    data: DispoIssueCreateManyInput | DispoIssueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispoIssueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DispoIssue update
   */
  export type DispoIssueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispoIssue
     */
    select?: DispoIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispoIssue
     */
    omit?: DispoIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispoIssueInclude<ExtArgs> | null
    /**
     * The data needed to update a DispoIssue.
     */
    data: XOR<DispoIssueUpdateInput, DispoIssueUncheckedUpdateInput>
    /**
     * Choose, which DispoIssue to update.
     */
    where: DispoIssueWhereUniqueInput
  }

  /**
   * DispoIssue updateMany
   */
  export type DispoIssueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DispoIssues.
     */
    data: XOR<DispoIssueUpdateManyMutationInput, DispoIssueUncheckedUpdateManyInput>
    /**
     * Filter which DispoIssues to update
     */
    where?: DispoIssueWhereInput
    /**
     * Limit how many DispoIssues to update.
     */
    limit?: number
  }

  /**
   * DispoIssue updateManyAndReturn
   */
  export type DispoIssueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispoIssue
     */
    select?: DispoIssueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DispoIssue
     */
    omit?: DispoIssueOmit<ExtArgs> | null
    /**
     * The data used to update DispoIssues.
     */
    data: XOR<DispoIssueUpdateManyMutationInput, DispoIssueUncheckedUpdateManyInput>
    /**
     * Filter which DispoIssues to update
     */
    where?: DispoIssueWhereInput
    /**
     * Limit how many DispoIssues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispoIssueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DispoIssue upsert
   */
  export type DispoIssueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispoIssue
     */
    select?: DispoIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispoIssue
     */
    omit?: DispoIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispoIssueInclude<ExtArgs> | null
    /**
     * The filter to search for the DispoIssue to update in case it exists.
     */
    where: DispoIssueWhereUniqueInput
    /**
     * In case the DispoIssue found by the `where` argument doesn't exist, create a new DispoIssue with this data.
     */
    create: XOR<DispoIssueCreateInput, DispoIssueUncheckedCreateInput>
    /**
     * In case the DispoIssue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DispoIssueUpdateInput, DispoIssueUncheckedUpdateInput>
  }

  /**
   * DispoIssue delete
   */
  export type DispoIssueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispoIssue
     */
    select?: DispoIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispoIssue
     */
    omit?: DispoIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispoIssueInclude<ExtArgs> | null
    /**
     * Filter which DispoIssue to delete.
     */
    where: DispoIssueWhereUniqueInput
  }

  /**
   * DispoIssue deleteMany
   */
  export type DispoIssueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DispoIssues to delete
     */
    where?: DispoIssueWhereInput
    /**
     * Limit how many DispoIssues to delete.
     */
    limit?: number
  }

  /**
   * DispoIssue.Maintainer
   */
  export type DispoIssue$MaintainerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    where?: MaintainerWhereInput
  }

  /**
   * DispoIssue without action
   */
  export type DispoIssueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispoIssue
     */
    select?: DispoIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispoIssue
     */
    omit?: DispoIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispoIssueInclude<ExtArgs> | null
  }


  /**
   * Model Dispositive
   */

  export type AggregateDispositive = {
    _count: DispositiveCountAggregateOutputType | null
    _avg: DispositiveAvgAggregateOutputType | null
    _sum: DispositiveSumAggregateOutputType | null
    _min: DispositiveMinAggregateOutputType | null
    _max: DispositiveMaxAggregateOutputType | null
  }

  export type DispositiveAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    product_id: number | null
  }

  export type DispositiveSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    product_id: number | null
  }

  export type DispositiveMinAggregateOutputType = {
    id: number | null
    type: string | null
    start_date: Date | null
    end_date: Date | null
    initial_state: string | null
    MAC: string | null
    state: string | null
    user_id: number | null
    product_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DispositiveMaxAggregateOutputType = {
    id: number | null
    type: string | null
    start_date: Date | null
    end_date: Date | null
    initial_state: string | null
    MAC: string | null
    state: string | null
    user_id: number | null
    product_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DispositiveCountAggregateOutputType = {
    id: number
    type: number
    start_date: number
    end_date: number
    initial_state: number
    MAC: number
    state: number
    user_id: number
    product_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DispositiveAvgAggregateInputType = {
    id?: true
    user_id?: true
    product_id?: true
  }

  export type DispositiveSumAggregateInputType = {
    id?: true
    user_id?: true
    product_id?: true
  }

  export type DispositiveMinAggregateInputType = {
    id?: true
    type?: true
    start_date?: true
    end_date?: true
    initial_state?: true
    MAC?: true
    state?: true
    user_id?: true
    product_id?: true
    created_at?: true
    updated_at?: true
  }

  export type DispositiveMaxAggregateInputType = {
    id?: true
    type?: true
    start_date?: true
    end_date?: true
    initial_state?: true
    MAC?: true
    state?: true
    user_id?: true
    product_id?: true
    created_at?: true
    updated_at?: true
  }

  export type DispositiveCountAggregateInputType = {
    id?: true
    type?: true
    start_date?: true
    end_date?: true
    initial_state?: true
    MAC?: true
    state?: true
    user_id?: true
    product_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DispositiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dispositive to aggregate.
     */
    where?: DispositiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dispositives to fetch.
     */
    orderBy?: DispositiveOrderByWithRelationInput | DispositiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DispositiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dispositives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dispositives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dispositives
    **/
    _count?: true | DispositiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DispositiveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DispositiveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DispositiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DispositiveMaxAggregateInputType
  }

  export type GetDispositiveAggregateType<T extends DispositiveAggregateArgs> = {
        [P in keyof T & keyof AggregateDispositive]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDispositive[P]>
      : GetScalarType<T[P], AggregateDispositive[P]>
  }




  export type DispositiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispositiveWhereInput
    orderBy?: DispositiveOrderByWithAggregationInput | DispositiveOrderByWithAggregationInput[]
    by: DispositiveScalarFieldEnum[] | DispositiveScalarFieldEnum
    having?: DispositiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DispositiveCountAggregateInputType | true
    _avg?: DispositiveAvgAggregateInputType
    _sum?: DispositiveSumAggregateInputType
    _min?: DispositiveMinAggregateInputType
    _max?: DispositiveMaxAggregateInputType
  }

  export type DispositiveGroupByOutputType = {
    id: number
    type: string
    start_date: Date
    end_date: Date
    initial_state: string
    MAC: string
    state: string
    user_id: number | null
    product_id: number
    created_at: Date
    updated_at: Date
    _count: DispositiveCountAggregateOutputType | null
    _avg: DispositiveAvgAggregateOutputType | null
    _sum: DispositiveSumAggregateOutputType | null
    _min: DispositiveMinAggregateOutputType | null
    _max: DispositiveMaxAggregateOutputType | null
  }

  type GetDispositiveGroupByPayload<T extends DispositiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DispositiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DispositiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DispositiveGroupByOutputType[P]>
            : GetScalarType<T[P], DispositiveGroupByOutputType[P]>
        }
      >
    >


  export type DispositiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    start_date?: boolean
    end_date?: boolean
    initial_state?: boolean
    MAC?: boolean
    state?: boolean
    user_id?: boolean
    product_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    DispotiveIssue?: boolean | Dispositive$DispotiveIssueArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    User?: boolean | Dispositive$UserArgs<ExtArgs>
    Intervention?: boolean | Dispositive$InterventionArgs<ExtArgs>
    ProductTransaction?: boolean | Dispositive$ProductTransactionArgs<ExtArgs>
    _count?: boolean | DispositiveCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispositive"]>

  export type DispositiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    start_date?: boolean
    end_date?: boolean
    initial_state?: boolean
    MAC?: boolean
    state?: boolean
    user_id?: boolean
    product_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    User?: boolean | Dispositive$UserArgs<ExtArgs>
  }, ExtArgs["result"]["dispositive"]>

  export type DispositiveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    start_date?: boolean
    end_date?: boolean
    initial_state?: boolean
    MAC?: boolean
    state?: boolean
    user_id?: boolean
    product_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    User?: boolean | Dispositive$UserArgs<ExtArgs>
  }, ExtArgs["result"]["dispositive"]>

  export type DispositiveSelectScalar = {
    id?: boolean
    type?: boolean
    start_date?: boolean
    end_date?: boolean
    initial_state?: boolean
    MAC?: boolean
    state?: boolean
    user_id?: boolean
    product_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type DispositiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "start_date" | "end_date" | "initial_state" | "MAC" | "state" | "user_id" | "product_id" | "created_at" | "updated_at", ExtArgs["result"]["dispositive"]>
  export type DispositiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DispotiveIssue?: boolean | Dispositive$DispotiveIssueArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    User?: boolean | Dispositive$UserArgs<ExtArgs>
    Intervention?: boolean | Dispositive$InterventionArgs<ExtArgs>
    ProductTransaction?: boolean | Dispositive$ProductTransactionArgs<ExtArgs>
    _count?: boolean | DispositiveCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DispositiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    User?: boolean | Dispositive$UserArgs<ExtArgs>
  }
  export type DispositiveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    User?: boolean | Dispositive$UserArgs<ExtArgs>
  }

  export type $DispositivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dispositive"
    objects: {
      DispotiveIssue: Prisma.$DispoIssuePayload<ExtArgs>[]
      Product: Prisma.$ProductPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs> | null
      Intervention: Prisma.$InterventionPayload<ExtArgs>[]
      ProductTransaction: Prisma.$ProductTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      start_date: Date
      end_date: Date
      initial_state: string
      MAC: string
      state: string
      user_id: number | null
      product_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["dispositive"]>
    composites: {}
  }

  type DispositiveGetPayload<S extends boolean | null | undefined | DispositiveDefaultArgs> = $Result.GetResult<Prisma.$DispositivePayload, S>

  type DispositiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DispositiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DispositiveCountAggregateInputType | true
    }

  export interface DispositiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dispositive'], meta: { name: 'Dispositive' } }
    /**
     * Find zero or one Dispositive that matches the filter.
     * @param {DispositiveFindUniqueArgs} args - Arguments to find a Dispositive
     * @example
     * // Get one Dispositive
     * const dispositive = await prisma.dispositive.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DispositiveFindUniqueArgs>(args: SelectSubset<T, DispositiveFindUniqueArgs<ExtArgs>>): Prisma__DispositiveClient<$Result.GetResult<Prisma.$DispositivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dispositive that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DispositiveFindUniqueOrThrowArgs} args - Arguments to find a Dispositive
     * @example
     * // Get one Dispositive
     * const dispositive = await prisma.dispositive.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DispositiveFindUniqueOrThrowArgs>(args: SelectSubset<T, DispositiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DispositiveClient<$Result.GetResult<Prisma.$DispositivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dispositive that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispositiveFindFirstArgs} args - Arguments to find a Dispositive
     * @example
     * // Get one Dispositive
     * const dispositive = await prisma.dispositive.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DispositiveFindFirstArgs>(args?: SelectSubset<T, DispositiveFindFirstArgs<ExtArgs>>): Prisma__DispositiveClient<$Result.GetResult<Prisma.$DispositivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dispositive that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispositiveFindFirstOrThrowArgs} args - Arguments to find a Dispositive
     * @example
     * // Get one Dispositive
     * const dispositive = await prisma.dispositive.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DispositiveFindFirstOrThrowArgs>(args?: SelectSubset<T, DispositiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__DispositiveClient<$Result.GetResult<Prisma.$DispositivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dispositives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispositiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dispositives
     * const dispositives = await prisma.dispositive.findMany()
     * 
     * // Get first 10 Dispositives
     * const dispositives = await prisma.dispositive.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dispositiveWithIdOnly = await prisma.dispositive.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DispositiveFindManyArgs>(args?: SelectSubset<T, DispositiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispositivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dispositive.
     * @param {DispositiveCreateArgs} args - Arguments to create a Dispositive.
     * @example
     * // Create one Dispositive
     * const Dispositive = await prisma.dispositive.create({
     *   data: {
     *     // ... data to create a Dispositive
     *   }
     * })
     * 
     */
    create<T extends DispositiveCreateArgs>(args: SelectSubset<T, DispositiveCreateArgs<ExtArgs>>): Prisma__DispositiveClient<$Result.GetResult<Prisma.$DispositivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dispositives.
     * @param {DispositiveCreateManyArgs} args - Arguments to create many Dispositives.
     * @example
     * // Create many Dispositives
     * const dispositive = await prisma.dispositive.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DispositiveCreateManyArgs>(args?: SelectSubset<T, DispositiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dispositives and returns the data saved in the database.
     * @param {DispositiveCreateManyAndReturnArgs} args - Arguments to create many Dispositives.
     * @example
     * // Create many Dispositives
     * const dispositive = await prisma.dispositive.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dispositives and only return the `id`
     * const dispositiveWithIdOnly = await prisma.dispositive.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DispositiveCreateManyAndReturnArgs>(args?: SelectSubset<T, DispositiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispositivePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Dispositive.
     * @param {DispositiveDeleteArgs} args - Arguments to delete one Dispositive.
     * @example
     * // Delete one Dispositive
     * const Dispositive = await prisma.dispositive.delete({
     *   where: {
     *     // ... filter to delete one Dispositive
     *   }
     * })
     * 
     */
    delete<T extends DispositiveDeleteArgs>(args: SelectSubset<T, DispositiveDeleteArgs<ExtArgs>>): Prisma__DispositiveClient<$Result.GetResult<Prisma.$DispositivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dispositive.
     * @param {DispositiveUpdateArgs} args - Arguments to update one Dispositive.
     * @example
     * // Update one Dispositive
     * const dispositive = await prisma.dispositive.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DispositiveUpdateArgs>(args: SelectSubset<T, DispositiveUpdateArgs<ExtArgs>>): Prisma__DispositiveClient<$Result.GetResult<Prisma.$DispositivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dispositives.
     * @param {DispositiveDeleteManyArgs} args - Arguments to filter Dispositives to delete.
     * @example
     * // Delete a few Dispositives
     * const { count } = await prisma.dispositive.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DispositiveDeleteManyArgs>(args?: SelectSubset<T, DispositiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dispositives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispositiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dispositives
     * const dispositive = await prisma.dispositive.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DispositiveUpdateManyArgs>(args: SelectSubset<T, DispositiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dispositives and returns the data updated in the database.
     * @param {DispositiveUpdateManyAndReturnArgs} args - Arguments to update many Dispositives.
     * @example
     * // Update many Dispositives
     * const dispositive = await prisma.dispositive.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Dispositives and only return the `id`
     * const dispositiveWithIdOnly = await prisma.dispositive.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DispositiveUpdateManyAndReturnArgs>(args: SelectSubset<T, DispositiveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispositivePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Dispositive.
     * @param {DispositiveUpsertArgs} args - Arguments to update or create a Dispositive.
     * @example
     * // Update or create a Dispositive
     * const dispositive = await prisma.dispositive.upsert({
     *   create: {
     *     // ... data to create a Dispositive
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dispositive we want to update
     *   }
     * })
     */
    upsert<T extends DispositiveUpsertArgs>(args: SelectSubset<T, DispositiveUpsertArgs<ExtArgs>>): Prisma__DispositiveClient<$Result.GetResult<Prisma.$DispositivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dispositives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispositiveCountArgs} args - Arguments to filter Dispositives to count.
     * @example
     * // Count the number of Dispositives
     * const count = await prisma.dispositive.count({
     *   where: {
     *     // ... the filter for the Dispositives we want to count
     *   }
     * })
    **/
    count<T extends DispositiveCountArgs>(
      args?: Subset<T, DispositiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DispositiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dispositive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispositiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DispositiveAggregateArgs>(args: Subset<T, DispositiveAggregateArgs>): Prisma.PrismaPromise<GetDispositiveAggregateType<T>>

    /**
     * Group by Dispositive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispositiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DispositiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DispositiveGroupByArgs['orderBy'] }
        : { orderBy?: DispositiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DispositiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDispositiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dispositive model
   */
  readonly fields: DispositiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dispositive.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DispositiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DispotiveIssue<T extends Dispositive$DispotiveIssueArgs<ExtArgs> = {}>(args?: Subset<T, Dispositive$DispotiveIssueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispoIssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends Dispositive$UserArgs<ExtArgs> = {}>(args?: Subset<T, Dispositive$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Intervention<T extends Dispositive$InterventionArgs<ExtArgs> = {}>(args?: Subset<T, Dispositive$InterventionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProductTransaction<T extends Dispositive$ProductTransactionArgs<ExtArgs> = {}>(args?: Subset<T, Dispositive$ProductTransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dispositive model
   */
  interface DispositiveFieldRefs {
    readonly id: FieldRef<"Dispositive", 'Int'>
    readonly type: FieldRef<"Dispositive", 'String'>
    readonly start_date: FieldRef<"Dispositive", 'DateTime'>
    readonly end_date: FieldRef<"Dispositive", 'DateTime'>
    readonly initial_state: FieldRef<"Dispositive", 'String'>
    readonly MAC: FieldRef<"Dispositive", 'String'>
    readonly state: FieldRef<"Dispositive", 'String'>
    readonly user_id: FieldRef<"Dispositive", 'Int'>
    readonly product_id: FieldRef<"Dispositive", 'Int'>
    readonly created_at: FieldRef<"Dispositive", 'DateTime'>
    readonly updated_at: FieldRef<"Dispositive", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dispositive findUnique
   */
  export type DispositiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositive
     */
    select?: DispositiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispositive
     */
    omit?: DispositiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispositiveInclude<ExtArgs> | null
    /**
     * Filter, which Dispositive to fetch.
     */
    where: DispositiveWhereUniqueInput
  }

  /**
   * Dispositive findUniqueOrThrow
   */
  export type DispositiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositive
     */
    select?: DispositiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispositive
     */
    omit?: DispositiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispositiveInclude<ExtArgs> | null
    /**
     * Filter, which Dispositive to fetch.
     */
    where: DispositiveWhereUniqueInput
  }

  /**
   * Dispositive findFirst
   */
  export type DispositiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositive
     */
    select?: DispositiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispositive
     */
    omit?: DispositiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispositiveInclude<ExtArgs> | null
    /**
     * Filter, which Dispositive to fetch.
     */
    where?: DispositiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dispositives to fetch.
     */
    orderBy?: DispositiveOrderByWithRelationInput | DispositiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dispositives.
     */
    cursor?: DispositiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dispositives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dispositives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dispositives.
     */
    distinct?: DispositiveScalarFieldEnum | DispositiveScalarFieldEnum[]
  }

  /**
   * Dispositive findFirstOrThrow
   */
  export type DispositiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositive
     */
    select?: DispositiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispositive
     */
    omit?: DispositiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispositiveInclude<ExtArgs> | null
    /**
     * Filter, which Dispositive to fetch.
     */
    where?: DispositiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dispositives to fetch.
     */
    orderBy?: DispositiveOrderByWithRelationInput | DispositiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dispositives.
     */
    cursor?: DispositiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dispositives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dispositives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dispositives.
     */
    distinct?: DispositiveScalarFieldEnum | DispositiveScalarFieldEnum[]
  }

  /**
   * Dispositive findMany
   */
  export type DispositiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositive
     */
    select?: DispositiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispositive
     */
    omit?: DispositiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispositiveInclude<ExtArgs> | null
    /**
     * Filter, which Dispositives to fetch.
     */
    where?: DispositiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dispositives to fetch.
     */
    orderBy?: DispositiveOrderByWithRelationInput | DispositiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dispositives.
     */
    cursor?: DispositiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dispositives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dispositives.
     */
    skip?: number
    distinct?: DispositiveScalarFieldEnum | DispositiveScalarFieldEnum[]
  }

  /**
   * Dispositive create
   */
  export type DispositiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositive
     */
    select?: DispositiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispositive
     */
    omit?: DispositiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispositiveInclude<ExtArgs> | null
    /**
     * The data needed to create a Dispositive.
     */
    data: XOR<DispositiveCreateInput, DispositiveUncheckedCreateInput>
  }

  /**
   * Dispositive createMany
   */
  export type DispositiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dispositives.
     */
    data: DispositiveCreateManyInput | DispositiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dispositive createManyAndReturn
   */
  export type DispositiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositive
     */
    select?: DispositiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dispositive
     */
    omit?: DispositiveOmit<ExtArgs> | null
    /**
     * The data used to create many Dispositives.
     */
    data: DispositiveCreateManyInput | DispositiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispositiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dispositive update
   */
  export type DispositiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositive
     */
    select?: DispositiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispositive
     */
    omit?: DispositiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispositiveInclude<ExtArgs> | null
    /**
     * The data needed to update a Dispositive.
     */
    data: XOR<DispositiveUpdateInput, DispositiveUncheckedUpdateInput>
    /**
     * Choose, which Dispositive to update.
     */
    where: DispositiveWhereUniqueInput
  }

  /**
   * Dispositive updateMany
   */
  export type DispositiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dispositives.
     */
    data: XOR<DispositiveUpdateManyMutationInput, DispositiveUncheckedUpdateManyInput>
    /**
     * Filter which Dispositives to update
     */
    where?: DispositiveWhereInput
    /**
     * Limit how many Dispositives to update.
     */
    limit?: number
  }

  /**
   * Dispositive updateManyAndReturn
   */
  export type DispositiveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositive
     */
    select?: DispositiveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dispositive
     */
    omit?: DispositiveOmit<ExtArgs> | null
    /**
     * The data used to update Dispositives.
     */
    data: XOR<DispositiveUpdateManyMutationInput, DispositiveUncheckedUpdateManyInput>
    /**
     * Filter which Dispositives to update
     */
    where?: DispositiveWhereInput
    /**
     * Limit how many Dispositives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispositiveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dispositive upsert
   */
  export type DispositiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositive
     */
    select?: DispositiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispositive
     */
    omit?: DispositiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispositiveInclude<ExtArgs> | null
    /**
     * The filter to search for the Dispositive to update in case it exists.
     */
    where: DispositiveWhereUniqueInput
    /**
     * In case the Dispositive found by the `where` argument doesn't exist, create a new Dispositive with this data.
     */
    create: XOR<DispositiveCreateInput, DispositiveUncheckedCreateInput>
    /**
     * In case the Dispositive was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DispositiveUpdateInput, DispositiveUncheckedUpdateInput>
  }

  /**
   * Dispositive delete
   */
  export type DispositiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositive
     */
    select?: DispositiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispositive
     */
    omit?: DispositiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispositiveInclude<ExtArgs> | null
    /**
     * Filter which Dispositive to delete.
     */
    where: DispositiveWhereUniqueInput
  }

  /**
   * Dispositive deleteMany
   */
  export type DispositiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dispositives to delete
     */
    where?: DispositiveWhereInput
    /**
     * Limit how many Dispositives to delete.
     */
    limit?: number
  }

  /**
   * Dispositive.DispotiveIssue
   */
  export type Dispositive$DispotiveIssueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispoIssue
     */
    select?: DispoIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispoIssue
     */
    omit?: DispoIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispoIssueInclude<ExtArgs> | null
    where?: DispoIssueWhereInput
    orderBy?: DispoIssueOrderByWithRelationInput | DispoIssueOrderByWithRelationInput[]
    cursor?: DispoIssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DispoIssueScalarFieldEnum | DispoIssueScalarFieldEnum[]
  }

  /**
   * Dispositive.User
   */
  export type Dispositive$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Dispositive.Intervention
   */
  export type Dispositive$InterventionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    where?: InterventionWhereInput
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    cursor?: InterventionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Dispositive.ProductTransaction
   */
  export type Dispositive$ProductTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransaction
     */
    select?: ProductTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransaction
     */
    omit?: ProductTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransactionInclude<ExtArgs> | null
    where?: ProductTransactionWhereInput
    orderBy?: ProductTransactionOrderByWithRelationInput | ProductTransactionOrderByWithRelationInput[]
    cursor?: ProductTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTransactionScalarFieldEnum | ProductTransactionScalarFieldEnum[]
  }

  /**
   * Dispositive without action
   */
  export type DispositiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositive
     */
    select?: DispositiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispositive
     */
    omit?: DispositiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispositiveInclude<ExtArgs> | null
  }


  /**
   * Model Helper
   */

  export type AggregateHelper = {
    _count: HelperCountAggregateOutputType | null
    _avg: HelperAvgAggregateOutputType | null
    _sum: HelperSumAggregateOutputType | null
    _min: HelperMinAggregateOutputType | null
    _max: HelperMaxAggregateOutputType | null
  }

  export type HelperAvgAggregateOutputType = {
    id: number | null
  }

  export type HelperSumAggregateOutputType = {
    id: number | null
  }

  export type HelperMinAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
    phone: string | null
  }

  export type HelperMaxAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
    phone: string | null
  }

  export type HelperCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    email: number
    password: number
    phone: number
    _all: number
  }


  export type HelperAvgAggregateInputType = {
    id?: true
  }

  export type HelperSumAggregateInputType = {
    id?: true
  }

  export type HelperMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
  }

  export type HelperMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
  }

  export type HelperCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
    _all?: true
  }

  export type HelperAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Helper to aggregate.
     */
    where?: HelperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Helpers to fetch.
     */
    orderBy?: HelperOrderByWithRelationInput | HelperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HelperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Helpers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Helpers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Helpers
    **/
    _count?: true | HelperCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HelperAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HelperSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelperMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelperMaxAggregateInputType
  }

  export type GetHelperAggregateType<T extends HelperAggregateArgs> = {
        [P in keyof T & keyof AggregateHelper]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelper[P]>
      : GetScalarType<T[P], AggregateHelper[P]>
  }




  export type HelperGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelperWhereInput
    orderBy?: HelperOrderByWithAggregationInput | HelperOrderByWithAggregationInput[]
    by: HelperScalarFieldEnum[] | HelperScalarFieldEnum
    having?: HelperScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelperCountAggregateInputType | true
    _avg?: HelperAvgAggregateInputType
    _sum?: HelperSumAggregateInputType
    _min?: HelperMinAggregateInputType
    _max?: HelperMaxAggregateInputType
  }

  export type HelperGroupByOutputType = {
    id: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone: string | null
    _count: HelperCountAggregateOutputType | null
    _avg: HelperAvgAggregateOutputType | null
    _sum: HelperSumAggregateOutputType | null
    _min: HelperMinAggregateOutputType | null
    _max: HelperMaxAggregateOutputType | null
  }

  type GetHelperGroupByPayload<T extends HelperGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelperGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelperGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelperGroupByOutputType[P]>
            : GetScalarType<T[P], HelperGroupByOutputType[P]>
        }
      >
    >


  export type HelperSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    User?: boolean | Helper$UserArgs<ExtArgs>
    _count?: boolean | HelperCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helper"]>

  export type HelperSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
  }, ExtArgs["result"]["helper"]>

  export type HelperSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
  }, ExtArgs["result"]["helper"]>

  export type HelperSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
  }

  export type HelperOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "first_name" | "last_name" | "email" | "password" | "phone", ExtArgs["result"]["helper"]>
  export type HelperInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Helper$UserArgs<ExtArgs>
    _count?: boolean | HelperCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HelperIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type HelperIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HelperPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Helper"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      first_name: string
      last_name: string
      email: string
      password: string
      phone: string | null
    }, ExtArgs["result"]["helper"]>
    composites: {}
  }

  type HelperGetPayload<S extends boolean | null | undefined | HelperDefaultArgs> = $Result.GetResult<Prisma.$HelperPayload, S>

  type HelperCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HelperFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HelperCountAggregateInputType | true
    }

  export interface HelperDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Helper'], meta: { name: 'Helper' } }
    /**
     * Find zero or one Helper that matches the filter.
     * @param {HelperFindUniqueArgs} args - Arguments to find a Helper
     * @example
     * // Get one Helper
     * const helper = await prisma.helper.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HelperFindUniqueArgs>(args: SelectSubset<T, HelperFindUniqueArgs<ExtArgs>>): Prisma__HelperClient<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Helper that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HelperFindUniqueOrThrowArgs} args - Arguments to find a Helper
     * @example
     * // Get one Helper
     * const helper = await prisma.helper.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HelperFindUniqueOrThrowArgs>(args: SelectSubset<T, HelperFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HelperClient<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Helper that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperFindFirstArgs} args - Arguments to find a Helper
     * @example
     * // Get one Helper
     * const helper = await prisma.helper.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HelperFindFirstArgs>(args?: SelectSubset<T, HelperFindFirstArgs<ExtArgs>>): Prisma__HelperClient<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Helper that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperFindFirstOrThrowArgs} args - Arguments to find a Helper
     * @example
     * // Get one Helper
     * const helper = await prisma.helper.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HelperFindFirstOrThrowArgs>(args?: SelectSubset<T, HelperFindFirstOrThrowArgs<ExtArgs>>): Prisma__HelperClient<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Helpers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Helpers
     * const helpers = await prisma.helper.findMany()
     * 
     * // Get first 10 Helpers
     * const helpers = await prisma.helper.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helperWithIdOnly = await prisma.helper.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HelperFindManyArgs>(args?: SelectSubset<T, HelperFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Helper.
     * @param {HelperCreateArgs} args - Arguments to create a Helper.
     * @example
     * // Create one Helper
     * const Helper = await prisma.helper.create({
     *   data: {
     *     // ... data to create a Helper
     *   }
     * })
     * 
     */
    create<T extends HelperCreateArgs>(args: SelectSubset<T, HelperCreateArgs<ExtArgs>>): Prisma__HelperClient<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Helpers.
     * @param {HelperCreateManyArgs} args - Arguments to create many Helpers.
     * @example
     * // Create many Helpers
     * const helper = await prisma.helper.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HelperCreateManyArgs>(args?: SelectSubset<T, HelperCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Helpers and returns the data saved in the database.
     * @param {HelperCreateManyAndReturnArgs} args - Arguments to create many Helpers.
     * @example
     * // Create many Helpers
     * const helper = await prisma.helper.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Helpers and only return the `id`
     * const helperWithIdOnly = await prisma.helper.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HelperCreateManyAndReturnArgs>(args?: SelectSubset<T, HelperCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Helper.
     * @param {HelperDeleteArgs} args - Arguments to delete one Helper.
     * @example
     * // Delete one Helper
     * const Helper = await prisma.helper.delete({
     *   where: {
     *     // ... filter to delete one Helper
     *   }
     * })
     * 
     */
    delete<T extends HelperDeleteArgs>(args: SelectSubset<T, HelperDeleteArgs<ExtArgs>>): Prisma__HelperClient<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Helper.
     * @param {HelperUpdateArgs} args - Arguments to update one Helper.
     * @example
     * // Update one Helper
     * const helper = await prisma.helper.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HelperUpdateArgs>(args: SelectSubset<T, HelperUpdateArgs<ExtArgs>>): Prisma__HelperClient<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Helpers.
     * @param {HelperDeleteManyArgs} args - Arguments to filter Helpers to delete.
     * @example
     * // Delete a few Helpers
     * const { count } = await prisma.helper.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HelperDeleteManyArgs>(args?: SelectSubset<T, HelperDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Helpers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Helpers
     * const helper = await prisma.helper.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HelperUpdateManyArgs>(args: SelectSubset<T, HelperUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Helpers and returns the data updated in the database.
     * @param {HelperUpdateManyAndReturnArgs} args - Arguments to update many Helpers.
     * @example
     * // Update many Helpers
     * const helper = await prisma.helper.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Helpers and only return the `id`
     * const helperWithIdOnly = await prisma.helper.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HelperUpdateManyAndReturnArgs>(args: SelectSubset<T, HelperUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Helper.
     * @param {HelperUpsertArgs} args - Arguments to update or create a Helper.
     * @example
     * // Update or create a Helper
     * const helper = await prisma.helper.upsert({
     *   create: {
     *     // ... data to create a Helper
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Helper we want to update
     *   }
     * })
     */
    upsert<T extends HelperUpsertArgs>(args: SelectSubset<T, HelperUpsertArgs<ExtArgs>>): Prisma__HelperClient<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Helpers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperCountArgs} args - Arguments to filter Helpers to count.
     * @example
     * // Count the number of Helpers
     * const count = await prisma.helper.count({
     *   where: {
     *     // ... the filter for the Helpers we want to count
     *   }
     * })
    **/
    count<T extends HelperCountArgs>(
      args?: Subset<T, HelperCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelperCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Helper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelperAggregateArgs>(args: Subset<T, HelperAggregateArgs>): Prisma.PrismaPromise<GetHelperAggregateType<T>>

    /**
     * Group by Helper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HelperGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HelperGroupByArgs['orderBy'] }
        : { orderBy?: HelperGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HelperGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelperGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Helper model
   */
  readonly fields: HelperFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Helper.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HelperClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends Helper$UserArgs<ExtArgs> = {}>(args?: Subset<T, Helper$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Helper model
   */
  interface HelperFieldRefs {
    readonly id: FieldRef<"Helper", 'Int'>
    readonly first_name: FieldRef<"Helper", 'String'>
    readonly last_name: FieldRef<"Helper", 'String'>
    readonly email: FieldRef<"Helper", 'String'>
    readonly password: FieldRef<"Helper", 'String'>
    readonly phone: FieldRef<"Helper", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Helper findUnique
   */
  export type HelperFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    /**
     * Filter, which Helper to fetch.
     */
    where: HelperWhereUniqueInput
  }

  /**
   * Helper findUniqueOrThrow
   */
  export type HelperFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    /**
     * Filter, which Helper to fetch.
     */
    where: HelperWhereUniqueInput
  }

  /**
   * Helper findFirst
   */
  export type HelperFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    /**
     * Filter, which Helper to fetch.
     */
    where?: HelperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Helpers to fetch.
     */
    orderBy?: HelperOrderByWithRelationInput | HelperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Helpers.
     */
    cursor?: HelperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Helpers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Helpers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Helpers.
     */
    distinct?: HelperScalarFieldEnum | HelperScalarFieldEnum[]
  }

  /**
   * Helper findFirstOrThrow
   */
  export type HelperFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    /**
     * Filter, which Helper to fetch.
     */
    where?: HelperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Helpers to fetch.
     */
    orderBy?: HelperOrderByWithRelationInput | HelperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Helpers.
     */
    cursor?: HelperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Helpers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Helpers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Helpers.
     */
    distinct?: HelperScalarFieldEnum | HelperScalarFieldEnum[]
  }

  /**
   * Helper findMany
   */
  export type HelperFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    /**
     * Filter, which Helpers to fetch.
     */
    where?: HelperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Helpers to fetch.
     */
    orderBy?: HelperOrderByWithRelationInput | HelperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Helpers.
     */
    cursor?: HelperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Helpers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Helpers.
     */
    skip?: number
    distinct?: HelperScalarFieldEnum | HelperScalarFieldEnum[]
  }

  /**
   * Helper create
   */
  export type HelperCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    /**
     * The data needed to create a Helper.
     */
    data: XOR<HelperCreateInput, HelperUncheckedCreateInput>
  }

  /**
   * Helper createMany
   */
  export type HelperCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Helpers.
     */
    data: HelperCreateManyInput | HelperCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Helper createManyAndReturn
   */
  export type HelperCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * The data used to create many Helpers.
     */
    data: HelperCreateManyInput | HelperCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Helper update
   */
  export type HelperUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    /**
     * The data needed to update a Helper.
     */
    data: XOR<HelperUpdateInput, HelperUncheckedUpdateInput>
    /**
     * Choose, which Helper to update.
     */
    where: HelperWhereUniqueInput
  }

  /**
   * Helper updateMany
   */
  export type HelperUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Helpers.
     */
    data: XOR<HelperUpdateManyMutationInput, HelperUncheckedUpdateManyInput>
    /**
     * Filter which Helpers to update
     */
    where?: HelperWhereInput
    /**
     * Limit how many Helpers to update.
     */
    limit?: number
  }

  /**
   * Helper updateManyAndReturn
   */
  export type HelperUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * The data used to update Helpers.
     */
    data: XOR<HelperUpdateManyMutationInput, HelperUncheckedUpdateManyInput>
    /**
     * Filter which Helpers to update
     */
    where?: HelperWhereInput
    /**
     * Limit how many Helpers to update.
     */
    limit?: number
  }

  /**
   * Helper upsert
   */
  export type HelperUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    /**
     * The filter to search for the Helper to update in case it exists.
     */
    where: HelperWhereUniqueInput
    /**
     * In case the Helper found by the `where` argument doesn't exist, create a new Helper with this data.
     */
    create: XOR<HelperCreateInput, HelperUncheckedCreateInput>
    /**
     * In case the Helper was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HelperUpdateInput, HelperUncheckedUpdateInput>
  }

  /**
   * Helper delete
   */
  export type HelperDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    /**
     * Filter which Helper to delete.
     */
    where: HelperWhereUniqueInput
  }

  /**
   * Helper deleteMany
   */
  export type HelperDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Helpers to delete
     */
    where?: HelperWhereInput
    /**
     * Limit how many Helpers to delete.
     */
    limit?: number
  }

  /**
   * Helper.User
   */
  export type Helper$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Helper without action
   */
  export type HelperDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
  }


  /**
   * Model Intervention
   */

  export type AggregateIntervention = {
    _count: InterventionCountAggregateOutputType | null
    _avg: InterventionAvgAggregateOutputType | null
    _sum: InterventionSumAggregateOutputType | null
    _min: InterventionMinAggregateOutputType | null
    _max: InterventionMaxAggregateOutputType | null
  }

  export type InterventionAvgAggregateOutputType = {
    idMaintainer: number | null
    id: number | null
    idDispositive: number | null
  }

  export type InterventionSumAggregateOutputType = {
    idMaintainer: number | null
    id: number | null
    idDispositive: number | null
  }

  export type InterventionMinAggregateOutputType = {
    idMaintainer: number | null
    description: string | null
    type: string | null
    end_date: Date | null
    start_date: Date | null
    id: number | null
    status: $Enums.InterventionStatus | null
    idDispositive: number | null
  }

  export type InterventionMaxAggregateOutputType = {
    idMaintainer: number | null
    description: string | null
    type: string | null
    end_date: Date | null
    start_date: Date | null
    id: number | null
    status: $Enums.InterventionStatus | null
    idDispositive: number | null
  }

  export type InterventionCountAggregateOutputType = {
    idMaintainer: number
    description: number
    type: number
    end_date: number
    start_date: number
    id: number
    status: number
    idDispositive: number
    _all: number
  }


  export type InterventionAvgAggregateInputType = {
    idMaintainer?: true
    id?: true
    idDispositive?: true
  }

  export type InterventionSumAggregateInputType = {
    idMaintainer?: true
    id?: true
    idDispositive?: true
  }

  export type InterventionMinAggregateInputType = {
    idMaintainer?: true
    description?: true
    type?: true
    end_date?: true
    start_date?: true
    id?: true
    status?: true
    idDispositive?: true
  }

  export type InterventionMaxAggregateInputType = {
    idMaintainer?: true
    description?: true
    type?: true
    end_date?: true
    start_date?: true
    id?: true
    status?: true
    idDispositive?: true
  }

  export type InterventionCountAggregateInputType = {
    idMaintainer?: true
    description?: true
    type?: true
    end_date?: true
    start_date?: true
    id?: true
    status?: true
    idDispositive?: true
    _all?: true
  }

  export type InterventionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Intervention to aggregate.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interventions
    **/
    _count?: true | InterventionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterventionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterventionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterventionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterventionMaxAggregateInputType
  }

  export type GetInterventionAggregateType<T extends InterventionAggregateArgs> = {
        [P in keyof T & keyof AggregateIntervention]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntervention[P]>
      : GetScalarType<T[P], AggregateIntervention[P]>
  }




  export type InterventionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionWhereInput
    orderBy?: InterventionOrderByWithAggregationInput | InterventionOrderByWithAggregationInput[]
    by: InterventionScalarFieldEnum[] | InterventionScalarFieldEnum
    having?: InterventionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterventionCountAggregateInputType | true
    _avg?: InterventionAvgAggregateInputType
    _sum?: InterventionSumAggregateInputType
    _min?: InterventionMinAggregateInputType
    _max?: InterventionMaxAggregateInputType
  }

  export type InterventionGroupByOutputType = {
    idMaintainer: number
    description: string
    type: string
    end_date: Date
    start_date: Date
    id: number
    status: $Enums.InterventionStatus
    idDispositive: number
    _count: InterventionCountAggregateOutputType | null
    _avg: InterventionAvgAggregateOutputType | null
    _sum: InterventionSumAggregateOutputType | null
    _min: InterventionMinAggregateOutputType | null
    _max: InterventionMaxAggregateOutputType | null
  }

  type GetInterventionGroupByPayload<T extends InterventionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterventionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterventionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterventionGroupByOutputType[P]>
            : GetScalarType<T[P], InterventionGroupByOutputType[P]>
        }
      >
    >


  export type InterventionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idMaintainer?: boolean
    description?: boolean
    type?: boolean
    end_date?: boolean
    start_date?: boolean
    id?: boolean
    status?: boolean
    idDispositive?: boolean
    Dispositive?: boolean | DispositiveDefaultArgs<ExtArgs>
    Maintainer?: boolean | MaintainerDefaultArgs<ExtArgs>
    InterventionReport?: boolean | Intervention$InterventionReportArgs<ExtArgs>
  }, ExtArgs["result"]["intervention"]>

  export type InterventionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idMaintainer?: boolean
    description?: boolean
    type?: boolean
    end_date?: boolean
    start_date?: boolean
    id?: boolean
    status?: boolean
    idDispositive?: boolean
    Dispositive?: boolean | DispositiveDefaultArgs<ExtArgs>
    Maintainer?: boolean | MaintainerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intervention"]>

  export type InterventionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idMaintainer?: boolean
    description?: boolean
    type?: boolean
    end_date?: boolean
    start_date?: boolean
    id?: boolean
    status?: boolean
    idDispositive?: boolean
    Dispositive?: boolean | DispositiveDefaultArgs<ExtArgs>
    Maintainer?: boolean | MaintainerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intervention"]>

  export type InterventionSelectScalar = {
    idMaintainer?: boolean
    description?: boolean
    type?: boolean
    end_date?: boolean
    start_date?: boolean
    id?: boolean
    status?: boolean
    idDispositive?: boolean
  }

  export type InterventionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idMaintainer" | "description" | "type" | "end_date" | "start_date" | "id" | "status" | "idDispositive", ExtArgs["result"]["intervention"]>
  export type InterventionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Dispositive?: boolean | DispositiveDefaultArgs<ExtArgs>
    Maintainer?: boolean | MaintainerDefaultArgs<ExtArgs>
    InterventionReport?: boolean | Intervention$InterventionReportArgs<ExtArgs>
  }
  export type InterventionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Dispositive?: boolean | DispositiveDefaultArgs<ExtArgs>
    Maintainer?: boolean | MaintainerDefaultArgs<ExtArgs>
  }
  export type InterventionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Dispositive?: boolean | DispositiveDefaultArgs<ExtArgs>
    Maintainer?: boolean | MaintainerDefaultArgs<ExtArgs>
  }

  export type $InterventionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Intervention"
    objects: {
      Dispositive: Prisma.$DispositivePayload<ExtArgs>
      Maintainer: Prisma.$MaintainerPayload<ExtArgs>
      InterventionReport: Prisma.$InterventionReportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idMaintainer: number
      description: string
      type: string
      end_date: Date
      start_date: Date
      id: number
      status: $Enums.InterventionStatus
      idDispositive: number
    }, ExtArgs["result"]["intervention"]>
    composites: {}
  }

  type InterventionGetPayload<S extends boolean | null | undefined | InterventionDefaultArgs> = $Result.GetResult<Prisma.$InterventionPayload, S>

  type InterventionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterventionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterventionCountAggregateInputType | true
    }

  export interface InterventionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Intervention'], meta: { name: 'Intervention' } }
    /**
     * Find zero or one Intervention that matches the filter.
     * @param {InterventionFindUniqueArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterventionFindUniqueArgs>(args: SelectSubset<T, InterventionFindUniqueArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Intervention that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterventionFindUniqueOrThrowArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterventionFindUniqueOrThrowArgs>(args: SelectSubset<T, InterventionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Intervention that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionFindFirstArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterventionFindFirstArgs>(args?: SelectSubset<T, InterventionFindFirstArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Intervention that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionFindFirstOrThrowArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterventionFindFirstOrThrowArgs>(args?: SelectSubset<T, InterventionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Interventions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interventions
     * const interventions = await prisma.intervention.findMany()
     * 
     * // Get first 10 Interventions
     * const interventions = await prisma.intervention.findMany({ take: 10 })
     * 
     * // Only select the `idMaintainer`
     * const interventionWithIdMaintainerOnly = await prisma.intervention.findMany({ select: { idMaintainer: true } })
     * 
     */
    findMany<T extends InterventionFindManyArgs>(args?: SelectSubset<T, InterventionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Intervention.
     * @param {InterventionCreateArgs} args - Arguments to create a Intervention.
     * @example
     * // Create one Intervention
     * const Intervention = await prisma.intervention.create({
     *   data: {
     *     // ... data to create a Intervention
     *   }
     * })
     * 
     */
    create<T extends InterventionCreateArgs>(args: SelectSubset<T, InterventionCreateArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Interventions.
     * @param {InterventionCreateManyArgs} args - Arguments to create many Interventions.
     * @example
     * // Create many Interventions
     * const intervention = await prisma.intervention.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterventionCreateManyArgs>(args?: SelectSubset<T, InterventionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interventions and returns the data saved in the database.
     * @param {InterventionCreateManyAndReturnArgs} args - Arguments to create many Interventions.
     * @example
     * // Create many Interventions
     * const intervention = await prisma.intervention.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interventions and only return the `idMaintainer`
     * const interventionWithIdMaintainerOnly = await prisma.intervention.createManyAndReturn({
     *   select: { idMaintainer: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterventionCreateManyAndReturnArgs>(args?: SelectSubset<T, InterventionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Intervention.
     * @param {InterventionDeleteArgs} args - Arguments to delete one Intervention.
     * @example
     * // Delete one Intervention
     * const Intervention = await prisma.intervention.delete({
     *   where: {
     *     // ... filter to delete one Intervention
     *   }
     * })
     * 
     */
    delete<T extends InterventionDeleteArgs>(args: SelectSubset<T, InterventionDeleteArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Intervention.
     * @param {InterventionUpdateArgs} args - Arguments to update one Intervention.
     * @example
     * // Update one Intervention
     * const intervention = await prisma.intervention.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterventionUpdateArgs>(args: SelectSubset<T, InterventionUpdateArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Interventions.
     * @param {InterventionDeleteManyArgs} args - Arguments to filter Interventions to delete.
     * @example
     * // Delete a few Interventions
     * const { count } = await prisma.intervention.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterventionDeleteManyArgs>(args?: SelectSubset<T, InterventionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interventions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interventions
     * const intervention = await prisma.intervention.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterventionUpdateManyArgs>(args: SelectSubset<T, InterventionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interventions and returns the data updated in the database.
     * @param {InterventionUpdateManyAndReturnArgs} args - Arguments to update many Interventions.
     * @example
     * // Update many Interventions
     * const intervention = await prisma.intervention.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Interventions and only return the `idMaintainer`
     * const interventionWithIdMaintainerOnly = await prisma.intervention.updateManyAndReturn({
     *   select: { idMaintainer: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterventionUpdateManyAndReturnArgs>(args: SelectSubset<T, InterventionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Intervention.
     * @param {InterventionUpsertArgs} args - Arguments to update or create a Intervention.
     * @example
     * // Update or create a Intervention
     * const intervention = await prisma.intervention.upsert({
     *   create: {
     *     // ... data to create a Intervention
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Intervention we want to update
     *   }
     * })
     */
    upsert<T extends InterventionUpsertArgs>(args: SelectSubset<T, InterventionUpsertArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Interventions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionCountArgs} args - Arguments to filter Interventions to count.
     * @example
     * // Count the number of Interventions
     * const count = await prisma.intervention.count({
     *   where: {
     *     // ... the filter for the Interventions we want to count
     *   }
     * })
    **/
    count<T extends InterventionCountArgs>(
      args?: Subset<T, InterventionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterventionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Intervention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterventionAggregateArgs>(args: Subset<T, InterventionAggregateArgs>): Prisma.PrismaPromise<GetInterventionAggregateType<T>>

    /**
     * Group by Intervention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterventionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterventionGroupByArgs['orderBy'] }
        : { orderBy?: InterventionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterventionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterventionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Intervention model
   */
  readonly fields: InterventionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Intervention.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterventionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Dispositive<T extends DispositiveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DispositiveDefaultArgs<ExtArgs>>): Prisma__DispositiveClient<$Result.GetResult<Prisma.$DispositivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Maintainer<T extends MaintainerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaintainerDefaultArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    InterventionReport<T extends Intervention$InterventionReportArgs<ExtArgs> = {}>(args?: Subset<T, Intervention$InterventionReportArgs<ExtArgs>>): Prisma__InterventionReportClient<$Result.GetResult<Prisma.$InterventionReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Intervention model
   */
  interface InterventionFieldRefs {
    readonly idMaintainer: FieldRef<"Intervention", 'Int'>
    readonly description: FieldRef<"Intervention", 'String'>
    readonly type: FieldRef<"Intervention", 'String'>
    readonly end_date: FieldRef<"Intervention", 'DateTime'>
    readonly start_date: FieldRef<"Intervention", 'DateTime'>
    readonly id: FieldRef<"Intervention", 'Int'>
    readonly status: FieldRef<"Intervention", 'InterventionStatus'>
    readonly idDispositive: FieldRef<"Intervention", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Intervention findUnique
   */
  export type InterventionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention findUniqueOrThrow
   */
  export type InterventionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention findFirst
   */
  export type InterventionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interventions.
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interventions.
     */
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Intervention findFirstOrThrow
   */
  export type InterventionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interventions.
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interventions.
     */
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Intervention findMany
   */
  export type InterventionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Interventions to fetch.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interventions.
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Intervention create
   */
  export type InterventionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * The data needed to create a Intervention.
     */
    data: XOR<InterventionCreateInput, InterventionUncheckedCreateInput>
  }

  /**
   * Intervention createMany
   */
  export type InterventionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interventions.
     */
    data: InterventionCreateManyInput | InterventionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Intervention createManyAndReturn
   */
  export type InterventionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * The data used to create many Interventions.
     */
    data: InterventionCreateManyInput | InterventionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Intervention update
   */
  export type InterventionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * The data needed to update a Intervention.
     */
    data: XOR<InterventionUpdateInput, InterventionUncheckedUpdateInput>
    /**
     * Choose, which Intervention to update.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention updateMany
   */
  export type InterventionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interventions.
     */
    data: XOR<InterventionUpdateManyMutationInput, InterventionUncheckedUpdateManyInput>
    /**
     * Filter which Interventions to update
     */
    where?: InterventionWhereInput
    /**
     * Limit how many Interventions to update.
     */
    limit?: number
  }

  /**
   * Intervention updateManyAndReturn
   */
  export type InterventionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * The data used to update Interventions.
     */
    data: XOR<InterventionUpdateManyMutationInput, InterventionUncheckedUpdateManyInput>
    /**
     * Filter which Interventions to update
     */
    where?: InterventionWhereInput
    /**
     * Limit how many Interventions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Intervention upsert
   */
  export type InterventionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * The filter to search for the Intervention to update in case it exists.
     */
    where: InterventionWhereUniqueInput
    /**
     * In case the Intervention found by the `where` argument doesn't exist, create a new Intervention with this data.
     */
    create: XOR<InterventionCreateInput, InterventionUncheckedCreateInput>
    /**
     * In case the Intervention was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterventionUpdateInput, InterventionUncheckedUpdateInput>
  }

  /**
   * Intervention delete
   */
  export type InterventionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter which Intervention to delete.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention deleteMany
   */
  export type InterventionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interventions to delete
     */
    where?: InterventionWhereInput
    /**
     * Limit how many Interventions to delete.
     */
    limit?: number
  }

  /**
   * Intervention.InterventionReport
   */
  export type Intervention$InterventionReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionReport
     */
    select?: InterventionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionReport
     */
    omit?: InterventionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionReportInclude<ExtArgs> | null
    where?: InterventionReportWhereInput
  }

  /**
   * Intervention without action
   */
  export type InterventionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
  }


  /**
   * Model Maintainer
   */

  export type AggregateMaintainer = {
    _count: MaintainerCountAggregateOutputType | null
    _avg: MaintainerAvgAggregateOutputType | null
    _sum: MaintainerSumAggregateOutputType | null
    _min: MaintainerMinAggregateOutputType | null
    _max: MaintainerMaxAggregateOutputType | null
  }

  export type MaintainerAvgAggregateOutputType = {
    id: number | null
  }

  export type MaintainerSumAggregateOutputType = {
    id: number | null
  }

  export type MaintainerMinAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
    phone: string | null
  }

  export type MaintainerMaxAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
    phone: string | null
  }

  export type MaintainerCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    email: number
    password: number
    phone: number
    _all: number
  }


  export type MaintainerAvgAggregateInputType = {
    id?: true
  }

  export type MaintainerSumAggregateInputType = {
    id?: true
  }

  export type MaintainerMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
  }

  export type MaintainerMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
  }

  export type MaintainerCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
    _all?: true
  }

  export type MaintainerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maintainer to aggregate.
     */
    where?: MaintainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintainers to fetch.
     */
    orderBy?: MaintainerOrderByWithRelationInput | MaintainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintainers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintainers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Maintainers
    **/
    _count?: true | MaintainerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaintainerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaintainerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintainerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintainerMaxAggregateInputType
  }

  export type GetMaintainerAggregateType<T extends MaintainerAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintainer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintainer[P]>
      : GetScalarType<T[P], AggregateMaintainer[P]>
  }




  export type MaintainerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintainerWhereInput
    orderBy?: MaintainerOrderByWithAggregationInput | MaintainerOrderByWithAggregationInput[]
    by: MaintainerScalarFieldEnum[] | MaintainerScalarFieldEnum
    having?: MaintainerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintainerCountAggregateInputType | true
    _avg?: MaintainerAvgAggregateInputType
    _sum?: MaintainerSumAggregateInputType
    _min?: MaintainerMinAggregateInputType
    _max?: MaintainerMaxAggregateInputType
  }

  export type MaintainerGroupByOutputType = {
    id: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone: string | null
    _count: MaintainerCountAggregateOutputType | null
    _avg: MaintainerAvgAggregateOutputType | null
    _sum: MaintainerSumAggregateOutputType | null
    _min: MaintainerMinAggregateOutputType | null
    _max: MaintainerMaxAggregateOutputType | null
  }

  type GetMaintainerGroupByPayload<T extends MaintainerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintainerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintainerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintainerGroupByOutputType[P]>
            : GetScalarType<T[P], MaintainerGroupByOutputType[P]>
        }
      >
    >


  export type MaintainerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    DispoIssue?: boolean | Maintainer$DispoIssueArgs<ExtArgs>
    Intervention?: boolean | Maintainer$InterventionArgs<ExtArgs>
    _count?: boolean | MaintainerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintainer"]>

  export type MaintainerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
  }, ExtArgs["result"]["maintainer"]>

  export type MaintainerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
  }, ExtArgs["result"]["maintainer"]>

  export type MaintainerSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
  }

  export type MaintainerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "first_name" | "last_name" | "email" | "password" | "phone", ExtArgs["result"]["maintainer"]>
  export type MaintainerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DispoIssue?: boolean | Maintainer$DispoIssueArgs<ExtArgs>
    Intervention?: boolean | Maintainer$InterventionArgs<ExtArgs>
    _count?: boolean | MaintainerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaintainerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MaintainerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MaintainerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Maintainer"
    objects: {
      DispoIssue: Prisma.$DispoIssuePayload<ExtArgs>[]
      Intervention: Prisma.$InterventionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      first_name: string
      last_name: string
      email: string
      password: string
      phone: string | null
    }, ExtArgs["result"]["maintainer"]>
    composites: {}
  }

  type MaintainerGetPayload<S extends boolean | null | undefined | MaintainerDefaultArgs> = $Result.GetResult<Prisma.$MaintainerPayload, S>

  type MaintainerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintainerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintainerCountAggregateInputType | true
    }

  export interface MaintainerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Maintainer'], meta: { name: 'Maintainer' } }
    /**
     * Find zero or one Maintainer that matches the filter.
     * @param {MaintainerFindUniqueArgs} args - Arguments to find a Maintainer
     * @example
     * // Get one Maintainer
     * const maintainer = await prisma.maintainer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintainerFindUniqueArgs>(args: SelectSubset<T, MaintainerFindUniqueArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Maintainer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintainerFindUniqueOrThrowArgs} args - Arguments to find a Maintainer
     * @example
     * // Get one Maintainer
     * const maintainer = await prisma.maintainer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintainerFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintainerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maintainer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintainerFindFirstArgs} args - Arguments to find a Maintainer
     * @example
     * // Get one Maintainer
     * const maintainer = await prisma.maintainer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintainerFindFirstArgs>(args?: SelectSubset<T, MaintainerFindFirstArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maintainer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintainerFindFirstOrThrowArgs} args - Arguments to find a Maintainer
     * @example
     * // Get one Maintainer
     * const maintainer = await prisma.maintainer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintainerFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintainerFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Maintainers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintainerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maintainers
     * const maintainers = await prisma.maintainer.findMany()
     * 
     * // Get first 10 Maintainers
     * const maintainers = await prisma.maintainer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintainerWithIdOnly = await prisma.maintainer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintainerFindManyArgs>(args?: SelectSubset<T, MaintainerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Maintainer.
     * @param {MaintainerCreateArgs} args - Arguments to create a Maintainer.
     * @example
     * // Create one Maintainer
     * const Maintainer = await prisma.maintainer.create({
     *   data: {
     *     // ... data to create a Maintainer
     *   }
     * })
     * 
     */
    create<T extends MaintainerCreateArgs>(args: SelectSubset<T, MaintainerCreateArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Maintainers.
     * @param {MaintainerCreateManyArgs} args - Arguments to create many Maintainers.
     * @example
     * // Create many Maintainers
     * const maintainer = await prisma.maintainer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintainerCreateManyArgs>(args?: SelectSubset<T, MaintainerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Maintainers and returns the data saved in the database.
     * @param {MaintainerCreateManyAndReturnArgs} args - Arguments to create many Maintainers.
     * @example
     * // Create many Maintainers
     * const maintainer = await prisma.maintainer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Maintainers and only return the `id`
     * const maintainerWithIdOnly = await prisma.maintainer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintainerCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintainerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Maintainer.
     * @param {MaintainerDeleteArgs} args - Arguments to delete one Maintainer.
     * @example
     * // Delete one Maintainer
     * const Maintainer = await prisma.maintainer.delete({
     *   where: {
     *     // ... filter to delete one Maintainer
     *   }
     * })
     * 
     */
    delete<T extends MaintainerDeleteArgs>(args: SelectSubset<T, MaintainerDeleteArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Maintainer.
     * @param {MaintainerUpdateArgs} args - Arguments to update one Maintainer.
     * @example
     * // Update one Maintainer
     * const maintainer = await prisma.maintainer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintainerUpdateArgs>(args: SelectSubset<T, MaintainerUpdateArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Maintainers.
     * @param {MaintainerDeleteManyArgs} args - Arguments to filter Maintainers to delete.
     * @example
     * // Delete a few Maintainers
     * const { count } = await prisma.maintainer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintainerDeleteManyArgs>(args?: SelectSubset<T, MaintainerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maintainers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintainerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maintainers
     * const maintainer = await prisma.maintainer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintainerUpdateManyArgs>(args: SelectSubset<T, MaintainerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maintainers and returns the data updated in the database.
     * @param {MaintainerUpdateManyAndReturnArgs} args - Arguments to update many Maintainers.
     * @example
     * // Update many Maintainers
     * const maintainer = await prisma.maintainer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Maintainers and only return the `id`
     * const maintainerWithIdOnly = await prisma.maintainer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaintainerUpdateManyAndReturnArgs>(args: SelectSubset<T, MaintainerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Maintainer.
     * @param {MaintainerUpsertArgs} args - Arguments to update or create a Maintainer.
     * @example
     * // Update or create a Maintainer
     * const maintainer = await prisma.maintainer.upsert({
     *   create: {
     *     // ... data to create a Maintainer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Maintainer we want to update
     *   }
     * })
     */
    upsert<T extends MaintainerUpsertArgs>(args: SelectSubset<T, MaintainerUpsertArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Maintainers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintainerCountArgs} args - Arguments to filter Maintainers to count.
     * @example
     * // Count the number of Maintainers
     * const count = await prisma.maintainer.count({
     *   where: {
     *     // ... the filter for the Maintainers we want to count
     *   }
     * })
    **/
    count<T extends MaintainerCountArgs>(
      args?: Subset<T, MaintainerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintainerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Maintainer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintainerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintainerAggregateArgs>(args: Subset<T, MaintainerAggregateArgs>): Prisma.PrismaPromise<GetMaintainerAggregateType<T>>

    /**
     * Group by Maintainer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintainerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintainerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintainerGroupByArgs['orderBy'] }
        : { orderBy?: MaintainerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintainerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintainerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Maintainer model
   */
  readonly fields: MaintainerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Maintainer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintainerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DispoIssue<T extends Maintainer$DispoIssueArgs<ExtArgs> = {}>(args?: Subset<T, Maintainer$DispoIssueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispoIssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Intervention<T extends Maintainer$InterventionArgs<ExtArgs> = {}>(args?: Subset<T, Maintainer$InterventionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Maintainer model
   */
  interface MaintainerFieldRefs {
    readonly id: FieldRef<"Maintainer", 'Int'>
    readonly first_name: FieldRef<"Maintainer", 'String'>
    readonly last_name: FieldRef<"Maintainer", 'String'>
    readonly email: FieldRef<"Maintainer", 'String'>
    readonly password: FieldRef<"Maintainer", 'String'>
    readonly phone: FieldRef<"Maintainer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Maintainer findUnique
   */
  export type MaintainerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    /**
     * Filter, which Maintainer to fetch.
     */
    where: MaintainerWhereUniqueInput
  }

  /**
   * Maintainer findUniqueOrThrow
   */
  export type MaintainerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    /**
     * Filter, which Maintainer to fetch.
     */
    where: MaintainerWhereUniqueInput
  }

  /**
   * Maintainer findFirst
   */
  export type MaintainerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    /**
     * Filter, which Maintainer to fetch.
     */
    where?: MaintainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintainers to fetch.
     */
    orderBy?: MaintainerOrderByWithRelationInput | MaintainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maintainers.
     */
    cursor?: MaintainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintainers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintainers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maintainers.
     */
    distinct?: MaintainerScalarFieldEnum | MaintainerScalarFieldEnum[]
  }

  /**
   * Maintainer findFirstOrThrow
   */
  export type MaintainerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    /**
     * Filter, which Maintainer to fetch.
     */
    where?: MaintainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintainers to fetch.
     */
    orderBy?: MaintainerOrderByWithRelationInput | MaintainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maintainers.
     */
    cursor?: MaintainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintainers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintainers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maintainers.
     */
    distinct?: MaintainerScalarFieldEnum | MaintainerScalarFieldEnum[]
  }

  /**
   * Maintainer findMany
   */
  export type MaintainerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    /**
     * Filter, which Maintainers to fetch.
     */
    where?: MaintainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintainers to fetch.
     */
    orderBy?: MaintainerOrderByWithRelationInput | MaintainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Maintainers.
     */
    cursor?: MaintainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintainers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintainers.
     */
    skip?: number
    distinct?: MaintainerScalarFieldEnum | MaintainerScalarFieldEnum[]
  }

  /**
   * Maintainer create
   */
  export type MaintainerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    /**
     * The data needed to create a Maintainer.
     */
    data: XOR<MaintainerCreateInput, MaintainerUncheckedCreateInput>
  }

  /**
   * Maintainer createMany
   */
  export type MaintainerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Maintainers.
     */
    data: MaintainerCreateManyInput | MaintainerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Maintainer createManyAndReturn
   */
  export type MaintainerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * The data used to create many Maintainers.
     */
    data: MaintainerCreateManyInput | MaintainerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Maintainer update
   */
  export type MaintainerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    /**
     * The data needed to update a Maintainer.
     */
    data: XOR<MaintainerUpdateInput, MaintainerUncheckedUpdateInput>
    /**
     * Choose, which Maintainer to update.
     */
    where: MaintainerWhereUniqueInput
  }

  /**
   * Maintainer updateMany
   */
  export type MaintainerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Maintainers.
     */
    data: XOR<MaintainerUpdateManyMutationInput, MaintainerUncheckedUpdateManyInput>
    /**
     * Filter which Maintainers to update
     */
    where?: MaintainerWhereInput
    /**
     * Limit how many Maintainers to update.
     */
    limit?: number
  }

  /**
   * Maintainer updateManyAndReturn
   */
  export type MaintainerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * The data used to update Maintainers.
     */
    data: XOR<MaintainerUpdateManyMutationInput, MaintainerUncheckedUpdateManyInput>
    /**
     * Filter which Maintainers to update
     */
    where?: MaintainerWhereInput
    /**
     * Limit how many Maintainers to update.
     */
    limit?: number
  }

  /**
   * Maintainer upsert
   */
  export type MaintainerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    /**
     * The filter to search for the Maintainer to update in case it exists.
     */
    where: MaintainerWhereUniqueInput
    /**
     * In case the Maintainer found by the `where` argument doesn't exist, create a new Maintainer with this data.
     */
    create: XOR<MaintainerCreateInput, MaintainerUncheckedCreateInput>
    /**
     * In case the Maintainer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintainerUpdateInput, MaintainerUncheckedUpdateInput>
  }

  /**
   * Maintainer delete
   */
  export type MaintainerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    /**
     * Filter which Maintainer to delete.
     */
    where: MaintainerWhereUniqueInput
  }

  /**
   * Maintainer deleteMany
   */
  export type MaintainerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maintainers to delete
     */
    where?: MaintainerWhereInput
    /**
     * Limit how many Maintainers to delete.
     */
    limit?: number
  }

  /**
   * Maintainer.DispoIssue
   */
  export type Maintainer$DispoIssueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispoIssue
     */
    select?: DispoIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispoIssue
     */
    omit?: DispoIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispoIssueInclude<ExtArgs> | null
    where?: DispoIssueWhereInput
    orderBy?: DispoIssueOrderByWithRelationInput | DispoIssueOrderByWithRelationInput[]
    cursor?: DispoIssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DispoIssueScalarFieldEnum | DispoIssueScalarFieldEnum[]
  }

  /**
   * Maintainer.Intervention
   */
  export type Maintainer$InterventionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    where?: InterventionWhereInput
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    cursor?: InterventionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Maintainer without action
   */
  export type MaintainerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    price: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    price: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    name: string
    description: string | null
    price: number
    created_at: Date
    updated_at: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
    Dispositive?: boolean | Product$DispositiveArgs<ExtArgs>
    ProductQuotation?: boolean | Product$ProductQuotationArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "price" | "created_at" | "updated_at", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Dispositive?: boolean | Product$DispositiveArgs<ExtArgs>
    ProductQuotation?: boolean | Product$ProductQuotationArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      Dispositive: Prisma.$DispositivePayload<ExtArgs>[]
      ProductQuotation: Prisma.$ProductQuotationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      price: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Dispositive<T extends Product$DispositiveArgs<ExtArgs> = {}>(args?: Subset<T, Product$DispositiveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispositivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProductQuotation<T extends Product$ProductQuotationArgs<ExtArgs> = {}>(args?: Subset<T, Product$ProductQuotationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductQuotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly created_at: FieldRef<"Product", 'DateTime'>
    readonly updated_at: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.Dispositive
   */
  export type Product$DispositiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositive
     */
    select?: DispositiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispositive
     */
    omit?: DispositiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispositiveInclude<ExtArgs> | null
    where?: DispositiveWhereInput
    orderBy?: DispositiveOrderByWithRelationInput | DispositiveOrderByWithRelationInput[]
    cursor?: DispositiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DispositiveScalarFieldEnum | DispositiveScalarFieldEnum[]
  }

  /**
   * Product.ProductQuotation
   */
  export type Product$ProductQuotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuotation
     */
    select?: ProductQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuotation
     */
    omit?: ProductQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQuotationInclude<ExtArgs> | null
    where?: ProductQuotationWhereInput
    orderBy?: ProductQuotationOrderByWithRelationInput | ProductQuotationOrderByWithRelationInput[]
    cursor?: ProductQuotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductQuotationScalarFieldEnum | ProductQuotationScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductQuotation
   */

  export type AggregateProductQuotation = {
    _count: ProductQuotationCountAggregateOutputType | null
    _avg: ProductQuotationAvgAggregateOutputType | null
    _sum: ProductQuotationSumAggregateOutputType | null
    _min: ProductQuotationMinAggregateOutputType | null
    _max: ProductQuotationMaxAggregateOutputType | null
  }

  export type ProductQuotationAvgAggregateOutputType = {
    quotation_id: number | null
    product_id: number | null
    count: number | null
  }

  export type ProductQuotationSumAggregateOutputType = {
    quotation_id: number | null
    product_id: number | null
    count: number | null
  }

  export type ProductQuotationMinAggregateOutputType = {
    quotation_id: number | null
    product_id: number | null
    count: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductQuotationMaxAggregateOutputType = {
    quotation_id: number | null
    product_id: number | null
    count: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductQuotationCountAggregateOutputType = {
    quotation_id: number
    product_id: number
    count: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProductQuotationAvgAggregateInputType = {
    quotation_id?: true
    product_id?: true
    count?: true
  }

  export type ProductQuotationSumAggregateInputType = {
    quotation_id?: true
    product_id?: true
    count?: true
  }

  export type ProductQuotationMinAggregateInputType = {
    quotation_id?: true
    product_id?: true
    count?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductQuotationMaxAggregateInputType = {
    quotation_id?: true
    product_id?: true
    count?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductQuotationCountAggregateInputType = {
    quotation_id?: true
    product_id?: true
    count?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProductQuotationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductQuotation to aggregate.
     */
    where?: ProductQuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductQuotations to fetch.
     */
    orderBy?: ProductQuotationOrderByWithRelationInput | ProductQuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductQuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductQuotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductQuotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductQuotations
    **/
    _count?: true | ProductQuotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductQuotationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductQuotationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductQuotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductQuotationMaxAggregateInputType
  }

  export type GetProductQuotationAggregateType<T extends ProductQuotationAggregateArgs> = {
        [P in keyof T & keyof AggregateProductQuotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductQuotation[P]>
      : GetScalarType<T[P], AggregateProductQuotation[P]>
  }




  export type ProductQuotationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductQuotationWhereInput
    orderBy?: ProductQuotationOrderByWithAggregationInput | ProductQuotationOrderByWithAggregationInput[]
    by: ProductQuotationScalarFieldEnum[] | ProductQuotationScalarFieldEnum
    having?: ProductQuotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductQuotationCountAggregateInputType | true
    _avg?: ProductQuotationAvgAggregateInputType
    _sum?: ProductQuotationSumAggregateInputType
    _min?: ProductQuotationMinAggregateInputType
    _max?: ProductQuotationMaxAggregateInputType
  }

  export type ProductQuotationGroupByOutputType = {
    quotation_id: number
    product_id: number
    count: number
    created_at: Date
    updated_at: Date
    _count: ProductQuotationCountAggregateOutputType | null
    _avg: ProductQuotationAvgAggregateOutputType | null
    _sum: ProductQuotationSumAggregateOutputType | null
    _min: ProductQuotationMinAggregateOutputType | null
    _max: ProductQuotationMaxAggregateOutputType | null
  }

  type GetProductQuotationGroupByPayload<T extends ProductQuotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductQuotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductQuotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductQuotationGroupByOutputType[P]>
            : GetScalarType<T[P], ProductQuotationGroupByOutputType[P]>
        }
      >
    >


  export type ProductQuotationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    quotation_id?: boolean
    product_id?: boolean
    count?: boolean
    created_at?: boolean
    updated_at?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    Quotation?: boolean | QuotationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productQuotation"]>

  export type ProductQuotationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    quotation_id?: boolean
    product_id?: boolean
    count?: boolean
    created_at?: boolean
    updated_at?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    Quotation?: boolean | QuotationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productQuotation"]>

  export type ProductQuotationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    quotation_id?: boolean
    product_id?: boolean
    count?: boolean
    created_at?: boolean
    updated_at?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    Quotation?: boolean | QuotationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productQuotation"]>

  export type ProductQuotationSelectScalar = {
    quotation_id?: boolean
    product_id?: boolean
    count?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProductQuotationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"quotation_id" | "product_id" | "count" | "created_at" | "updated_at", ExtArgs["result"]["productQuotation"]>
  export type ProductQuotationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    Quotation?: boolean | QuotationDefaultArgs<ExtArgs>
  }
  export type ProductQuotationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    Quotation?: boolean | QuotationDefaultArgs<ExtArgs>
  }
  export type ProductQuotationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    Quotation?: boolean | QuotationDefaultArgs<ExtArgs>
  }

  export type $ProductQuotationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductQuotation"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs>
      Quotation: Prisma.$QuotationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      quotation_id: number
      product_id: number
      count: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["productQuotation"]>
    composites: {}
  }

  type ProductQuotationGetPayload<S extends boolean | null | undefined | ProductQuotationDefaultArgs> = $Result.GetResult<Prisma.$ProductQuotationPayload, S>

  type ProductQuotationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductQuotationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductQuotationCountAggregateInputType | true
    }

  export interface ProductQuotationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductQuotation'], meta: { name: 'ProductQuotation' } }
    /**
     * Find zero or one ProductQuotation that matches the filter.
     * @param {ProductQuotationFindUniqueArgs} args - Arguments to find a ProductQuotation
     * @example
     * // Get one ProductQuotation
     * const productQuotation = await prisma.productQuotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductQuotationFindUniqueArgs>(args: SelectSubset<T, ProductQuotationFindUniqueArgs<ExtArgs>>): Prisma__ProductQuotationClient<$Result.GetResult<Prisma.$ProductQuotationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductQuotation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductQuotationFindUniqueOrThrowArgs} args - Arguments to find a ProductQuotation
     * @example
     * // Get one ProductQuotation
     * const productQuotation = await prisma.productQuotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductQuotationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductQuotationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductQuotationClient<$Result.GetResult<Prisma.$ProductQuotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductQuotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQuotationFindFirstArgs} args - Arguments to find a ProductQuotation
     * @example
     * // Get one ProductQuotation
     * const productQuotation = await prisma.productQuotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductQuotationFindFirstArgs>(args?: SelectSubset<T, ProductQuotationFindFirstArgs<ExtArgs>>): Prisma__ProductQuotationClient<$Result.GetResult<Prisma.$ProductQuotationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductQuotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQuotationFindFirstOrThrowArgs} args - Arguments to find a ProductQuotation
     * @example
     * // Get one ProductQuotation
     * const productQuotation = await prisma.productQuotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductQuotationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductQuotationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductQuotationClient<$Result.GetResult<Prisma.$ProductQuotationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductQuotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQuotationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductQuotations
     * const productQuotations = await prisma.productQuotation.findMany()
     * 
     * // Get first 10 ProductQuotations
     * const productQuotations = await prisma.productQuotation.findMany({ take: 10 })
     * 
     * // Only select the `quotation_id`
     * const productQuotationWithQuotation_idOnly = await prisma.productQuotation.findMany({ select: { quotation_id: true } })
     * 
     */
    findMany<T extends ProductQuotationFindManyArgs>(args?: SelectSubset<T, ProductQuotationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductQuotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductQuotation.
     * @param {ProductQuotationCreateArgs} args - Arguments to create a ProductQuotation.
     * @example
     * // Create one ProductQuotation
     * const ProductQuotation = await prisma.productQuotation.create({
     *   data: {
     *     // ... data to create a ProductQuotation
     *   }
     * })
     * 
     */
    create<T extends ProductQuotationCreateArgs>(args: SelectSubset<T, ProductQuotationCreateArgs<ExtArgs>>): Prisma__ProductQuotationClient<$Result.GetResult<Prisma.$ProductQuotationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductQuotations.
     * @param {ProductQuotationCreateManyArgs} args - Arguments to create many ProductQuotations.
     * @example
     * // Create many ProductQuotations
     * const productQuotation = await prisma.productQuotation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductQuotationCreateManyArgs>(args?: SelectSubset<T, ProductQuotationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductQuotations and returns the data saved in the database.
     * @param {ProductQuotationCreateManyAndReturnArgs} args - Arguments to create many ProductQuotations.
     * @example
     * // Create many ProductQuotations
     * const productQuotation = await prisma.productQuotation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductQuotations and only return the `quotation_id`
     * const productQuotationWithQuotation_idOnly = await prisma.productQuotation.createManyAndReturn({
     *   select: { quotation_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductQuotationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductQuotationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductQuotationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductQuotation.
     * @param {ProductQuotationDeleteArgs} args - Arguments to delete one ProductQuotation.
     * @example
     * // Delete one ProductQuotation
     * const ProductQuotation = await prisma.productQuotation.delete({
     *   where: {
     *     // ... filter to delete one ProductQuotation
     *   }
     * })
     * 
     */
    delete<T extends ProductQuotationDeleteArgs>(args: SelectSubset<T, ProductQuotationDeleteArgs<ExtArgs>>): Prisma__ProductQuotationClient<$Result.GetResult<Prisma.$ProductQuotationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductQuotation.
     * @param {ProductQuotationUpdateArgs} args - Arguments to update one ProductQuotation.
     * @example
     * // Update one ProductQuotation
     * const productQuotation = await prisma.productQuotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductQuotationUpdateArgs>(args: SelectSubset<T, ProductQuotationUpdateArgs<ExtArgs>>): Prisma__ProductQuotationClient<$Result.GetResult<Prisma.$ProductQuotationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductQuotations.
     * @param {ProductQuotationDeleteManyArgs} args - Arguments to filter ProductQuotations to delete.
     * @example
     * // Delete a few ProductQuotations
     * const { count } = await prisma.productQuotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductQuotationDeleteManyArgs>(args?: SelectSubset<T, ProductQuotationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductQuotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQuotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductQuotations
     * const productQuotation = await prisma.productQuotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductQuotationUpdateManyArgs>(args: SelectSubset<T, ProductQuotationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductQuotations and returns the data updated in the database.
     * @param {ProductQuotationUpdateManyAndReturnArgs} args - Arguments to update many ProductQuotations.
     * @example
     * // Update many ProductQuotations
     * const productQuotation = await prisma.productQuotation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductQuotations and only return the `quotation_id`
     * const productQuotationWithQuotation_idOnly = await prisma.productQuotation.updateManyAndReturn({
     *   select: { quotation_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductQuotationUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductQuotationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductQuotationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductQuotation.
     * @param {ProductQuotationUpsertArgs} args - Arguments to update or create a ProductQuotation.
     * @example
     * // Update or create a ProductQuotation
     * const productQuotation = await prisma.productQuotation.upsert({
     *   create: {
     *     // ... data to create a ProductQuotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductQuotation we want to update
     *   }
     * })
     */
    upsert<T extends ProductQuotationUpsertArgs>(args: SelectSubset<T, ProductQuotationUpsertArgs<ExtArgs>>): Prisma__ProductQuotationClient<$Result.GetResult<Prisma.$ProductQuotationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductQuotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQuotationCountArgs} args - Arguments to filter ProductQuotations to count.
     * @example
     * // Count the number of ProductQuotations
     * const count = await prisma.productQuotation.count({
     *   where: {
     *     // ... the filter for the ProductQuotations we want to count
     *   }
     * })
    **/
    count<T extends ProductQuotationCountArgs>(
      args?: Subset<T, ProductQuotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductQuotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductQuotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQuotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductQuotationAggregateArgs>(args: Subset<T, ProductQuotationAggregateArgs>): Prisma.PrismaPromise<GetProductQuotationAggregateType<T>>

    /**
     * Group by ProductQuotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQuotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductQuotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductQuotationGroupByArgs['orderBy'] }
        : { orderBy?: ProductQuotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductQuotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductQuotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductQuotation model
   */
  readonly fields: ProductQuotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductQuotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductQuotationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Quotation<T extends QuotationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuotationDefaultArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductQuotation model
   */
  interface ProductQuotationFieldRefs {
    readonly quotation_id: FieldRef<"ProductQuotation", 'Int'>
    readonly product_id: FieldRef<"ProductQuotation", 'Int'>
    readonly count: FieldRef<"ProductQuotation", 'Int'>
    readonly created_at: FieldRef<"ProductQuotation", 'DateTime'>
    readonly updated_at: FieldRef<"ProductQuotation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductQuotation findUnique
   */
  export type ProductQuotationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuotation
     */
    select?: ProductQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuotation
     */
    omit?: ProductQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQuotationInclude<ExtArgs> | null
    /**
     * Filter, which ProductQuotation to fetch.
     */
    where: ProductQuotationWhereUniqueInput
  }

  /**
   * ProductQuotation findUniqueOrThrow
   */
  export type ProductQuotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuotation
     */
    select?: ProductQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuotation
     */
    omit?: ProductQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQuotationInclude<ExtArgs> | null
    /**
     * Filter, which ProductQuotation to fetch.
     */
    where: ProductQuotationWhereUniqueInput
  }

  /**
   * ProductQuotation findFirst
   */
  export type ProductQuotationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuotation
     */
    select?: ProductQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuotation
     */
    omit?: ProductQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQuotationInclude<ExtArgs> | null
    /**
     * Filter, which ProductQuotation to fetch.
     */
    where?: ProductQuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductQuotations to fetch.
     */
    orderBy?: ProductQuotationOrderByWithRelationInput | ProductQuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductQuotations.
     */
    cursor?: ProductQuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductQuotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductQuotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductQuotations.
     */
    distinct?: ProductQuotationScalarFieldEnum | ProductQuotationScalarFieldEnum[]
  }

  /**
   * ProductQuotation findFirstOrThrow
   */
  export type ProductQuotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuotation
     */
    select?: ProductQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuotation
     */
    omit?: ProductQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQuotationInclude<ExtArgs> | null
    /**
     * Filter, which ProductQuotation to fetch.
     */
    where?: ProductQuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductQuotations to fetch.
     */
    orderBy?: ProductQuotationOrderByWithRelationInput | ProductQuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductQuotations.
     */
    cursor?: ProductQuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductQuotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductQuotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductQuotations.
     */
    distinct?: ProductQuotationScalarFieldEnum | ProductQuotationScalarFieldEnum[]
  }

  /**
   * ProductQuotation findMany
   */
  export type ProductQuotationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuotation
     */
    select?: ProductQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuotation
     */
    omit?: ProductQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQuotationInclude<ExtArgs> | null
    /**
     * Filter, which ProductQuotations to fetch.
     */
    where?: ProductQuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductQuotations to fetch.
     */
    orderBy?: ProductQuotationOrderByWithRelationInput | ProductQuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductQuotations.
     */
    cursor?: ProductQuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductQuotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductQuotations.
     */
    skip?: number
    distinct?: ProductQuotationScalarFieldEnum | ProductQuotationScalarFieldEnum[]
  }

  /**
   * ProductQuotation create
   */
  export type ProductQuotationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuotation
     */
    select?: ProductQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuotation
     */
    omit?: ProductQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQuotationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductQuotation.
     */
    data: XOR<ProductQuotationCreateInput, ProductQuotationUncheckedCreateInput>
  }

  /**
   * ProductQuotation createMany
   */
  export type ProductQuotationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductQuotations.
     */
    data: ProductQuotationCreateManyInput | ProductQuotationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductQuotation createManyAndReturn
   */
  export type ProductQuotationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuotation
     */
    select?: ProductQuotationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuotation
     */
    omit?: ProductQuotationOmit<ExtArgs> | null
    /**
     * The data used to create many ProductQuotations.
     */
    data: ProductQuotationCreateManyInput | ProductQuotationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQuotationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductQuotation update
   */
  export type ProductQuotationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuotation
     */
    select?: ProductQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuotation
     */
    omit?: ProductQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQuotationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductQuotation.
     */
    data: XOR<ProductQuotationUpdateInput, ProductQuotationUncheckedUpdateInput>
    /**
     * Choose, which ProductQuotation to update.
     */
    where: ProductQuotationWhereUniqueInput
  }

  /**
   * ProductQuotation updateMany
   */
  export type ProductQuotationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductQuotations.
     */
    data: XOR<ProductQuotationUpdateManyMutationInput, ProductQuotationUncheckedUpdateManyInput>
    /**
     * Filter which ProductQuotations to update
     */
    where?: ProductQuotationWhereInput
    /**
     * Limit how many ProductQuotations to update.
     */
    limit?: number
  }

  /**
   * ProductQuotation updateManyAndReturn
   */
  export type ProductQuotationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuotation
     */
    select?: ProductQuotationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuotation
     */
    omit?: ProductQuotationOmit<ExtArgs> | null
    /**
     * The data used to update ProductQuotations.
     */
    data: XOR<ProductQuotationUpdateManyMutationInput, ProductQuotationUncheckedUpdateManyInput>
    /**
     * Filter which ProductQuotations to update
     */
    where?: ProductQuotationWhereInput
    /**
     * Limit how many ProductQuotations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQuotationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductQuotation upsert
   */
  export type ProductQuotationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuotation
     */
    select?: ProductQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuotation
     */
    omit?: ProductQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQuotationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductQuotation to update in case it exists.
     */
    where: ProductQuotationWhereUniqueInput
    /**
     * In case the ProductQuotation found by the `where` argument doesn't exist, create a new ProductQuotation with this data.
     */
    create: XOR<ProductQuotationCreateInput, ProductQuotationUncheckedCreateInput>
    /**
     * In case the ProductQuotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductQuotationUpdateInput, ProductQuotationUncheckedUpdateInput>
  }

  /**
   * ProductQuotation delete
   */
  export type ProductQuotationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuotation
     */
    select?: ProductQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuotation
     */
    omit?: ProductQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQuotationInclude<ExtArgs> | null
    /**
     * Filter which ProductQuotation to delete.
     */
    where: ProductQuotationWhereUniqueInput
  }

  /**
   * ProductQuotation deleteMany
   */
  export type ProductQuotationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductQuotations to delete
     */
    where?: ProductQuotationWhereInput
    /**
     * Limit how many ProductQuotations to delete.
     */
    limit?: number
  }

  /**
   * ProductQuotation without action
   */
  export type ProductQuotationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuotation
     */
    select?: ProductQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuotation
     */
    omit?: ProductQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQuotationInclude<ExtArgs> | null
  }


  /**
   * Model ProductTransaction
   */

  export type AggregateProductTransaction = {
    _count: ProductTransactionCountAggregateOutputType | null
    _avg: ProductTransactionAvgAggregateOutputType | null
    _sum: ProductTransactionSumAggregateOutputType | null
    _min: ProductTransactionMinAggregateOutputType | null
    _max: ProductTransactionMaxAggregateOutputType | null
  }

  export type ProductTransactionAvgAggregateOutputType = {
    transaction_id: number | null
    dispositive_id: number | null
  }

  export type ProductTransactionSumAggregateOutputType = {
    transaction_id: number | null
    dispositive_id: number | null
  }

  export type ProductTransactionMinAggregateOutputType = {
    transaction_id: number | null
    dispositive_id: number | null
    isConfirmed: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductTransactionMaxAggregateOutputType = {
    transaction_id: number | null
    dispositive_id: number | null
    isConfirmed: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductTransactionCountAggregateOutputType = {
    transaction_id: number
    dispositive_id: number
    isConfirmed: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProductTransactionAvgAggregateInputType = {
    transaction_id?: true
    dispositive_id?: true
  }

  export type ProductTransactionSumAggregateInputType = {
    transaction_id?: true
    dispositive_id?: true
  }

  export type ProductTransactionMinAggregateInputType = {
    transaction_id?: true
    dispositive_id?: true
    isConfirmed?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductTransactionMaxAggregateInputType = {
    transaction_id?: true
    dispositive_id?: true
    isConfirmed?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductTransactionCountAggregateInputType = {
    transaction_id?: true
    dispositive_id?: true
    isConfirmed?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProductTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductTransaction to aggregate.
     */
    where?: ProductTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTransactions to fetch.
     */
    orderBy?: ProductTransactionOrderByWithRelationInput | ProductTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductTransactions
    **/
    _count?: true | ProductTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductTransactionMaxAggregateInputType
  }

  export type GetProductTransactionAggregateType<T extends ProductTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateProductTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductTransaction[P]>
      : GetScalarType<T[P], AggregateProductTransaction[P]>
  }




  export type ProductTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTransactionWhereInput
    orderBy?: ProductTransactionOrderByWithAggregationInput | ProductTransactionOrderByWithAggregationInput[]
    by: ProductTransactionScalarFieldEnum[] | ProductTransactionScalarFieldEnum
    having?: ProductTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductTransactionCountAggregateInputType | true
    _avg?: ProductTransactionAvgAggregateInputType
    _sum?: ProductTransactionSumAggregateInputType
    _min?: ProductTransactionMinAggregateInputType
    _max?: ProductTransactionMaxAggregateInputType
  }

  export type ProductTransactionGroupByOutputType = {
    transaction_id: number
    dispositive_id: number
    isConfirmed: boolean
    created_at: Date
    updated_at: Date
    _count: ProductTransactionCountAggregateOutputType | null
    _avg: ProductTransactionAvgAggregateOutputType | null
    _sum: ProductTransactionSumAggregateOutputType | null
    _min: ProductTransactionMinAggregateOutputType | null
    _max: ProductTransactionMaxAggregateOutputType | null
  }

  type GetProductTransactionGroupByPayload<T extends ProductTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], ProductTransactionGroupByOutputType[P]>
        }
      >
    >


  export type ProductTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    transaction_id?: boolean
    dispositive_id?: boolean
    isConfirmed?: boolean
    created_at?: boolean
    updated_at?: boolean
    Dispositive?: boolean | DispositiveDefaultArgs<ExtArgs>
    Transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productTransaction"]>

  export type ProductTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    transaction_id?: boolean
    dispositive_id?: boolean
    isConfirmed?: boolean
    created_at?: boolean
    updated_at?: boolean
    Dispositive?: boolean | DispositiveDefaultArgs<ExtArgs>
    Transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productTransaction"]>

  export type ProductTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    transaction_id?: boolean
    dispositive_id?: boolean
    isConfirmed?: boolean
    created_at?: boolean
    updated_at?: boolean
    Dispositive?: boolean | DispositiveDefaultArgs<ExtArgs>
    Transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productTransaction"]>

  export type ProductTransactionSelectScalar = {
    transaction_id?: boolean
    dispositive_id?: boolean
    isConfirmed?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProductTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"transaction_id" | "dispositive_id" | "isConfirmed" | "created_at" | "updated_at", ExtArgs["result"]["productTransaction"]>
  export type ProductTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Dispositive?: boolean | DispositiveDefaultArgs<ExtArgs>
    Transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type ProductTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Dispositive?: boolean | DispositiveDefaultArgs<ExtArgs>
    Transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type ProductTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Dispositive?: boolean | DispositiveDefaultArgs<ExtArgs>
    Transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }

  export type $ProductTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductTransaction"
    objects: {
      Dispositive: Prisma.$DispositivePayload<ExtArgs>
      Transaction: Prisma.$TransactionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      transaction_id: number
      dispositive_id: number
      isConfirmed: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["productTransaction"]>
    composites: {}
  }

  type ProductTransactionGetPayload<S extends boolean | null | undefined | ProductTransactionDefaultArgs> = $Result.GetResult<Prisma.$ProductTransactionPayload, S>

  type ProductTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductTransactionCountAggregateInputType | true
    }

  export interface ProductTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductTransaction'], meta: { name: 'ProductTransaction' } }
    /**
     * Find zero or one ProductTransaction that matches the filter.
     * @param {ProductTransactionFindUniqueArgs} args - Arguments to find a ProductTransaction
     * @example
     * // Get one ProductTransaction
     * const productTransaction = await prisma.productTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductTransactionFindUniqueArgs>(args: SelectSubset<T, ProductTransactionFindUniqueArgs<ExtArgs>>): Prisma__ProductTransactionClient<$Result.GetResult<Prisma.$ProductTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductTransactionFindUniqueOrThrowArgs} args - Arguments to find a ProductTransaction
     * @example
     * // Get one ProductTransaction
     * const productTransaction = await prisma.productTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductTransactionClient<$Result.GetResult<Prisma.$ProductTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTransactionFindFirstArgs} args - Arguments to find a ProductTransaction
     * @example
     * // Get one ProductTransaction
     * const productTransaction = await prisma.productTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductTransactionFindFirstArgs>(args?: SelectSubset<T, ProductTransactionFindFirstArgs<ExtArgs>>): Prisma__ProductTransactionClient<$Result.GetResult<Prisma.$ProductTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTransactionFindFirstOrThrowArgs} args - Arguments to find a ProductTransaction
     * @example
     * // Get one ProductTransaction
     * const productTransaction = await prisma.productTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductTransactionClient<$Result.GetResult<Prisma.$ProductTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductTransactions
     * const productTransactions = await prisma.productTransaction.findMany()
     * 
     * // Get first 10 ProductTransactions
     * const productTransactions = await prisma.productTransaction.findMany({ take: 10 })
     * 
     * // Only select the `transaction_id`
     * const productTransactionWithTransaction_idOnly = await prisma.productTransaction.findMany({ select: { transaction_id: true } })
     * 
     */
    findMany<T extends ProductTransactionFindManyArgs>(args?: SelectSubset<T, ProductTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductTransaction.
     * @param {ProductTransactionCreateArgs} args - Arguments to create a ProductTransaction.
     * @example
     * // Create one ProductTransaction
     * const ProductTransaction = await prisma.productTransaction.create({
     *   data: {
     *     // ... data to create a ProductTransaction
     *   }
     * })
     * 
     */
    create<T extends ProductTransactionCreateArgs>(args: SelectSubset<T, ProductTransactionCreateArgs<ExtArgs>>): Prisma__ProductTransactionClient<$Result.GetResult<Prisma.$ProductTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductTransactions.
     * @param {ProductTransactionCreateManyArgs} args - Arguments to create many ProductTransactions.
     * @example
     * // Create many ProductTransactions
     * const productTransaction = await prisma.productTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductTransactionCreateManyArgs>(args?: SelectSubset<T, ProductTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductTransactions and returns the data saved in the database.
     * @param {ProductTransactionCreateManyAndReturnArgs} args - Arguments to create many ProductTransactions.
     * @example
     * // Create many ProductTransactions
     * const productTransaction = await prisma.productTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductTransactions and only return the `transaction_id`
     * const productTransactionWithTransaction_idOnly = await prisma.productTransaction.createManyAndReturn({
     *   select: { transaction_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductTransaction.
     * @param {ProductTransactionDeleteArgs} args - Arguments to delete one ProductTransaction.
     * @example
     * // Delete one ProductTransaction
     * const ProductTransaction = await prisma.productTransaction.delete({
     *   where: {
     *     // ... filter to delete one ProductTransaction
     *   }
     * })
     * 
     */
    delete<T extends ProductTransactionDeleteArgs>(args: SelectSubset<T, ProductTransactionDeleteArgs<ExtArgs>>): Prisma__ProductTransactionClient<$Result.GetResult<Prisma.$ProductTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductTransaction.
     * @param {ProductTransactionUpdateArgs} args - Arguments to update one ProductTransaction.
     * @example
     * // Update one ProductTransaction
     * const productTransaction = await prisma.productTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductTransactionUpdateArgs>(args: SelectSubset<T, ProductTransactionUpdateArgs<ExtArgs>>): Prisma__ProductTransactionClient<$Result.GetResult<Prisma.$ProductTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductTransactions.
     * @param {ProductTransactionDeleteManyArgs} args - Arguments to filter ProductTransactions to delete.
     * @example
     * // Delete a few ProductTransactions
     * const { count } = await prisma.productTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductTransactionDeleteManyArgs>(args?: SelectSubset<T, ProductTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductTransactions
     * const productTransaction = await prisma.productTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductTransactionUpdateManyArgs>(args: SelectSubset<T, ProductTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductTransactions and returns the data updated in the database.
     * @param {ProductTransactionUpdateManyAndReturnArgs} args - Arguments to update many ProductTransactions.
     * @example
     * // Update many ProductTransactions
     * const productTransaction = await prisma.productTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductTransactions and only return the `transaction_id`
     * const productTransactionWithTransaction_idOnly = await prisma.productTransaction.updateManyAndReturn({
     *   select: { transaction_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductTransaction.
     * @param {ProductTransactionUpsertArgs} args - Arguments to update or create a ProductTransaction.
     * @example
     * // Update or create a ProductTransaction
     * const productTransaction = await prisma.productTransaction.upsert({
     *   create: {
     *     // ... data to create a ProductTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductTransaction we want to update
     *   }
     * })
     */
    upsert<T extends ProductTransactionUpsertArgs>(args: SelectSubset<T, ProductTransactionUpsertArgs<ExtArgs>>): Prisma__ProductTransactionClient<$Result.GetResult<Prisma.$ProductTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTransactionCountArgs} args - Arguments to filter ProductTransactions to count.
     * @example
     * // Count the number of ProductTransactions
     * const count = await prisma.productTransaction.count({
     *   where: {
     *     // ... the filter for the ProductTransactions we want to count
     *   }
     * })
    **/
    count<T extends ProductTransactionCountArgs>(
      args?: Subset<T, ProductTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductTransactionAggregateArgs>(args: Subset<T, ProductTransactionAggregateArgs>): Prisma.PrismaPromise<GetProductTransactionAggregateType<T>>

    /**
     * Group by ProductTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductTransactionGroupByArgs['orderBy'] }
        : { orderBy?: ProductTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductTransaction model
   */
  readonly fields: ProductTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Dispositive<T extends DispositiveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DispositiveDefaultArgs<ExtArgs>>): Prisma__DispositiveClient<$Result.GetResult<Prisma.$DispositivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductTransaction model
   */
  interface ProductTransactionFieldRefs {
    readonly transaction_id: FieldRef<"ProductTransaction", 'Int'>
    readonly dispositive_id: FieldRef<"ProductTransaction", 'Int'>
    readonly isConfirmed: FieldRef<"ProductTransaction", 'Boolean'>
    readonly created_at: FieldRef<"ProductTransaction", 'DateTime'>
    readonly updated_at: FieldRef<"ProductTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductTransaction findUnique
   */
  export type ProductTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransaction
     */
    select?: ProductTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransaction
     */
    omit?: ProductTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ProductTransaction to fetch.
     */
    where: ProductTransactionWhereUniqueInput
  }

  /**
   * ProductTransaction findUniqueOrThrow
   */
  export type ProductTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransaction
     */
    select?: ProductTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransaction
     */
    omit?: ProductTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ProductTransaction to fetch.
     */
    where: ProductTransactionWhereUniqueInput
  }

  /**
   * ProductTransaction findFirst
   */
  export type ProductTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransaction
     */
    select?: ProductTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransaction
     */
    omit?: ProductTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ProductTransaction to fetch.
     */
    where?: ProductTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTransactions to fetch.
     */
    orderBy?: ProductTransactionOrderByWithRelationInput | ProductTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTransactions.
     */
    cursor?: ProductTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTransactions.
     */
    distinct?: ProductTransactionScalarFieldEnum | ProductTransactionScalarFieldEnum[]
  }

  /**
   * ProductTransaction findFirstOrThrow
   */
  export type ProductTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransaction
     */
    select?: ProductTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransaction
     */
    omit?: ProductTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ProductTransaction to fetch.
     */
    where?: ProductTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTransactions to fetch.
     */
    orderBy?: ProductTransactionOrderByWithRelationInput | ProductTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTransactions.
     */
    cursor?: ProductTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTransactions.
     */
    distinct?: ProductTransactionScalarFieldEnum | ProductTransactionScalarFieldEnum[]
  }

  /**
   * ProductTransaction findMany
   */
  export type ProductTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransaction
     */
    select?: ProductTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransaction
     */
    omit?: ProductTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ProductTransactions to fetch.
     */
    where?: ProductTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTransactions to fetch.
     */
    orderBy?: ProductTransactionOrderByWithRelationInput | ProductTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductTransactions.
     */
    cursor?: ProductTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTransactions.
     */
    skip?: number
    distinct?: ProductTransactionScalarFieldEnum | ProductTransactionScalarFieldEnum[]
  }

  /**
   * ProductTransaction create
   */
  export type ProductTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransaction
     */
    select?: ProductTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransaction
     */
    omit?: ProductTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductTransaction.
     */
    data: XOR<ProductTransactionCreateInput, ProductTransactionUncheckedCreateInput>
  }

  /**
   * ProductTransaction createMany
   */
  export type ProductTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductTransactions.
     */
    data: ProductTransactionCreateManyInput | ProductTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductTransaction createManyAndReturn
   */
  export type ProductTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransaction
     */
    select?: ProductTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransaction
     */
    omit?: ProductTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many ProductTransactions.
     */
    data: ProductTransactionCreateManyInput | ProductTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductTransaction update
   */
  export type ProductTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransaction
     */
    select?: ProductTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransaction
     */
    omit?: ProductTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductTransaction.
     */
    data: XOR<ProductTransactionUpdateInput, ProductTransactionUncheckedUpdateInput>
    /**
     * Choose, which ProductTransaction to update.
     */
    where: ProductTransactionWhereUniqueInput
  }

  /**
   * ProductTransaction updateMany
   */
  export type ProductTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductTransactions.
     */
    data: XOR<ProductTransactionUpdateManyMutationInput, ProductTransactionUncheckedUpdateManyInput>
    /**
     * Filter which ProductTransactions to update
     */
    where?: ProductTransactionWhereInput
    /**
     * Limit how many ProductTransactions to update.
     */
    limit?: number
  }

  /**
   * ProductTransaction updateManyAndReturn
   */
  export type ProductTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransaction
     */
    select?: ProductTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransaction
     */
    omit?: ProductTransactionOmit<ExtArgs> | null
    /**
     * The data used to update ProductTransactions.
     */
    data: XOR<ProductTransactionUpdateManyMutationInput, ProductTransactionUncheckedUpdateManyInput>
    /**
     * Filter which ProductTransactions to update
     */
    where?: ProductTransactionWhereInput
    /**
     * Limit how many ProductTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductTransaction upsert
   */
  export type ProductTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransaction
     */
    select?: ProductTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransaction
     */
    omit?: ProductTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductTransaction to update in case it exists.
     */
    where: ProductTransactionWhereUniqueInput
    /**
     * In case the ProductTransaction found by the `where` argument doesn't exist, create a new ProductTransaction with this data.
     */
    create: XOR<ProductTransactionCreateInput, ProductTransactionUncheckedCreateInput>
    /**
     * In case the ProductTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductTransactionUpdateInput, ProductTransactionUncheckedUpdateInput>
  }

  /**
   * ProductTransaction delete
   */
  export type ProductTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransaction
     */
    select?: ProductTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransaction
     */
    omit?: ProductTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransactionInclude<ExtArgs> | null
    /**
     * Filter which ProductTransaction to delete.
     */
    where: ProductTransactionWhereUniqueInput
  }

  /**
   * ProductTransaction deleteMany
   */
  export type ProductTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductTransactions to delete
     */
    where?: ProductTransactionWhereInput
    /**
     * Limit how many ProductTransactions to delete.
     */
    limit?: number
  }

  /**
   * ProductTransaction without action
   */
  export type ProductTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransaction
     */
    select?: ProductTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransaction
     */
    omit?: ProductTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Quotation
   */

  export type AggregateQuotation = {
    _count: QuotationCountAggregateOutputType | null
    _avg: QuotationAvgAggregateOutputType | null
    _sum: QuotationSumAggregateOutputType | null
    _min: QuotationMinAggregateOutputType | null
    _max: QuotationMaxAggregateOutputType | null
  }

  export type QuotationAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type QuotationSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type QuotationMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type QuotationMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type QuotationCountAggregateOutputType = {
    id: number
    user_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type QuotationAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type QuotationSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type QuotationMinAggregateInputType = {
    id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
  }

  export type QuotationMaxAggregateInputType = {
    id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
  }

  export type QuotationCountAggregateInputType = {
    id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type QuotationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotation to aggregate.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quotations
    **/
    _count?: true | QuotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotationMaxAggregateInputType
  }

  export type GetQuotationAggregateType<T extends QuotationAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotation[P]>
      : GetScalarType<T[P], AggregateQuotation[P]>
  }




  export type QuotationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationWhereInput
    orderBy?: QuotationOrderByWithAggregationInput | QuotationOrderByWithAggregationInput[]
    by: QuotationScalarFieldEnum[] | QuotationScalarFieldEnum
    having?: QuotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotationCountAggregateInputType | true
    _avg?: QuotationAvgAggregateInputType
    _sum?: QuotationSumAggregateInputType
    _min?: QuotationMinAggregateInputType
    _max?: QuotationMaxAggregateInputType
  }

  export type QuotationGroupByOutputType = {
    id: number
    user_id: number
    created_at: Date
    updated_at: Date
    _count: QuotationCountAggregateOutputType | null
    _avg: QuotationAvgAggregateOutputType | null
    _sum: QuotationSumAggregateOutputType | null
    _min: QuotationMinAggregateOutputType | null
    _max: QuotationMaxAggregateOutputType | null
  }

  type GetQuotationGroupByPayload<T extends QuotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotationGroupByOutputType[P]>
            : GetScalarType<T[P], QuotationGroupByOutputType[P]>
        }
      >
    >


  export type QuotationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    ProductQuotation?: boolean | Quotation$ProductQuotationArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | QuotationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotation"]>

  export type QuotationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotation"]>

  export type QuotationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotation"]>

  export type QuotationSelectScalar = {
    id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type QuotationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "created_at" | "updated_at", ExtArgs["result"]["quotation"]>
  export type QuotationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductQuotation?: boolean | Quotation$ProductQuotationArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | QuotationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuotationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QuotationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QuotationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quotation"
    objects: {
      ProductQuotation: Prisma.$ProductQuotationPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["quotation"]>
    composites: {}
  }

  type QuotationGetPayload<S extends boolean | null | undefined | QuotationDefaultArgs> = $Result.GetResult<Prisma.$QuotationPayload, S>

  type QuotationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuotationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuotationCountAggregateInputType | true
    }

  export interface QuotationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quotation'], meta: { name: 'Quotation' } }
    /**
     * Find zero or one Quotation that matches the filter.
     * @param {QuotationFindUniqueArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuotationFindUniqueArgs>(args: SelectSubset<T, QuotationFindUniqueArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quotation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuotationFindUniqueOrThrowArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuotationFindUniqueOrThrowArgs>(args: SelectSubset<T, QuotationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationFindFirstArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuotationFindFirstArgs>(args?: SelectSubset<T, QuotationFindFirstArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationFindFirstOrThrowArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuotationFindFirstOrThrowArgs>(args?: SelectSubset<T, QuotationFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotations
     * const quotations = await prisma.quotation.findMany()
     * 
     * // Get first 10 Quotations
     * const quotations = await prisma.quotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotationWithIdOnly = await prisma.quotation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuotationFindManyArgs>(args?: SelectSubset<T, QuotationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quotation.
     * @param {QuotationCreateArgs} args - Arguments to create a Quotation.
     * @example
     * // Create one Quotation
     * const Quotation = await prisma.quotation.create({
     *   data: {
     *     // ... data to create a Quotation
     *   }
     * })
     * 
     */
    create<T extends QuotationCreateArgs>(args: SelectSubset<T, QuotationCreateArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quotations.
     * @param {QuotationCreateManyArgs} args - Arguments to create many Quotations.
     * @example
     * // Create many Quotations
     * const quotation = await prisma.quotation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuotationCreateManyArgs>(args?: SelectSubset<T, QuotationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quotations and returns the data saved in the database.
     * @param {QuotationCreateManyAndReturnArgs} args - Arguments to create many Quotations.
     * @example
     * // Create many Quotations
     * const quotation = await prisma.quotation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quotations and only return the `id`
     * const quotationWithIdOnly = await prisma.quotation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuotationCreateManyAndReturnArgs>(args?: SelectSubset<T, QuotationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quotation.
     * @param {QuotationDeleteArgs} args - Arguments to delete one Quotation.
     * @example
     * // Delete one Quotation
     * const Quotation = await prisma.quotation.delete({
     *   where: {
     *     // ... filter to delete one Quotation
     *   }
     * })
     * 
     */
    delete<T extends QuotationDeleteArgs>(args: SelectSubset<T, QuotationDeleteArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quotation.
     * @param {QuotationUpdateArgs} args - Arguments to update one Quotation.
     * @example
     * // Update one Quotation
     * const quotation = await prisma.quotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuotationUpdateArgs>(args: SelectSubset<T, QuotationUpdateArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quotations.
     * @param {QuotationDeleteManyArgs} args - Arguments to filter Quotations to delete.
     * @example
     * // Delete a few Quotations
     * const { count } = await prisma.quotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuotationDeleteManyArgs>(args?: SelectSubset<T, QuotationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotations
     * const quotation = await prisma.quotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuotationUpdateManyArgs>(args: SelectSubset<T, QuotationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotations and returns the data updated in the database.
     * @param {QuotationUpdateManyAndReturnArgs} args - Arguments to update many Quotations.
     * @example
     * // Update many Quotations
     * const quotation = await prisma.quotation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quotations and only return the `id`
     * const quotationWithIdOnly = await prisma.quotation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuotationUpdateManyAndReturnArgs>(args: SelectSubset<T, QuotationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quotation.
     * @param {QuotationUpsertArgs} args - Arguments to update or create a Quotation.
     * @example
     * // Update or create a Quotation
     * const quotation = await prisma.quotation.upsert({
     *   create: {
     *     // ... data to create a Quotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quotation we want to update
     *   }
     * })
     */
    upsert<T extends QuotationUpsertArgs>(args: SelectSubset<T, QuotationUpsertArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationCountArgs} args - Arguments to filter Quotations to count.
     * @example
     * // Count the number of Quotations
     * const count = await prisma.quotation.count({
     *   where: {
     *     // ... the filter for the Quotations we want to count
     *   }
     * })
    **/
    count<T extends QuotationCountArgs>(
      args?: Subset<T, QuotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotationAggregateArgs>(args: Subset<T, QuotationAggregateArgs>): Prisma.PrismaPromise<GetQuotationAggregateType<T>>

    /**
     * Group by Quotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotationGroupByArgs['orderBy'] }
        : { orderBy?: QuotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quotation model
   */
  readonly fields: QuotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ProductQuotation<T extends Quotation$ProductQuotationArgs<ExtArgs> = {}>(args?: Subset<T, Quotation$ProductQuotationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductQuotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quotation model
   */
  interface QuotationFieldRefs {
    readonly id: FieldRef<"Quotation", 'Int'>
    readonly user_id: FieldRef<"Quotation", 'Int'>
    readonly created_at: FieldRef<"Quotation", 'DateTime'>
    readonly updated_at: FieldRef<"Quotation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quotation findUnique
   */
  export type QuotationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation findUniqueOrThrow
   */
  export type QuotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation findFirst
   */
  export type QuotationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotations.
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotations.
     */
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Quotation findFirstOrThrow
   */
  export type QuotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotations.
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotations.
     */
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Quotation findMany
   */
  export type QuotationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotations to fetch.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quotations.
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Quotation create
   */
  export type QuotationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * The data needed to create a Quotation.
     */
    data: XOR<QuotationCreateInput, QuotationUncheckedCreateInput>
  }

  /**
   * Quotation createMany
   */
  export type QuotationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quotations.
     */
    data: QuotationCreateManyInput | QuotationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quotation createManyAndReturn
   */
  export type QuotationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * The data used to create many Quotations.
     */
    data: QuotationCreateManyInput | QuotationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quotation update
   */
  export type QuotationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * The data needed to update a Quotation.
     */
    data: XOR<QuotationUpdateInput, QuotationUncheckedUpdateInput>
    /**
     * Choose, which Quotation to update.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation updateMany
   */
  export type QuotationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quotations.
     */
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyInput>
    /**
     * Filter which Quotations to update
     */
    where?: QuotationWhereInput
    /**
     * Limit how many Quotations to update.
     */
    limit?: number
  }

  /**
   * Quotation updateManyAndReturn
   */
  export type QuotationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * The data used to update Quotations.
     */
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyInput>
    /**
     * Filter which Quotations to update
     */
    where?: QuotationWhereInput
    /**
     * Limit how many Quotations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quotation upsert
   */
  export type QuotationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * The filter to search for the Quotation to update in case it exists.
     */
    where: QuotationWhereUniqueInput
    /**
     * In case the Quotation found by the `where` argument doesn't exist, create a new Quotation with this data.
     */
    create: XOR<QuotationCreateInput, QuotationUncheckedCreateInput>
    /**
     * In case the Quotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotationUpdateInput, QuotationUncheckedUpdateInput>
  }

  /**
   * Quotation delete
   */
  export type QuotationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter which Quotation to delete.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation deleteMany
   */
  export type QuotationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotations to delete
     */
    where?: QuotationWhereInput
    /**
     * Limit how many Quotations to delete.
     */
    limit?: number
  }

  /**
   * Quotation.ProductQuotation
   */
  export type Quotation$ProductQuotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuotation
     */
    select?: ProductQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuotation
     */
    omit?: ProductQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQuotationInclude<ExtArgs> | null
    where?: ProductQuotationWhereInput
    orderBy?: ProductQuotationOrderByWithRelationInput | ProductQuotationOrderByWithRelationInput[]
    cursor?: ProductQuotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductQuotationScalarFieldEnum | ProductQuotationScalarFieldEnum[]
  }

  /**
   * Quotation without action
   */
  export type QuotationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
  }


  /**
   * Model SuperAdmin
   */

  export type AggregateSuperAdmin = {
    _count: SuperAdminCountAggregateOutputType | null
    _avg: SuperAdminAvgAggregateOutputType | null
    _sum: SuperAdminSumAggregateOutputType | null
    _min: SuperAdminMinAggregateOutputType | null
    _max: SuperAdminMaxAggregateOutputType | null
  }

  export type SuperAdminAvgAggregateOutputType = {
    id: number | null
  }

  export type SuperAdminSumAggregateOutputType = {
    id: number | null
  }

  export type SuperAdminMinAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
    phone: string | null
  }

  export type SuperAdminMaxAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
    phone: string | null
  }

  export type SuperAdminCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    email: number
    password: number
    phone: number
    _all: number
  }


  export type SuperAdminAvgAggregateInputType = {
    id?: true
  }

  export type SuperAdminSumAggregateInputType = {
    id?: true
  }

  export type SuperAdminMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
  }

  export type SuperAdminMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
  }

  export type SuperAdminCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone?: true
    _all?: true
  }

  export type SuperAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdmin to aggregate.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SuperAdmins
    **/
    _count?: true | SuperAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SuperAdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SuperAdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuperAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuperAdminMaxAggregateInputType
  }

  export type GetSuperAdminAggregateType<T extends SuperAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateSuperAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuperAdmin[P]>
      : GetScalarType<T[P], AggregateSuperAdmin[P]>
  }




  export type SuperAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuperAdminWhereInput
    orderBy?: SuperAdminOrderByWithAggregationInput | SuperAdminOrderByWithAggregationInput[]
    by: SuperAdminScalarFieldEnum[] | SuperAdminScalarFieldEnum
    having?: SuperAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuperAdminCountAggregateInputType | true
    _avg?: SuperAdminAvgAggregateInputType
    _sum?: SuperAdminSumAggregateInputType
    _min?: SuperAdminMinAggregateInputType
    _max?: SuperAdminMaxAggregateInputType
  }

  export type SuperAdminGroupByOutputType = {
    id: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone: string | null
    _count: SuperAdminCountAggregateOutputType | null
    _avg: SuperAdminAvgAggregateOutputType | null
    _sum: SuperAdminSumAggregateOutputType | null
    _min: SuperAdminMinAggregateOutputType | null
    _max: SuperAdminMaxAggregateOutputType | null
  }

  type GetSuperAdminGroupByPayload<T extends SuperAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuperAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuperAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuperAdminGroupByOutputType[P]>
            : GetScalarType<T[P], SuperAdminGroupByOutputType[P]>
        }
      >
    >


  export type SuperAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    Admin?: boolean | SuperAdmin$AdminArgs<ExtArgs>
    _count?: boolean | SuperAdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["superAdmin"]>

  export type SuperAdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
  }, ExtArgs["result"]["superAdmin"]>

  export type SuperAdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
  }, ExtArgs["result"]["superAdmin"]>

  export type SuperAdminSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
  }

  export type SuperAdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "first_name" | "last_name" | "email" | "password" | "phone", ExtArgs["result"]["superAdmin"]>
  export type SuperAdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Admin?: boolean | SuperAdmin$AdminArgs<ExtArgs>
    _count?: boolean | SuperAdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SuperAdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SuperAdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SuperAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SuperAdmin"
    objects: {
      Admin: Prisma.$AdminPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      first_name: string
      last_name: string
      email: string
      password: string
      phone: string | null
    }, ExtArgs["result"]["superAdmin"]>
    composites: {}
  }

  type SuperAdminGetPayload<S extends boolean | null | undefined | SuperAdminDefaultArgs> = $Result.GetResult<Prisma.$SuperAdminPayload, S>

  type SuperAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SuperAdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuperAdminCountAggregateInputType | true
    }

  export interface SuperAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SuperAdmin'], meta: { name: 'SuperAdmin' } }
    /**
     * Find zero or one SuperAdmin that matches the filter.
     * @param {SuperAdminFindUniqueArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuperAdminFindUniqueArgs>(args: SelectSubset<T, SuperAdminFindUniqueArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SuperAdmin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SuperAdminFindUniqueOrThrowArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuperAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, SuperAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminFindFirstArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuperAdminFindFirstArgs>(args?: SelectSubset<T, SuperAdminFindFirstArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminFindFirstOrThrowArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuperAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, SuperAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SuperAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuperAdmins
     * const superAdmins = await prisma.superAdmin.findMany()
     * 
     * // Get first 10 SuperAdmins
     * const superAdmins = await prisma.superAdmin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const superAdminWithIdOnly = await prisma.superAdmin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SuperAdminFindManyArgs>(args?: SelectSubset<T, SuperAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SuperAdmin.
     * @param {SuperAdminCreateArgs} args - Arguments to create a SuperAdmin.
     * @example
     * // Create one SuperAdmin
     * const SuperAdmin = await prisma.superAdmin.create({
     *   data: {
     *     // ... data to create a SuperAdmin
     *   }
     * })
     * 
     */
    create<T extends SuperAdminCreateArgs>(args: SelectSubset<T, SuperAdminCreateArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SuperAdmins.
     * @param {SuperAdminCreateManyArgs} args - Arguments to create many SuperAdmins.
     * @example
     * // Create many SuperAdmins
     * const superAdmin = await prisma.superAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuperAdminCreateManyArgs>(args?: SelectSubset<T, SuperAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SuperAdmins and returns the data saved in the database.
     * @param {SuperAdminCreateManyAndReturnArgs} args - Arguments to create many SuperAdmins.
     * @example
     * // Create many SuperAdmins
     * const superAdmin = await prisma.superAdmin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SuperAdmins and only return the `id`
     * const superAdminWithIdOnly = await prisma.superAdmin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SuperAdminCreateManyAndReturnArgs>(args?: SelectSubset<T, SuperAdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SuperAdmin.
     * @param {SuperAdminDeleteArgs} args - Arguments to delete one SuperAdmin.
     * @example
     * // Delete one SuperAdmin
     * const SuperAdmin = await prisma.superAdmin.delete({
     *   where: {
     *     // ... filter to delete one SuperAdmin
     *   }
     * })
     * 
     */
    delete<T extends SuperAdminDeleteArgs>(args: SelectSubset<T, SuperAdminDeleteArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SuperAdmin.
     * @param {SuperAdminUpdateArgs} args - Arguments to update one SuperAdmin.
     * @example
     * // Update one SuperAdmin
     * const superAdmin = await prisma.superAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuperAdminUpdateArgs>(args: SelectSubset<T, SuperAdminUpdateArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SuperAdmins.
     * @param {SuperAdminDeleteManyArgs} args - Arguments to filter SuperAdmins to delete.
     * @example
     * // Delete a few SuperAdmins
     * const { count } = await prisma.superAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuperAdminDeleteManyArgs>(args?: SelectSubset<T, SuperAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuperAdmins
     * const superAdmin = await prisma.superAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuperAdminUpdateManyArgs>(args: SelectSubset<T, SuperAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdmins and returns the data updated in the database.
     * @param {SuperAdminUpdateManyAndReturnArgs} args - Arguments to update many SuperAdmins.
     * @example
     * // Update many SuperAdmins
     * const superAdmin = await prisma.superAdmin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SuperAdmins and only return the `id`
     * const superAdminWithIdOnly = await prisma.superAdmin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SuperAdminUpdateManyAndReturnArgs>(args: SelectSubset<T, SuperAdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SuperAdmin.
     * @param {SuperAdminUpsertArgs} args - Arguments to update or create a SuperAdmin.
     * @example
     * // Update or create a SuperAdmin
     * const superAdmin = await prisma.superAdmin.upsert({
     *   create: {
     *     // ... data to create a SuperAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuperAdmin we want to update
     *   }
     * })
     */
    upsert<T extends SuperAdminUpsertArgs>(args: SelectSubset<T, SuperAdminUpsertArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SuperAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminCountArgs} args - Arguments to filter SuperAdmins to count.
     * @example
     * // Count the number of SuperAdmins
     * const count = await prisma.superAdmin.count({
     *   where: {
     *     // ... the filter for the SuperAdmins we want to count
     *   }
     * })
    **/
    count<T extends SuperAdminCountArgs>(
      args?: Subset<T, SuperAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuperAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuperAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuperAdminAggregateArgs>(args: Subset<T, SuperAdminAggregateArgs>): Prisma.PrismaPromise<GetSuperAdminAggregateType<T>>

    /**
     * Group by SuperAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuperAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuperAdminGroupByArgs['orderBy'] }
        : { orderBy?: SuperAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuperAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuperAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SuperAdmin model
   */
  readonly fields: SuperAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SuperAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuperAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Admin<T extends SuperAdmin$AdminArgs<ExtArgs> = {}>(args?: Subset<T, SuperAdmin$AdminArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SuperAdmin model
   */
  interface SuperAdminFieldRefs {
    readonly id: FieldRef<"SuperAdmin", 'Int'>
    readonly first_name: FieldRef<"SuperAdmin", 'String'>
    readonly last_name: FieldRef<"SuperAdmin", 'String'>
    readonly email: FieldRef<"SuperAdmin", 'String'>
    readonly password: FieldRef<"SuperAdmin", 'String'>
    readonly phone: FieldRef<"SuperAdmin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SuperAdmin findUnique
   */
  export type SuperAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin findUniqueOrThrow
   */
  export type SuperAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin findFirst
   */
  export type SuperAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdmins.
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdmins.
     */
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin findFirstOrThrow
   */
  export type SuperAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdmins.
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdmins.
     */
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin findMany
   */
  export type SuperAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmins to fetch.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SuperAdmins.
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin create
   */
  export type SuperAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * The data needed to create a SuperAdmin.
     */
    data: XOR<SuperAdminCreateInput, SuperAdminUncheckedCreateInput>
  }

  /**
   * SuperAdmin createMany
   */
  export type SuperAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SuperAdmins.
     */
    data: SuperAdminCreateManyInput | SuperAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SuperAdmin createManyAndReturn
   */
  export type SuperAdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * The data used to create many SuperAdmins.
     */
    data: SuperAdminCreateManyInput | SuperAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SuperAdmin update
   */
  export type SuperAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * The data needed to update a SuperAdmin.
     */
    data: XOR<SuperAdminUpdateInput, SuperAdminUncheckedUpdateInput>
    /**
     * Choose, which SuperAdmin to update.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin updateMany
   */
  export type SuperAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SuperAdmins.
     */
    data: XOR<SuperAdminUpdateManyMutationInput, SuperAdminUncheckedUpdateManyInput>
    /**
     * Filter which SuperAdmins to update
     */
    where?: SuperAdminWhereInput
    /**
     * Limit how many SuperAdmins to update.
     */
    limit?: number
  }

  /**
   * SuperAdmin updateManyAndReturn
   */
  export type SuperAdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * The data used to update SuperAdmins.
     */
    data: XOR<SuperAdminUpdateManyMutationInput, SuperAdminUncheckedUpdateManyInput>
    /**
     * Filter which SuperAdmins to update
     */
    where?: SuperAdminWhereInput
    /**
     * Limit how many SuperAdmins to update.
     */
    limit?: number
  }

  /**
   * SuperAdmin upsert
   */
  export type SuperAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * The filter to search for the SuperAdmin to update in case it exists.
     */
    where: SuperAdminWhereUniqueInput
    /**
     * In case the SuperAdmin found by the `where` argument doesn't exist, create a new SuperAdmin with this data.
     */
    create: XOR<SuperAdminCreateInput, SuperAdminUncheckedCreateInput>
    /**
     * In case the SuperAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuperAdminUpdateInput, SuperAdminUncheckedUpdateInput>
  }

  /**
   * SuperAdmin delete
   */
  export type SuperAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter which SuperAdmin to delete.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin deleteMany
   */
  export type SuperAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdmins to delete
     */
    where?: SuperAdminWhereInput
    /**
     * Limit how many SuperAdmins to delete.
     */
    limit?: number
  }

  /**
   * SuperAdmin.Admin
   */
  export type SuperAdmin$AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin without action
   */
  export type SuperAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    commercial_id: number | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    commercial_id: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    commercial_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    commercial_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    user_id: number
    commercial_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    user_id?: true
    commercial_id?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    user_id?: true
    commercial_id?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    user_id?: true
    commercial_id?: true
    created_at?: true
    updated_at?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    user_id?: true
    commercial_id?: true
    created_at?: true
    updated_at?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    user_id?: true
    commercial_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    user_id: number
    commercial_id: number
    created_at: Date
    updated_at: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    commercial_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    ProductTransaction?: boolean | Transaction$ProductTransactionArgs<ExtArgs>
    Commercial?: boolean | CommercialDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    commercial_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    Commercial?: boolean | CommercialDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    commercial_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    Commercial?: boolean | CommercialDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    user_id?: boolean
    commercial_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "commercial_id" | "created_at" | "updated_at", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductTransaction?: boolean | Transaction$ProductTransactionArgs<ExtArgs>
    Commercial?: boolean | CommercialDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Commercial?: boolean | CommercialDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Commercial?: boolean | CommercialDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      ProductTransaction: Prisma.$ProductTransactionPayload<ExtArgs>[]
      Commercial: Prisma.$CommercialPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      commercial_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ProductTransaction<T extends Transaction$ProductTransactionArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$ProductTransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Commercial<T extends CommercialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommercialDefaultArgs<ExtArgs>>): Prisma__CommercialClient<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'Int'>
    readonly user_id: FieldRef<"Transaction", 'Int'>
    readonly commercial_id: FieldRef<"Transaction", 'Int'>
    readonly created_at: FieldRef<"Transaction", 'DateTime'>
    readonly updated_at: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.ProductTransaction
   */
  export type Transaction$ProductTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTransaction
     */
    select?: ProductTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTransaction
     */
    omit?: ProductTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTransactionInclude<ExtArgs> | null
    where?: ProductTransactionWhereInput
    orderBy?: ProductTransactionOrderByWithRelationInput | ProductTransactionOrderByWithRelationInput[]
    cursor?: ProductTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTransactionScalarFieldEnum | ProductTransactionScalarFieldEnum[]
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    first_name: string | null
    last_name: string | null
    password: string | null
    phone: string | null
    created_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    first_name: string | null
    last_name: string | null
    password: string | null
    phone: string | null
    created_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    first_name: number
    last_name: number
    password: number
    phone: number
    created_at: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    first_name?: true
    last_name?: true
    password?: true
    phone?: true
    created_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    first_name?: true
    last_name?: true
    password?: true
    phone?: true
    created_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    first_name?: true
    last_name?: true
    password?: true
    phone?: true
    created_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    first_name: string
    last_name: string
    password: string
    phone: string | null
    created_at: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    first_name?: boolean
    last_name?: boolean
    password?: boolean
    phone?: boolean
    created_at?: boolean
    Dispositive?: boolean | User$DispositiveArgs<ExtArgs>
    Quotation?: boolean | User$QuotationArgs<ExtArgs>
    Transaction?: boolean | User$TransactionArgs<ExtArgs>
    Helper?: boolean | User$HelperArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    first_name?: boolean
    last_name?: boolean
    password?: boolean
    phone?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    first_name?: boolean
    last_name?: boolean
    password?: boolean
    phone?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    first_name?: boolean
    last_name?: boolean
    password?: boolean
    phone?: boolean
    created_at?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "first_name" | "last_name" | "password" | "phone" | "created_at", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Dispositive?: boolean | User$DispositiveArgs<ExtArgs>
    Quotation?: boolean | User$QuotationArgs<ExtArgs>
    Transaction?: boolean | User$TransactionArgs<ExtArgs>
    Helper?: boolean | User$HelperArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      Dispositive: Prisma.$DispositivePayload<ExtArgs>[]
      Quotation: Prisma.$QuotationPayload<ExtArgs>[]
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
      Helper: Prisma.$HelperPayload<ExtArgs>[]
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      first_name: string
      last_name: string
      password: string
      phone: string | null
      created_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Dispositive<T extends User$DispositiveArgs<ExtArgs> = {}>(args?: Subset<T, User$DispositiveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispositivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Quotation<T extends User$QuotationArgs<ExtArgs> = {}>(args?: Subset<T, User$QuotationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transaction<T extends User$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, User$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Helper<T extends User$HelperArgs<ExtArgs> = {}>(args?: Subset<T, User$HelperArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Notification<T extends User$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly first_name: FieldRef<"User", 'String'>
    readonly last_name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.Dispositive
   */
  export type User$DispositiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositive
     */
    select?: DispositiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispositive
     */
    omit?: DispositiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispositiveInclude<ExtArgs> | null
    where?: DispositiveWhereInput
    orderBy?: DispositiveOrderByWithRelationInput | DispositiveOrderByWithRelationInput[]
    cursor?: DispositiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DispositiveScalarFieldEnum | DispositiveScalarFieldEnum[]
  }

  /**
   * User.Quotation
   */
  export type User$QuotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    where?: QuotationWhereInput
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    cursor?: QuotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * User.Transaction
   */
  export type User$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.Helper
   */
  export type User$HelperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    where?: HelperWhereInput
    orderBy?: HelperOrderByWithRelationInput | HelperOrderByWithRelationInput[]
    cursor?: HelperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelperScalarFieldEnum | HelperScalarFieldEnum[]
  }

  /**
   * User.Notification
   */
  export type User$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model InterventionReport
   */

  export type AggregateInterventionReport = {
    _count: InterventionReportCountAggregateOutputType | null
    _avg: InterventionReportAvgAggregateOutputType | null
    _sum: InterventionReportSumAggregateOutputType | null
    _min: InterventionReportMinAggregateOutputType | null
    _max: InterventionReportMaxAggregateOutputType | null
  }

  export type InterventionReportAvgAggregateOutputType = {
    id: number | null
    interventionId: number | null
  }

  export type InterventionReportSumAggregateOutputType = {
    id: number | null
    interventionId: number | null
  }

  export type InterventionReportMinAggregateOutputType = {
    id: number | null
    interventionId: number | null
    title: string | null
    description: string | null
    created_at: Date | null
  }

  export type InterventionReportMaxAggregateOutputType = {
    id: number | null
    interventionId: number | null
    title: string | null
    description: string | null
    created_at: Date | null
  }

  export type InterventionReportCountAggregateOutputType = {
    id: number
    interventionId: number
    title: number
    description: number
    created_at: number
    _all: number
  }


  export type InterventionReportAvgAggregateInputType = {
    id?: true
    interventionId?: true
  }

  export type InterventionReportSumAggregateInputType = {
    id?: true
    interventionId?: true
  }

  export type InterventionReportMinAggregateInputType = {
    id?: true
    interventionId?: true
    title?: true
    description?: true
    created_at?: true
  }

  export type InterventionReportMaxAggregateInputType = {
    id?: true
    interventionId?: true
    title?: true
    description?: true
    created_at?: true
  }

  export type InterventionReportCountAggregateInputType = {
    id?: true
    interventionId?: true
    title?: true
    description?: true
    created_at?: true
    _all?: true
  }

  export type InterventionReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterventionReport to aggregate.
     */
    where?: InterventionReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterventionReports to fetch.
     */
    orderBy?: InterventionReportOrderByWithRelationInput | InterventionReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterventionReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterventionReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterventionReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterventionReports
    **/
    _count?: true | InterventionReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterventionReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterventionReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterventionReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterventionReportMaxAggregateInputType
  }

  export type GetInterventionReportAggregateType<T extends InterventionReportAggregateArgs> = {
        [P in keyof T & keyof AggregateInterventionReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterventionReport[P]>
      : GetScalarType<T[P], AggregateInterventionReport[P]>
  }




  export type InterventionReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionReportWhereInput
    orderBy?: InterventionReportOrderByWithAggregationInput | InterventionReportOrderByWithAggregationInput[]
    by: InterventionReportScalarFieldEnum[] | InterventionReportScalarFieldEnum
    having?: InterventionReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterventionReportCountAggregateInputType | true
    _avg?: InterventionReportAvgAggregateInputType
    _sum?: InterventionReportSumAggregateInputType
    _min?: InterventionReportMinAggregateInputType
    _max?: InterventionReportMaxAggregateInputType
  }

  export type InterventionReportGroupByOutputType = {
    id: number
    interventionId: number
    title: string
    description: string
    created_at: Date
    _count: InterventionReportCountAggregateOutputType | null
    _avg: InterventionReportAvgAggregateOutputType | null
    _sum: InterventionReportSumAggregateOutputType | null
    _min: InterventionReportMinAggregateOutputType | null
    _max: InterventionReportMaxAggregateOutputType | null
  }

  type GetInterventionReportGroupByPayload<T extends InterventionReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterventionReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterventionReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterventionReportGroupByOutputType[P]>
            : GetScalarType<T[P], InterventionReportGroupByOutputType[P]>
        }
      >
    >


  export type InterventionReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interventionId?: boolean
    title?: boolean
    description?: boolean
    created_at?: boolean
    Intervention?: boolean | InterventionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interventionReport"]>

  export type InterventionReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interventionId?: boolean
    title?: boolean
    description?: boolean
    created_at?: boolean
    Intervention?: boolean | InterventionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interventionReport"]>

  export type InterventionReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interventionId?: boolean
    title?: boolean
    description?: boolean
    created_at?: boolean
    Intervention?: boolean | InterventionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interventionReport"]>

  export type InterventionReportSelectScalar = {
    id?: boolean
    interventionId?: boolean
    title?: boolean
    description?: boolean
    created_at?: boolean
  }

  export type InterventionReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "interventionId" | "title" | "description" | "created_at", ExtArgs["result"]["interventionReport"]>
  export type InterventionReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Intervention?: boolean | InterventionDefaultArgs<ExtArgs>
  }
  export type InterventionReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Intervention?: boolean | InterventionDefaultArgs<ExtArgs>
  }
  export type InterventionReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Intervention?: boolean | InterventionDefaultArgs<ExtArgs>
  }

  export type $InterventionReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterventionReport"
    objects: {
      Intervention: Prisma.$InterventionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      interventionId: number
      title: string
      description: string
      created_at: Date
    }, ExtArgs["result"]["interventionReport"]>
    composites: {}
  }

  type InterventionReportGetPayload<S extends boolean | null | undefined | InterventionReportDefaultArgs> = $Result.GetResult<Prisma.$InterventionReportPayload, S>

  type InterventionReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterventionReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterventionReportCountAggregateInputType | true
    }

  export interface InterventionReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterventionReport'], meta: { name: 'InterventionReport' } }
    /**
     * Find zero or one InterventionReport that matches the filter.
     * @param {InterventionReportFindUniqueArgs} args - Arguments to find a InterventionReport
     * @example
     * // Get one InterventionReport
     * const interventionReport = await prisma.interventionReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterventionReportFindUniqueArgs>(args: SelectSubset<T, InterventionReportFindUniqueArgs<ExtArgs>>): Prisma__InterventionReportClient<$Result.GetResult<Prisma.$InterventionReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InterventionReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterventionReportFindUniqueOrThrowArgs} args - Arguments to find a InterventionReport
     * @example
     * // Get one InterventionReport
     * const interventionReport = await prisma.interventionReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterventionReportFindUniqueOrThrowArgs>(args: SelectSubset<T, InterventionReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterventionReportClient<$Result.GetResult<Prisma.$InterventionReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterventionReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionReportFindFirstArgs} args - Arguments to find a InterventionReport
     * @example
     * // Get one InterventionReport
     * const interventionReport = await prisma.interventionReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterventionReportFindFirstArgs>(args?: SelectSubset<T, InterventionReportFindFirstArgs<ExtArgs>>): Prisma__InterventionReportClient<$Result.GetResult<Prisma.$InterventionReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterventionReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionReportFindFirstOrThrowArgs} args - Arguments to find a InterventionReport
     * @example
     * // Get one InterventionReport
     * const interventionReport = await prisma.interventionReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterventionReportFindFirstOrThrowArgs>(args?: SelectSubset<T, InterventionReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterventionReportClient<$Result.GetResult<Prisma.$InterventionReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InterventionReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterventionReports
     * const interventionReports = await prisma.interventionReport.findMany()
     * 
     * // Get first 10 InterventionReports
     * const interventionReports = await prisma.interventionReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interventionReportWithIdOnly = await prisma.interventionReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterventionReportFindManyArgs>(args?: SelectSubset<T, InterventionReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InterventionReport.
     * @param {InterventionReportCreateArgs} args - Arguments to create a InterventionReport.
     * @example
     * // Create one InterventionReport
     * const InterventionReport = await prisma.interventionReport.create({
     *   data: {
     *     // ... data to create a InterventionReport
     *   }
     * })
     * 
     */
    create<T extends InterventionReportCreateArgs>(args: SelectSubset<T, InterventionReportCreateArgs<ExtArgs>>): Prisma__InterventionReportClient<$Result.GetResult<Prisma.$InterventionReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InterventionReports.
     * @param {InterventionReportCreateManyArgs} args - Arguments to create many InterventionReports.
     * @example
     * // Create many InterventionReports
     * const interventionReport = await prisma.interventionReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterventionReportCreateManyArgs>(args?: SelectSubset<T, InterventionReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InterventionReports and returns the data saved in the database.
     * @param {InterventionReportCreateManyAndReturnArgs} args - Arguments to create many InterventionReports.
     * @example
     * // Create many InterventionReports
     * const interventionReport = await prisma.interventionReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InterventionReports and only return the `id`
     * const interventionReportWithIdOnly = await prisma.interventionReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterventionReportCreateManyAndReturnArgs>(args?: SelectSubset<T, InterventionReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InterventionReport.
     * @param {InterventionReportDeleteArgs} args - Arguments to delete one InterventionReport.
     * @example
     * // Delete one InterventionReport
     * const InterventionReport = await prisma.interventionReport.delete({
     *   where: {
     *     // ... filter to delete one InterventionReport
     *   }
     * })
     * 
     */
    delete<T extends InterventionReportDeleteArgs>(args: SelectSubset<T, InterventionReportDeleteArgs<ExtArgs>>): Prisma__InterventionReportClient<$Result.GetResult<Prisma.$InterventionReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InterventionReport.
     * @param {InterventionReportUpdateArgs} args - Arguments to update one InterventionReport.
     * @example
     * // Update one InterventionReport
     * const interventionReport = await prisma.interventionReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterventionReportUpdateArgs>(args: SelectSubset<T, InterventionReportUpdateArgs<ExtArgs>>): Prisma__InterventionReportClient<$Result.GetResult<Prisma.$InterventionReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InterventionReports.
     * @param {InterventionReportDeleteManyArgs} args - Arguments to filter InterventionReports to delete.
     * @example
     * // Delete a few InterventionReports
     * const { count } = await prisma.interventionReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterventionReportDeleteManyArgs>(args?: SelectSubset<T, InterventionReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterventionReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterventionReports
     * const interventionReport = await prisma.interventionReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterventionReportUpdateManyArgs>(args: SelectSubset<T, InterventionReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterventionReports and returns the data updated in the database.
     * @param {InterventionReportUpdateManyAndReturnArgs} args - Arguments to update many InterventionReports.
     * @example
     * // Update many InterventionReports
     * const interventionReport = await prisma.interventionReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InterventionReports and only return the `id`
     * const interventionReportWithIdOnly = await prisma.interventionReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterventionReportUpdateManyAndReturnArgs>(args: SelectSubset<T, InterventionReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InterventionReport.
     * @param {InterventionReportUpsertArgs} args - Arguments to update or create a InterventionReport.
     * @example
     * // Update or create a InterventionReport
     * const interventionReport = await prisma.interventionReport.upsert({
     *   create: {
     *     // ... data to create a InterventionReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterventionReport we want to update
     *   }
     * })
     */
    upsert<T extends InterventionReportUpsertArgs>(args: SelectSubset<T, InterventionReportUpsertArgs<ExtArgs>>): Prisma__InterventionReportClient<$Result.GetResult<Prisma.$InterventionReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InterventionReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionReportCountArgs} args - Arguments to filter InterventionReports to count.
     * @example
     * // Count the number of InterventionReports
     * const count = await prisma.interventionReport.count({
     *   where: {
     *     // ... the filter for the InterventionReports we want to count
     *   }
     * })
    **/
    count<T extends InterventionReportCountArgs>(
      args?: Subset<T, InterventionReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterventionReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterventionReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterventionReportAggregateArgs>(args: Subset<T, InterventionReportAggregateArgs>): Prisma.PrismaPromise<GetInterventionReportAggregateType<T>>

    /**
     * Group by InterventionReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterventionReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterventionReportGroupByArgs['orderBy'] }
        : { orderBy?: InterventionReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterventionReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterventionReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterventionReport model
   */
  readonly fields: InterventionReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterventionReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterventionReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Intervention<T extends InterventionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterventionDefaultArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterventionReport model
   */
  interface InterventionReportFieldRefs {
    readonly id: FieldRef<"InterventionReport", 'Int'>
    readonly interventionId: FieldRef<"InterventionReport", 'Int'>
    readonly title: FieldRef<"InterventionReport", 'String'>
    readonly description: FieldRef<"InterventionReport", 'String'>
    readonly created_at: FieldRef<"InterventionReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InterventionReport findUnique
   */
  export type InterventionReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionReport
     */
    select?: InterventionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionReport
     */
    omit?: InterventionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionReportInclude<ExtArgs> | null
    /**
     * Filter, which InterventionReport to fetch.
     */
    where: InterventionReportWhereUniqueInput
  }

  /**
   * InterventionReport findUniqueOrThrow
   */
  export type InterventionReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionReport
     */
    select?: InterventionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionReport
     */
    omit?: InterventionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionReportInclude<ExtArgs> | null
    /**
     * Filter, which InterventionReport to fetch.
     */
    where: InterventionReportWhereUniqueInput
  }

  /**
   * InterventionReport findFirst
   */
  export type InterventionReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionReport
     */
    select?: InterventionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionReport
     */
    omit?: InterventionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionReportInclude<ExtArgs> | null
    /**
     * Filter, which InterventionReport to fetch.
     */
    where?: InterventionReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterventionReports to fetch.
     */
    orderBy?: InterventionReportOrderByWithRelationInput | InterventionReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterventionReports.
     */
    cursor?: InterventionReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterventionReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterventionReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterventionReports.
     */
    distinct?: InterventionReportScalarFieldEnum | InterventionReportScalarFieldEnum[]
  }

  /**
   * InterventionReport findFirstOrThrow
   */
  export type InterventionReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionReport
     */
    select?: InterventionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionReport
     */
    omit?: InterventionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionReportInclude<ExtArgs> | null
    /**
     * Filter, which InterventionReport to fetch.
     */
    where?: InterventionReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterventionReports to fetch.
     */
    orderBy?: InterventionReportOrderByWithRelationInput | InterventionReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterventionReports.
     */
    cursor?: InterventionReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterventionReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterventionReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterventionReports.
     */
    distinct?: InterventionReportScalarFieldEnum | InterventionReportScalarFieldEnum[]
  }

  /**
   * InterventionReport findMany
   */
  export type InterventionReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionReport
     */
    select?: InterventionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionReport
     */
    omit?: InterventionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionReportInclude<ExtArgs> | null
    /**
     * Filter, which InterventionReports to fetch.
     */
    where?: InterventionReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterventionReports to fetch.
     */
    orderBy?: InterventionReportOrderByWithRelationInput | InterventionReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterventionReports.
     */
    cursor?: InterventionReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterventionReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterventionReports.
     */
    skip?: number
    distinct?: InterventionReportScalarFieldEnum | InterventionReportScalarFieldEnum[]
  }

  /**
   * InterventionReport create
   */
  export type InterventionReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionReport
     */
    select?: InterventionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionReport
     */
    omit?: InterventionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionReportInclude<ExtArgs> | null
    /**
     * The data needed to create a InterventionReport.
     */
    data: XOR<InterventionReportCreateInput, InterventionReportUncheckedCreateInput>
  }

  /**
   * InterventionReport createMany
   */
  export type InterventionReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterventionReports.
     */
    data: InterventionReportCreateManyInput | InterventionReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterventionReport createManyAndReturn
   */
  export type InterventionReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionReport
     */
    select?: InterventionReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionReport
     */
    omit?: InterventionReportOmit<ExtArgs> | null
    /**
     * The data used to create many InterventionReports.
     */
    data: InterventionReportCreateManyInput | InterventionReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterventionReport update
   */
  export type InterventionReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionReport
     */
    select?: InterventionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionReport
     */
    omit?: InterventionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionReportInclude<ExtArgs> | null
    /**
     * The data needed to update a InterventionReport.
     */
    data: XOR<InterventionReportUpdateInput, InterventionReportUncheckedUpdateInput>
    /**
     * Choose, which InterventionReport to update.
     */
    where: InterventionReportWhereUniqueInput
  }

  /**
   * InterventionReport updateMany
   */
  export type InterventionReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterventionReports.
     */
    data: XOR<InterventionReportUpdateManyMutationInput, InterventionReportUncheckedUpdateManyInput>
    /**
     * Filter which InterventionReports to update
     */
    where?: InterventionReportWhereInput
    /**
     * Limit how many InterventionReports to update.
     */
    limit?: number
  }

  /**
   * InterventionReport updateManyAndReturn
   */
  export type InterventionReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionReport
     */
    select?: InterventionReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionReport
     */
    omit?: InterventionReportOmit<ExtArgs> | null
    /**
     * The data used to update InterventionReports.
     */
    data: XOR<InterventionReportUpdateManyMutationInput, InterventionReportUncheckedUpdateManyInput>
    /**
     * Filter which InterventionReports to update
     */
    where?: InterventionReportWhereInput
    /**
     * Limit how many InterventionReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterventionReport upsert
   */
  export type InterventionReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionReport
     */
    select?: InterventionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionReport
     */
    omit?: InterventionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionReportInclude<ExtArgs> | null
    /**
     * The filter to search for the InterventionReport to update in case it exists.
     */
    where: InterventionReportWhereUniqueInput
    /**
     * In case the InterventionReport found by the `where` argument doesn't exist, create a new InterventionReport with this data.
     */
    create: XOR<InterventionReportCreateInput, InterventionReportUncheckedCreateInput>
    /**
     * In case the InterventionReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterventionReportUpdateInput, InterventionReportUncheckedUpdateInput>
  }

  /**
   * InterventionReport delete
   */
  export type InterventionReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionReport
     */
    select?: InterventionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionReport
     */
    omit?: InterventionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionReportInclude<ExtArgs> | null
    /**
     * Filter which InterventionReport to delete.
     */
    where: InterventionReportWhereUniqueInput
  }

  /**
   * InterventionReport deleteMany
   */
  export type InterventionReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterventionReports to delete
     */
    where?: InterventionReportWhereInput
    /**
     * Limit how many InterventionReports to delete.
     */
    limit?: number
  }

  /**
   * InterventionReport without action
   */
  export type InterventionReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionReport
     */
    select?: InterventionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionReport
     */
    omit?: InterventionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionReportInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    type: string | null
    channel: string | null
    title: string | null
    message: string | null
    is_read: boolean | null
    status: string | null
    created_at: Date | null
    sent_at: Date | null
    read_at: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    type: string | null
    channel: string | null
    title: string | null
    message: string | null
    is_read: boolean | null
    status: string | null
    created_at: Date | null
    sent_at: Date | null
    read_at: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    user_id: number
    type: number
    channel: number
    title: number
    message: number
    metadata: number
    is_read: number
    status: number
    created_at: number
    sent_at: number
    read_at: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    channel?: true
    title?: true
    message?: true
    is_read?: true
    status?: true
    created_at?: true
    sent_at?: true
    read_at?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    channel?: true
    title?: true
    message?: true
    is_read?: true
    status?: true
    created_at?: true
    sent_at?: true
    read_at?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    channel?: true
    title?: true
    message?: true
    metadata?: true
    is_read?: true
    status?: true
    created_at?: true
    sent_at?: true
    read_at?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    user_id: number
    type: string | null
    channel: string | null
    title: string
    message: string
    metadata: JsonValue | null
    is_read: boolean
    status: string
    created_at: Date
    sent_at: Date | null
    read_at: Date | null
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    channel?: boolean
    title?: boolean
    message?: boolean
    metadata?: boolean
    is_read?: boolean
    status?: boolean
    created_at?: boolean
    sent_at?: boolean
    read_at?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    channel?: boolean
    title?: boolean
    message?: boolean
    metadata?: boolean
    is_read?: boolean
    status?: boolean
    created_at?: boolean
    sent_at?: boolean
    read_at?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    channel?: boolean
    title?: boolean
    message?: boolean
    metadata?: boolean
    is_read?: boolean
    status?: boolean
    created_at?: boolean
    sent_at?: boolean
    read_at?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    user_id?: boolean
    type?: boolean
    channel?: boolean
    title?: boolean
    message?: boolean
    metadata?: boolean
    is_read?: boolean
    status?: boolean
    created_at?: boolean
    sent_at?: boolean
    read_at?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "type" | "channel" | "title" | "message" | "metadata" | "is_read" | "status" | "created_at" | "sent_at" | "read_at", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      type: string | null
      channel: string | null
      title: string
      message: string
      metadata: Prisma.JsonValue | null
      is_read: boolean
      status: string
      created_at: Date
      sent_at: Date | null
      read_at: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly user_id: FieldRef<"Notification", 'Int'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly channel: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly is_read: FieldRef<"Notification", 'Boolean'>
    readonly status: FieldRef<"Notification", 'String'>
    readonly created_at: FieldRef<"Notification", 'DateTime'>
    readonly sent_at: FieldRef<"Notification", 'DateTime'>
    readonly read_at: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    password: 'password',
    phone: 'phone',
    add_by: 'add_by',
    privilege: 'privilege'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const CommercialScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    password: 'password',
    phone: 'phone'
  };

  export type CommercialScalarFieldEnum = (typeof CommercialScalarFieldEnum)[keyof typeof CommercialScalarFieldEnum]


  export const DeciderScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    password: 'password',
    phone: 'phone'
  };

  export type DeciderScalarFieldEnum = (typeof DeciderScalarFieldEnum)[keyof typeof DeciderScalarFieldEnum]


  export const DispoIssueScalarFieldEnum: {
    id: 'id',
    dispositiveId: 'dispositiveId',
    description: 'description',
    date: 'date',
    status: 'status',
    maintainerId: 'maintainerId'
  };

  export type DispoIssueScalarFieldEnum = (typeof DispoIssueScalarFieldEnum)[keyof typeof DispoIssueScalarFieldEnum]


  export const DispositiveScalarFieldEnum: {
    id: 'id',
    type: 'type',
    start_date: 'start_date',
    end_date: 'end_date',
    initial_state: 'initial_state',
    MAC: 'MAC',
    state: 'state',
    user_id: 'user_id',
    product_id: 'product_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DispositiveScalarFieldEnum = (typeof DispositiveScalarFieldEnum)[keyof typeof DispositiveScalarFieldEnum]


  export const HelperScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    password: 'password',
    phone: 'phone'
  };

  export type HelperScalarFieldEnum = (typeof HelperScalarFieldEnum)[keyof typeof HelperScalarFieldEnum]


  export const InterventionScalarFieldEnum: {
    idMaintainer: 'idMaintainer',
    description: 'description',
    type: 'type',
    end_date: 'end_date',
    start_date: 'start_date',
    id: 'id',
    status: 'status',
    idDispositive: 'idDispositive'
  };

  export type InterventionScalarFieldEnum = (typeof InterventionScalarFieldEnum)[keyof typeof InterventionScalarFieldEnum]


  export const MaintainerScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    password: 'password',
    phone: 'phone'
  };

  export type MaintainerScalarFieldEnum = (typeof MaintainerScalarFieldEnum)[keyof typeof MaintainerScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductQuotationScalarFieldEnum: {
    quotation_id: 'quotation_id',
    product_id: 'product_id',
    count: 'count',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProductQuotationScalarFieldEnum = (typeof ProductQuotationScalarFieldEnum)[keyof typeof ProductQuotationScalarFieldEnum]


  export const ProductTransactionScalarFieldEnum: {
    transaction_id: 'transaction_id',
    dispositive_id: 'dispositive_id',
    isConfirmed: 'isConfirmed',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProductTransactionScalarFieldEnum = (typeof ProductTransactionScalarFieldEnum)[keyof typeof ProductTransactionScalarFieldEnum]


  export const QuotationScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type QuotationScalarFieldEnum = (typeof QuotationScalarFieldEnum)[keyof typeof QuotationScalarFieldEnum]


  export const SuperAdminScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    password: 'password',
    phone: 'phone'
  };

  export type SuperAdminScalarFieldEnum = (typeof SuperAdminScalarFieldEnum)[keyof typeof SuperAdminScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    commercial_id: 'commercial_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    first_name: 'first_name',
    last_name: 'last_name',
    password: 'password',
    phone: 'phone',
    created_at: 'created_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const InterventionReportScalarFieldEnum: {
    id: 'id',
    interventionId: 'interventionId',
    title: 'title',
    description: 'description',
    created_at: 'created_at'
  };

  export type InterventionReportScalarFieldEnum = (typeof InterventionReportScalarFieldEnum)[keyof typeof InterventionReportScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    type: 'type',
    channel: 'channel',
    title: 'title',
    message: 'message',
    metadata: 'metadata',
    is_read: 'is_read',
    status: 'status',
    created_at: 'created_at',
    sent_at: 'sent_at',
    read_at: 'read_at'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'InterventionStatus'
   */
  export type EnumInterventionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterventionStatus'>
    


  /**
   * Reference to a field of type 'InterventionStatus[]'
   */
  export type ListEnumInterventionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterventionStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: IntFilter<"Admin"> | number
    first_name?: StringFilter<"Admin"> | string
    last_name?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    phone?: StringNullableFilter<"Admin"> | string | null
    add_by?: IntFilter<"Admin"> | number
    privilege?: IntFilter<"Admin"> | number
    SuperAdmin?: XOR<SuperAdminScalarRelationFilter, SuperAdminWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    add_by?: SortOrder
    privilege?: SortOrder
    SuperAdmin?: SuperAdminOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    first_name?: StringFilter<"Admin"> | string
    last_name?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    phone?: StringNullableFilter<"Admin"> | string | null
    add_by?: IntFilter<"Admin"> | number
    privilege?: IntFilter<"Admin"> | number
    SuperAdmin?: XOR<SuperAdminScalarRelationFilter, SuperAdminWhereInput>
  }, "id" | "email">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    add_by?: SortOrder
    privilege?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admin"> | number
    first_name?: StringWithAggregatesFilter<"Admin"> | string
    last_name?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    password?: StringWithAggregatesFilter<"Admin"> | string
    phone?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    add_by?: IntWithAggregatesFilter<"Admin"> | number
    privilege?: IntWithAggregatesFilter<"Admin"> | number
  }

  export type CommercialWhereInput = {
    AND?: CommercialWhereInput | CommercialWhereInput[]
    OR?: CommercialWhereInput[]
    NOT?: CommercialWhereInput | CommercialWhereInput[]
    id?: IntFilter<"Commercial"> | number
    first_name?: StringFilter<"Commercial"> | string
    last_name?: StringFilter<"Commercial"> | string
    email?: StringFilter<"Commercial"> | string
    password?: StringFilter<"Commercial"> | string
    phone?: StringNullableFilter<"Commercial"> | string | null
    Transaction?: TransactionListRelationFilter
  }

  export type CommercialOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    Transaction?: TransactionOrderByRelationAggregateInput
  }

  export type CommercialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: CommercialWhereInput | CommercialWhereInput[]
    OR?: CommercialWhereInput[]
    NOT?: CommercialWhereInput | CommercialWhereInput[]
    first_name?: StringFilter<"Commercial"> | string
    last_name?: StringFilter<"Commercial"> | string
    password?: StringFilter<"Commercial"> | string
    phone?: StringNullableFilter<"Commercial"> | string | null
    Transaction?: TransactionListRelationFilter
  }, "id" | "email">

  export type CommercialOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    _count?: CommercialCountOrderByAggregateInput
    _avg?: CommercialAvgOrderByAggregateInput
    _max?: CommercialMaxOrderByAggregateInput
    _min?: CommercialMinOrderByAggregateInput
    _sum?: CommercialSumOrderByAggregateInput
  }

  export type CommercialScalarWhereWithAggregatesInput = {
    AND?: CommercialScalarWhereWithAggregatesInput | CommercialScalarWhereWithAggregatesInput[]
    OR?: CommercialScalarWhereWithAggregatesInput[]
    NOT?: CommercialScalarWhereWithAggregatesInput | CommercialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Commercial"> | number
    first_name?: StringWithAggregatesFilter<"Commercial"> | string
    last_name?: StringWithAggregatesFilter<"Commercial"> | string
    email?: StringWithAggregatesFilter<"Commercial"> | string
    password?: StringWithAggregatesFilter<"Commercial"> | string
    phone?: StringNullableWithAggregatesFilter<"Commercial"> | string | null
  }

  export type DeciderWhereInput = {
    AND?: DeciderWhereInput | DeciderWhereInput[]
    OR?: DeciderWhereInput[]
    NOT?: DeciderWhereInput | DeciderWhereInput[]
    id?: IntFilter<"Decider"> | number
    first_name?: StringFilter<"Decider"> | string
    last_name?: StringFilter<"Decider"> | string
    email?: StringFilter<"Decider"> | string
    password?: StringFilter<"Decider"> | string
    phone?: StringNullableFilter<"Decider"> | string | null
  }

  export type DeciderOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
  }

  export type DeciderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: DeciderWhereInput | DeciderWhereInput[]
    OR?: DeciderWhereInput[]
    NOT?: DeciderWhereInput | DeciderWhereInput[]
    first_name?: StringFilter<"Decider"> | string
    last_name?: StringFilter<"Decider"> | string
    password?: StringFilter<"Decider"> | string
    phone?: StringNullableFilter<"Decider"> | string | null
  }, "id" | "email">

  export type DeciderOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    _count?: DeciderCountOrderByAggregateInput
    _avg?: DeciderAvgOrderByAggregateInput
    _max?: DeciderMaxOrderByAggregateInput
    _min?: DeciderMinOrderByAggregateInput
    _sum?: DeciderSumOrderByAggregateInput
  }

  export type DeciderScalarWhereWithAggregatesInput = {
    AND?: DeciderScalarWhereWithAggregatesInput | DeciderScalarWhereWithAggregatesInput[]
    OR?: DeciderScalarWhereWithAggregatesInput[]
    NOT?: DeciderScalarWhereWithAggregatesInput | DeciderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Decider"> | number
    first_name?: StringWithAggregatesFilter<"Decider"> | string
    last_name?: StringWithAggregatesFilter<"Decider"> | string
    email?: StringWithAggregatesFilter<"Decider"> | string
    password?: StringWithAggregatesFilter<"Decider"> | string
    phone?: StringNullableWithAggregatesFilter<"Decider"> | string | null
  }

  export type DispoIssueWhereInput = {
    AND?: DispoIssueWhereInput | DispoIssueWhereInput[]
    OR?: DispoIssueWhereInput[]
    NOT?: DispoIssueWhereInput | DispoIssueWhereInput[]
    id?: IntFilter<"DispoIssue"> | number
    dispositiveId?: IntFilter<"DispoIssue"> | number
    description?: StringFilter<"DispoIssue"> | string
    date?: DateTimeFilter<"DispoIssue"> | Date | string
    status?: StringFilter<"DispoIssue"> | string
    maintainerId?: IntNullableFilter<"DispoIssue"> | number | null
    Dispositive?: XOR<DispositiveScalarRelationFilter, DispositiveWhereInput>
    Maintainer?: XOR<MaintainerNullableScalarRelationFilter, MaintainerWhereInput> | null
  }

  export type DispoIssueOrderByWithRelationInput = {
    id?: SortOrder
    dispositiveId?: SortOrder
    description?: SortOrder
    date?: SortOrder
    status?: SortOrder
    maintainerId?: SortOrderInput | SortOrder
    Dispositive?: DispositiveOrderByWithRelationInput
    Maintainer?: MaintainerOrderByWithRelationInput
  }

  export type DispoIssueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DispoIssueWhereInput | DispoIssueWhereInput[]
    OR?: DispoIssueWhereInput[]
    NOT?: DispoIssueWhereInput | DispoIssueWhereInput[]
    dispositiveId?: IntFilter<"DispoIssue"> | number
    description?: StringFilter<"DispoIssue"> | string
    date?: DateTimeFilter<"DispoIssue"> | Date | string
    status?: StringFilter<"DispoIssue"> | string
    maintainerId?: IntNullableFilter<"DispoIssue"> | number | null
    Dispositive?: XOR<DispositiveScalarRelationFilter, DispositiveWhereInput>
    Maintainer?: XOR<MaintainerNullableScalarRelationFilter, MaintainerWhereInput> | null
  }, "id">

  export type DispoIssueOrderByWithAggregationInput = {
    id?: SortOrder
    dispositiveId?: SortOrder
    description?: SortOrder
    date?: SortOrder
    status?: SortOrder
    maintainerId?: SortOrderInput | SortOrder
    _count?: DispoIssueCountOrderByAggregateInput
    _avg?: DispoIssueAvgOrderByAggregateInput
    _max?: DispoIssueMaxOrderByAggregateInput
    _min?: DispoIssueMinOrderByAggregateInput
    _sum?: DispoIssueSumOrderByAggregateInput
  }

  export type DispoIssueScalarWhereWithAggregatesInput = {
    AND?: DispoIssueScalarWhereWithAggregatesInput | DispoIssueScalarWhereWithAggregatesInput[]
    OR?: DispoIssueScalarWhereWithAggregatesInput[]
    NOT?: DispoIssueScalarWhereWithAggregatesInput | DispoIssueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DispoIssue"> | number
    dispositiveId?: IntWithAggregatesFilter<"DispoIssue"> | number
    description?: StringWithAggregatesFilter<"DispoIssue"> | string
    date?: DateTimeWithAggregatesFilter<"DispoIssue"> | Date | string
    status?: StringWithAggregatesFilter<"DispoIssue"> | string
    maintainerId?: IntNullableWithAggregatesFilter<"DispoIssue"> | number | null
  }

  export type DispositiveWhereInput = {
    AND?: DispositiveWhereInput | DispositiveWhereInput[]
    OR?: DispositiveWhereInput[]
    NOT?: DispositiveWhereInput | DispositiveWhereInput[]
    id?: IntFilter<"Dispositive"> | number
    type?: StringFilter<"Dispositive"> | string
    start_date?: DateTimeFilter<"Dispositive"> | Date | string
    end_date?: DateTimeFilter<"Dispositive"> | Date | string
    initial_state?: StringFilter<"Dispositive"> | string
    MAC?: StringFilter<"Dispositive"> | string
    state?: StringFilter<"Dispositive"> | string
    user_id?: IntNullableFilter<"Dispositive"> | number | null
    product_id?: IntFilter<"Dispositive"> | number
    created_at?: DateTimeFilter<"Dispositive"> | Date | string
    updated_at?: DateTimeFilter<"Dispositive"> | Date | string
    DispotiveIssue?: DispoIssueListRelationFilter
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Intervention?: InterventionListRelationFilter
    ProductTransaction?: ProductTransactionListRelationFilter
  }

  export type DispositiveOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    initial_state?: SortOrder
    MAC?: SortOrder
    state?: SortOrder
    user_id?: SortOrderInput | SortOrder
    product_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    DispotiveIssue?: DispoIssueOrderByRelationAggregateInput
    Product?: ProductOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    Intervention?: InterventionOrderByRelationAggregateInput
    ProductTransaction?: ProductTransactionOrderByRelationAggregateInput
  }

  export type DispositiveWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DispositiveWhereInput | DispositiveWhereInput[]
    OR?: DispositiveWhereInput[]
    NOT?: DispositiveWhereInput | DispositiveWhereInput[]
    type?: StringFilter<"Dispositive"> | string
    start_date?: DateTimeFilter<"Dispositive"> | Date | string
    end_date?: DateTimeFilter<"Dispositive"> | Date | string
    initial_state?: StringFilter<"Dispositive"> | string
    MAC?: StringFilter<"Dispositive"> | string
    state?: StringFilter<"Dispositive"> | string
    user_id?: IntNullableFilter<"Dispositive"> | number | null
    product_id?: IntFilter<"Dispositive"> | number
    created_at?: DateTimeFilter<"Dispositive"> | Date | string
    updated_at?: DateTimeFilter<"Dispositive"> | Date | string
    DispotiveIssue?: DispoIssueListRelationFilter
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Intervention?: InterventionListRelationFilter
    ProductTransaction?: ProductTransactionListRelationFilter
  }, "id">

  export type DispositiveOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    initial_state?: SortOrder
    MAC?: SortOrder
    state?: SortOrder
    user_id?: SortOrderInput | SortOrder
    product_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: DispositiveCountOrderByAggregateInput
    _avg?: DispositiveAvgOrderByAggregateInput
    _max?: DispositiveMaxOrderByAggregateInput
    _min?: DispositiveMinOrderByAggregateInput
    _sum?: DispositiveSumOrderByAggregateInput
  }

  export type DispositiveScalarWhereWithAggregatesInput = {
    AND?: DispositiveScalarWhereWithAggregatesInput | DispositiveScalarWhereWithAggregatesInput[]
    OR?: DispositiveScalarWhereWithAggregatesInput[]
    NOT?: DispositiveScalarWhereWithAggregatesInput | DispositiveScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Dispositive"> | number
    type?: StringWithAggregatesFilter<"Dispositive"> | string
    start_date?: DateTimeWithAggregatesFilter<"Dispositive"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"Dispositive"> | Date | string
    initial_state?: StringWithAggregatesFilter<"Dispositive"> | string
    MAC?: StringWithAggregatesFilter<"Dispositive"> | string
    state?: StringWithAggregatesFilter<"Dispositive"> | string
    user_id?: IntNullableWithAggregatesFilter<"Dispositive"> | number | null
    product_id?: IntWithAggregatesFilter<"Dispositive"> | number
    created_at?: DateTimeWithAggregatesFilter<"Dispositive"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Dispositive"> | Date | string
  }

  export type HelperWhereInput = {
    AND?: HelperWhereInput | HelperWhereInput[]
    OR?: HelperWhereInput[]
    NOT?: HelperWhereInput | HelperWhereInput[]
    id?: IntFilter<"Helper"> | number
    first_name?: StringFilter<"Helper"> | string
    last_name?: StringFilter<"Helper"> | string
    email?: StringFilter<"Helper"> | string
    password?: StringFilter<"Helper"> | string
    phone?: StringNullableFilter<"Helper"> | string | null
    User?: UserListRelationFilter
  }

  export type HelperOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    User?: UserOrderByRelationAggregateInput
  }

  export type HelperWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: HelperWhereInput | HelperWhereInput[]
    OR?: HelperWhereInput[]
    NOT?: HelperWhereInput | HelperWhereInput[]
    first_name?: StringFilter<"Helper"> | string
    last_name?: StringFilter<"Helper"> | string
    password?: StringFilter<"Helper"> | string
    phone?: StringNullableFilter<"Helper"> | string | null
    User?: UserListRelationFilter
  }, "id" | "email">

  export type HelperOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    _count?: HelperCountOrderByAggregateInput
    _avg?: HelperAvgOrderByAggregateInput
    _max?: HelperMaxOrderByAggregateInput
    _min?: HelperMinOrderByAggregateInput
    _sum?: HelperSumOrderByAggregateInput
  }

  export type HelperScalarWhereWithAggregatesInput = {
    AND?: HelperScalarWhereWithAggregatesInput | HelperScalarWhereWithAggregatesInput[]
    OR?: HelperScalarWhereWithAggregatesInput[]
    NOT?: HelperScalarWhereWithAggregatesInput | HelperScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Helper"> | number
    first_name?: StringWithAggregatesFilter<"Helper"> | string
    last_name?: StringWithAggregatesFilter<"Helper"> | string
    email?: StringWithAggregatesFilter<"Helper"> | string
    password?: StringWithAggregatesFilter<"Helper"> | string
    phone?: StringNullableWithAggregatesFilter<"Helper"> | string | null
  }

  export type InterventionWhereInput = {
    AND?: InterventionWhereInput | InterventionWhereInput[]
    OR?: InterventionWhereInput[]
    NOT?: InterventionWhereInput | InterventionWhereInput[]
    idMaintainer?: IntFilter<"Intervention"> | number
    description?: StringFilter<"Intervention"> | string
    type?: StringFilter<"Intervention"> | string
    end_date?: DateTimeFilter<"Intervention"> | Date | string
    start_date?: DateTimeFilter<"Intervention"> | Date | string
    id?: IntFilter<"Intervention"> | number
    status?: EnumInterventionStatusFilter<"Intervention"> | $Enums.InterventionStatus
    idDispositive?: IntFilter<"Intervention"> | number
    Dispositive?: XOR<DispositiveScalarRelationFilter, DispositiveWhereInput>
    Maintainer?: XOR<MaintainerScalarRelationFilter, MaintainerWhereInput>
    InterventionReport?: XOR<InterventionReportNullableScalarRelationFilter, InterventionReportWhereInput> | null
  }

  export type InterventionOrderByWithRelationInput = {
    idMaintainer?: SortOrder
    description?: SortOrder
    type?: SortOrder
    end_date?: SortOrder
    start_date?: SortOrder
    id?: SortOrder
    status?: SortOrder
    idDispositive?: SortOrder
    Dispositive?: DispositiveOrderByWithRelationInput
    Maintainer?: MaintainerOrderByWithRelationInput
    InterventionReport?: InterventionReportOrderByWithRelationInput
  }

  export type InterventionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InterventionWhereInput | InterventionWhereInput[]
    OR?: InterventionWhereInput[]
    NOT?: InterventionWhereInput | InterventionWhereInput[]
    idMaintainer?: IntFilter<"Intervention"> | number
    description?: StringFilter<"Intervention"> | string
    type?: StringFilter<"Intervention"> | string
    end_date?: DateTimeFilter<"Intervention"> | Date | string
    start_date?: DateTimeFilter<"Intervention"> | Date | string
    status?: EnumInterventionStatusFilter<"Intervention"> | $Enums.InterventionStatus
    idDispositive?: IntFilter<"Intervention"> | number
    Dispositive?: XOR<DispositiveScalarRelationFilter, DispositiveWhereInput>
    Maintainer?: XOR<MaintainerScalarRelationFilter, MaintainerWhereInput>
    InterventionReport?: XOR<InterventionReportNullableScalarRelationFilter, InterventionReportWhereInput> | null
  }, "id">

  export type InterventionOrderByWithAggregationInput = {
    idMaintainer?: SortOrder
    description?: SortOrder
    type?: SortOrder
    end_date?: SortOrder
    start_date?: SortOrder
    id?: SortOrder
    status?: SortOrder
    idDispositive?: SortOrder
    _count?: InterventionCountOrderByAggregateInput
    _avg?: InterventionAvgOrderByAggregateInput
    _max?: InterventionMaxOrderByAggregateInput
    _min?: InterventionMinOrderByAggregateInput
    _sum?: InterventionSumOrderByAggregateInput
  }

  export type InterventionScalarWhereWithAggregatesInput = {
    AND?: InterventionScalarWhereWithAggregatesInput | InterventionScalarWhereWithAggregatesInput[]
    OR?: InterventionScalarWhereWithAggregatesInput[]
    NOT?: InterventionScalarWhereWithAggregatesInput | InterventionScalarWhereWithAggregatesInput[]
    idMaintainer?: IntWithAggregatesFilter<"Intervention"> | number
    description?: StringWithAggregatesFilter<"Intervention"> | string
    type?: StringWithAggregatesFilter<"Intervention"> | string
    end_date?: DateTimeWithAggregatesFilter<"Intervention"> | Date | string
    start_date?: DateTimeWithAggregatesFilter<"Intervention"> | Date | string
    id?: IntWithAggregatesFilter<"Intervention"> | number
    status?: EnumInterventionStatusWithAggregatesFilter<"Intervention"> | $Enums.InterventionStatus
    idDispositive?: IntWithAggregatesFilter<"Intervention"> | number
  }

  export type MaintainerWhereInput = {
    AND?: MaintainerWhereInput | MaintainerWhereInput[]
    OR?: MaintainerWhereInput[]
    NOT?: MaintainerWhereInput | MaintainerWhereInput[]
    id?: IntFilter<"Maintainer"> | number
    first_name?: StringFilter<"Maintainer"> | string
    last_name?: StringFilter<"Maintainer"> | string
    email?: StringFilter<"Maintainer"> | string
    password?: StringFilter<"Maintainer"> | string
    phone?: StringNullableFilter<"Maintainer"> | string | null
    DispoIssue?: DispoIssueListRelationFilter
    Intervention?: InterventionListRelationFilter
  }

  export type MaintainerOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    DispoIssue?: DispoIssueOrderByRelationAggregateInput
    Intervention?: InterventionOrderByRelationAggregateInput
  }

  export type MaintainerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: MaintainerWhereInput | MaintainerWhereInput[]
    OR?: MaintainerWhereInput[]
    NOT?: MaintainerWhereInput | MaintainerWhereInput[]
    first_name?: StringFilter<"Maintainer"> | string
    last_name?: StringFilter<"Maintainer"> | string
    password?: StringFilter<"Maintainer"> | string
    phone?: StringNullableFilter<"Maintainer"> | string | null
    DispoIssue?: DispoIssueListRelationFilter
    Intervention?: InterventionListRelationFilter
  }, "id" | "email">

  export type MaintainerOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    _count?: MaintainerCountOrderByAggregateInput
    _avg?: MaintainerAvgOrderByAggregateInput
    _max?: MaintainerMaxOrderByAggregateInput
    _min?: MaintainerMinOrderByAggregateInput
    _sum?: MaintainerSumOrderByAggregateInput
  }

  export type MaintainerScalarWhereWithAggregatesInput = {
    AND?: MaintainerScalarWhereWithAggregatesInput | MaintainerScalarWhereWithAggregatesInput[]
    OR?: MaintainerScalarWhereWithAggregatesInput[]
    NOT?: MaintainerScalarWhereWithAggregatesInput | MaintainerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Maintainer"> | number
    first_name?: StringWithAggregatesFilter<"Maintainer"> | string
    last_name?: StringWithAggregatesFilter<"Maintainer"> | string
    email?: StringWithAggregatesFilter<"Maintainer"> | string
    password?: StringWithAggregatesFilter<"Maintainer"> | string
    phone?: StringNullableWithAggregatesFilter<"Maintainer"> | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    created_at?: DateTimeFilter<"Product"> | Date | string
    updated_at?: DateTimeFilter<"Product"> | Date | string
    Dispositive?: DispositiveListRelationFilter
    ProductQuotation?: ProductQuotationListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    Dispositive?: DispositiveOrderByRelationAggregateInput
    ProductQuotation?: ProductQuotationOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    created_at?: DateTimeFilter<"Product"> | Date | string
    updated_at?: DateTimeFilter<"Product"> | Date | string
    Dispositive?: DispositiveListRelationFilter
    ProductQuotation?: ProductQuotationListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: FloatWithAggregatesFilter<"Product"> | number
    created_at?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type ProductQuotationWhereInput = {
    AND?: ProductQuotationWhereInput | ProductQuotationWhereInput[]
    OR?: ProductQuotationWhereInput[]
    NOT?: ProductQuotationWhereInput | ProductQuotationWhereInput[]
    quotation_id?: IntFilter<"ProductQuotation"> | number
    product_id?: IntFilter<"ProductQuotation"> | number
    count?: IntFilter<"ProductQuotation"> | number
    created_at?: DateTimeFilter<"ProductQuotation"> | Date | string
    updated_at?: DateTimeFilter<"ProductQuotation"> | Date | string
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    Quotation?: XOR<QuotationScalarRelationFilter, QuotationWhereInput>
  }

  export type ProductQuotationOrderByWithRelationInput = {
    quotation_id?: SortOrder
    product_id?: SortOrder
    count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    Product?: ProductOrderByWithRelationInput
    Quotation?: QuotationOrderByWithRelationInput
  }

  export type ProductQuotationWhereUniqueInput = Prisma.AtLeast<{
    quotation_id_product_id?: ProductQuotationQuotation_idProduct_idCompoundUniqueInput
    AND?: ProductQuotationWhereInput | ProductQuotationWhereInput[]
    OR?: ProductQuotationWhereInput[]
    NOT?: ProductQuotationWhereInput | ProductQuotationWhereInput[]
    quotation_id?: IntFilter<"ProductQuotation"> | number
    product_id?: IntFilter<"ProductQuotation"> | number
    count?: IntFilter<"ProductQuotation"> | number
    created_at?: DateTimeFilter<"ProductQuotation"> | Date | string
    updated_at?: DateTimeFilter<"ProductQuotation"> | Date | string
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    Quotation?: XOR<QuotationScalarRelationFilter, QuotationWhereInput>
  }, "quotation_id_product_id">

  export type ProductQuotationOrderByWithAggregationInput = {
    quotation_id?: SortOrder
    product_id?: SortOrder
    count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProductQuotationCountOrderByAggregateInput
    _avg?: ProductQuotationAvgOrderByAggregateInput
    _max?: ProductQuotationMaxOrderByAggregateInput
    _min?: ProductQuotationMinOrderByAggregateInput
    _sum?: ProductQuotationSumOrderByAggregateInput
  }

  export type ProductQuotationScalarWhereWithAggregatesInput = {
    AND?: ProductQuotationScalarWhereWithAggregatesInput | ProductQuotationScalarWhereWithAggregatesInput[]
    OR?: ProductQuotationScalarWhereWithAggregatesInput[]
    NOT?: ProductQuotationScalarWhereWithAggregatesInput | ProductQuotationScalarWhereWithAggregatesInput[]
    quotation_id?: IntWithAggregatesFilter<"ProductQuotation"> | number
    product_id?: IntWithAggregatesFilter<"ProductQuotation"> | number
    count?: IntWithAggregatesFilter<"ProductQuotation"> | number
    created_at?: DateTimeWithAggregatesFilter<"ProductQuotation"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ProductQuotation"> | Date | string
  }

  export type ProductTransactionWhereInput = {
    AND?: ProductTransactionWhereInput | ProductTransactionWhereInput[]
    OR?: ProductTransactionWhereInput[]
    NOT?: ProductTransactionWhereInput | ProductTransactionWhereInput[]
    transaction_id?: IntFilter<"ProductTransaction"> | number
    dispositive_id?: IntFilter<"ProductTransaction"> | number
    isConfirmed?: BoolFilter<"ProductTransaction"> | boolean
    created_at?: DateTimeFilter<"ProductTransaction"> | Date | string
    updated_at?: DateTimeFilter<"ProductTransaction"> | Date | string
    Dispositive?: XOR<DispositiveScalarRelationFilter, DispositiveWhereInput>
    Transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }

  export type ProductTransactionOrderByWithRelationInput = {
    transaction_id?: SortOrder
    dispositive_id?: SortOrder
    isConfirmed?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    Dispositive?: DispositiveOrderByWithRelationInput
    Transaction?: TransactionOrderByWithRelationInput
  }

  export type ProductTransactionWhereUniqueInput = Prisma.AtLeast<{
    transaction_id_dispositive_id?: ProductTransactionTransaction_idDispositive_idCompoundUniqueInput
    AND?: ProductTransactionWhereInput | ProductTransactionWhereInput[]
    OR?: ProductTransactionWhereInput[]
    NOT?: ProductTransactionWhereInput | ProductTransactionWhereInput[]
    transaction_id?: IntFilter<"ProductTransaction"> | number
    dispositive_id?: IntFilter<"ProductTransaction"> | number
    isConfirmed?: BoolFilter<"ProductTransaction"> | boolean
    created_at?: DateTimeFilter<"ProductTransaction"> | Date | string
    updated_at?: DateTimeFilter<"ProductTransaction"> | Date | string
    Dispositive?: XOR<DispositiveScalarRelationFilter, DispositiveWhereInput>
    Transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }, "transaction_id_dispositive_id">

  export type ProductTransactionOrderByWithAggregationInput = {
    transaction_id?: SortOrder
    dispositive_id?: SortOrder
    isConfirmed?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProductTransactionCountOrderByAggregateInput
    _avg?: ProductTransactionAvgOrderByAggregateInput
    _max?: ProductTransactionMaxOrderByAggregateInput
    _min?: ProductTransactionMinOrderByAggregateInput
    _sum?: ProductTransactionSumOrderByAggregateInput
  }

  export type ProductTransactionScalarWhereWithAggregatesInput = {
    AND?: ProductTransactionScalarWhereWithAggregatesInput | ProductTransactionScalarWhereWithAggregatesInput[]
    OR?: ProductTransactionScalarWhereWithAggregatesInput[]
    NOT?: ProductTransactionScalarWhereWithAggregatesInput | ProductTransactionScalarWhereWithAggregatesInput[]
    transaction_id?: IntWithAggregatesFilter<"ProductTransaction"> | number
    dispositive_id?: IntWithAggregatesFilter<"ProductTransaction"> | number
    isConfirmed?: BoolWithAggregatesFilter<"ProductTransaction"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"ProductTransaction"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ProductTransaction"> | Date | string
  }

  export type QuotationWhereInput = {
    AND?: QuotationWhereInput | QuotationWhereInput[]
    OR?: QuotationWhereInput[]
    NOT?: QuotationWhereInput | QuotationWhereInput[]
    id?: IntFilter<"Quotation"> | number
    user_id?: IntFilter<"Quotation"> | number
    created_at?: DateTimeFilter<"Quotation"> | Date | string
    updated_at?: DateTimeFilter<"Quotation"> | Date | string
    ProductQuotation?: ProductQuotationListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type QuotationOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    ProductQuotation?: ProductQuotationOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
  }

  export type QuotationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuotationWhereInput | QuotationWhereInput[]
    OR?: QuotationWhereInput[]
    NOT?: QuotationWhereInput | QuotationWhereInput[]
    user_id?: IntFilter<"Quotation"> | number
    created_at?: DateTimeFilter<"Quotation"> | Date | string
    updated_at?: DateTimeFilter<"Quotation"> | Date | string
    ProductQuotation?: ProductQuotationListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type QuotationOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: QuotationCountOrderByAggregateInput
    _avg?: QuotationAvgOrderByAggregateInput
    _max?: QuotationMaxOrderByAggregateInput
    _min?: QuotationMinOrderByAggregateInput
    _sum?: QuotationSumOrderByAggregateInput
  }

  export type QuotationScalarWhereWithAggregatesInput = {
    AND?: QuotationScalarWhereWithAggregatesInput | QuotationScalarWhereWithAggregatesInput[]
    OR?: QuotationScalarWhereWithAggregatesInput[]
    NOT?: QuotationScalarWhereWithAggregatesInput | QuotationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Quotation"> | number
    user_id?: IntWithAggregatesFilter<"Quotation"> | number
    created_at?: DateTimeWithAggregatesFilter<"Quotation"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Quotation"> | Date | string
  }

  export type SuperAdminWhereInput = {
    AND?: SuperAdminWhereInput | SuperAdminWhereInput[]
    OR?: SuperAdminWhereInput[]
    NOT?: SuperAdminWhereInput | SuperAdminWhereInput[]
    id?: IntFilter<"SuperAdmin"> | number
    first_name?: StringFilter<"SuperAdmin"> | string
    last_name?: StringFilter<"SuperAdmin"> | string
    email?: StringFilter<"SuperAdmin"> | string
    password?: StringFilter<"SuperAdmin"> | string
    phone?: StringNullableFilter<"SuperAdmin"> | string | null
    Admin?: AdminListRelationFilter
  }

  export type SuperAdminOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    Admin?: AdminOrderByRelationAggregateInput
  }

  export type SuperAdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: SuperAdminWhereInput | SuperAdminWhereInput[]
    OR?: SuperAdminWhereInput[]
    NOT?: SuperAdminWhereInput | SuperAdminWhereInput[]
    first_name?: StringFilter<"SuperAdmin"> | string
    last_name?: StringFilter<"SuperAdmin"> | string
    password?: StringFilter<"SuperAdmin"> | string
    phone?: StringNullableFilter<"SuperAdmin"> | string | null
    Admin?: AdminListRelationFilter
  }, "id" | "email">

  export type SuperAdminOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    _count?: SuperAdminCountOrderByAggregateInput
    _avg?: SuperAdminAvgOrderByAggregateInput
    _max?: SuperAdminMaxOrderByAggregateInput
    _min?: SuperAdminMinOrderByAggregateInput
    _sum?: SuperAdminSumOrderByAggregateInput
  }

  export type SuperAdminScalarWhereWithAggregatesInput = {
    AND?: SuperAdminScalarWhereWithAggregatesInput | SuperAdminScalarWhereWithAggregatesInput[]
    OR?: SuperAdminScalarWhereWithAggregatesInput[]
    NOT?: SuperAdminScalarWhereWithAggregatesInput | SuperAdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SuperAdmin"> | number
    first_name?: StringWithAggregatesFilter<"SuperAdmin"> | string
    last_name?: StringWithAggregatesFilter<"SuperAdmin"> | string
    email?: StringWithAggregatesFilter<"SuperAdmin"> | string
    password?: StringWithAggregatesFilter<"SuperAdmin"> | string
    phone?: StringNullableWithAggregatesFilter<"SuperAdmin"> | string | null
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: IntFilter<"Transaction"> | number
    user_id?: IntFilter<"Transaction"> | number
    commercial_id?: IntFilter<"Transaction"> | number
    created_at?: DateTimeFilter<"Transaction"> | Date | string
    updated_at?: DateTimeFilter<"Transaction"> | Date | string
    ProductTransaction?: ProductTransactionListRelationFilter
    Commercial?: XOR<CommercialScalarRelationFilter, CommercialWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    commercial_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    ProductTransaction?: ProductTransactionOrderByRelationAggregateInput
    Commercial?: CommercialOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    user_id?: IntFilter<"Transaction"> | number
    commercial_id?: IntFilter<"Transaction"> | number
    created_at?: DateTimeFilter<"Transaction"> | Date | string
    updated_at?: DateTimeFilter<"Transaction"> | Date | string
    ProductTransaction?: ProductTransactionListRelationFilter
    Commercial?: XOR<CommercialScalarRelationFilter, CommercialWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    commercial_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transaction"> | number
    user_id?: IntWithAggregatesFilter<"Transaction"> | number
    commercial_id?: IntWithAggregatesFilter<"Transaction"> | number
    created_at?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    first_name?: StringFilter<"User"> | string
    last_name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    Dispositive?: DispositiveListRelationFilter
    Quotation?: QuotationListRelationFilter
    Transaction?: TransactionListRelationFilter
    Helper?: HelperListRelationFilter
    Notification?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    created_at?: SortOrder
    Dispositive?: DispositiveOrderByRelationAggregateInput
    Quotation?: QuotationOrderByRelationAggregateInput
    Transaction?: TransactionOrderByRelationAggregateInput
    Helper?: HelperOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    first_name?: StringFilter<"User"> | string
    last_name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    Dispositive?: DispositiveListRelationFilter
    Quotation?: QuotationListRelationFilter
    Transaction?: TransactionListRelationFilter
    Helper?: HelperListRelationFilter
    Notification?: NotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    first_name?: StringWithAggregatesFilter<"User"> | string
    last_name?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type InterventionReportWhereInput = {
    AND?: InterventionReportWhereInput | InterventionReportWhereInput[]
    OR?: InterventionReportWhereInput[]
    NOT?: InterventionReportWhereInput | InterventionReportWhereInput[]
    id?: IntFilter<"InterventionReport"> | number
    interventionId?: IntFilter<"InterventionReport"> | number
    title?: StringFilter<"InterventionReport"> | string
    description?: StringFilter<"InterventionReport"> | string
    created_at?: DateTimeFilter<"InterventionReport"> | Date | string
    Intervention?: XOR<InterventionScalarRelationFilter, InterventionWhereInput>
  }

  export type InterventionReportOrderByWithRelationInput = {
    id?: SortOrder
    interventionId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    Intervention?: InterventionOrderByWithRelationInput
  }

  export type InterventionReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    interventionId?: number
    AND?: InterventionReportWhereInput | InterventionReportWhereInput[]
    OR?: InterventionReportWhereInput[]
    NOT?: InterventionReportWhereInput | InterventionReportWhereInput[]
    title?: StringFilter<"InterventionReport"> | string
    description?: StringFilter<"InterventionReport"> | string
    created_at?: DateTimeFilter<"InterventionReport"> | Date | string
    Intervention?: XOR<InterventionScalarRelationFilter, InterventionWhereInput>
  }, "id" | "interventionId">

  export type InterventionReportOrderByWithAggregationInput = {
    id?: SortOrder
    interventionId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    _count?: InterventionReportCountOrderByAggregateInput
    _avg?: InterventionReportAvgOrderByAggregateInput
    _max?: InterventionReportMaxOrderByAggregateInput
    _min?: InterventionReportMinOrderByAggregateInput
    _sum?: InterventionReportSumOrderByAggregateInput
  }

  export type InterventionReportScalarWhereWithAggregatesInput = {
    AND?: InterventionReportScalarWhereWithAggregatesInput | InterventionReportScalarWhereWithAggregatesInput[]
    OR?: InterventionReportScalarWhereWithAggregatesInput[]
    NOT?: InterventionReportScalarWhereWithAggregatesInput | InterventionReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InterventionReport"> | number
    interventionId?: IntWithAggregatesFilter<"InterventionReport"> | number
    title?: StringWithAggregatesFilter<"InterventionReport"> | string
    description?: StringWithAggregatesFilter<"InterventionReport"> | string
    created_at?: DateTimeWithAggregatesFilter<"InterventionReport"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    user_id?: IntFilter<"Notification"> | number
    type?: StringNullableFilter<"Notification"> | string | null
    channel?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    metadata?: JsonNullableFilter<"Notification">
    is_read?: BoolFilter<"Notification"> | boolean
    status?: StringFilter<"Notification"> | string
    created_at?: DateTimeFilter<"Notification"> | Date | string
    sent_at?: DateTimeNullableFilter<"Notification"> | Date | string | null
    read_at?: DateTimeNullableFilter<"Notification"> | Date | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrderInput | SortOrder
    channel?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    metadata?: SortOrderInput | SortOrder
    is_read?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    sent_at?: SortOrderInput | SortOrder
    read_at?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    user_id?: IntFilter<"Notification"> | number
    type?: StringNullableFilter<"Notification"> | string | null
    channel?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    metadata?: JsonNullableFilter<"Notification">
    is_read?: BoolFilter<"Notification"> | boolean
    status?: StringFilter<"Notification"> | string
    created_at?: DateTimeFilter<"Notification"> | Date | string
    sent_at?: DateTimeNullableFilter<"Notification"> | Date | string | null
    read_at?: DateTimeNullableFilter<"Notification"> | Date | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrderInput | SortOrder
    channel?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    metadata?: SortOrderInput | SortOrder
    is_read?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    sent_at?: SortOrderInput | SortOrder
    read_at?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    user_id?: IntWithAggregatesFilter<"Notification"> | number
    type?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    channel?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    is_read?: BoolWithAggregatesFilter<"Notification"> | boolean
    status?: StringWithAggregatesFilter<"Notification"> | string
    created_at?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    sent_at?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    read_at?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
  }

  export type AdminCreateInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    privilege: number
    SuperAdmin: SuperAdminCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    add_by: number
    privilege: number
  }

  export type AdminUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    privilege?: IntFieldUpdateOperationsInput | number
    SuperAdmin?: SuperAdminUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    add_by?: IntFieldUpdateOperationsInput | number
    privilege?: IntFieldUpdateOperationsInput | number
  }

  export type AdminCreateManyInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    add_by: number
    privilege: number
  }

  export type AdminUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    privilege?: IntFieldUpdateOperationsInput | number
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    add_by?: IntFieldUpdateOperationsInput | number
    privilege?: IntFieldUpdateOperationsInput | number
  }

  export type CommercialCreateInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    Transaction?: TransactionCreateNestedManyWithoutCommercialInput
  }

  export type CommercialUncheckedCreateInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    Transaction?: TransactionUncheckedCreateNestedManyWithoutCommercialInput
  }

  export type CommercialUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    Transaction?: TransactionUpdateManyWithoutCommercialNestedInput
  }

  export type CommercialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    Transaction?: TransactionUncheckedUpdateManyWithoutCommercialNestedInput
  }

  export type CommercialCreateManyInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
  }

  export type CommercialUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommercialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeciderCreateInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
  }

  export type DeciderUncheckedCreateInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
  }

  export type DeciderUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeciderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeciderCreateManyInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
  }

  export type DeciderUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeciderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DispoIssueCreateInput = {
    description: string
    date?: Date | string
    status?: string
    Dispositive: DispositiveCreateNestedOneWithoutDispotiveIssueInput
    Maintainer?: MaintainerCreateNestedOneWithoutDispoIssueInput
  }

  export type DispoIssueUncheckedCreateInput = {
    id?: number
    dispositiveId: number
    description: string
    date?: Date | string
    status?: string
    maintainerId?: number | null
  }

  export type DispoIssueUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    Dispositive?: DispositiveUpdateOneRequiredWithoutDispotiveIssueNestedInput
    Maintainer?: MaintainerUpdateOneWithoutDispoIssueNestedInput
  }

  export type DispoIssueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dispositiveId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    maintainerId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DispoIssueCreateManyInput = {
    id?: number
    dispositiveId: number
    description: string
    date?: Date | string
    status?: string
    maintainerId?: number | null
  }

  export type DispoIssueUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type DispoIssueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dispositiveId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    maintainerId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DispositiveCreateInput = {
    type: string
    start_date: Date | string
    end_date: Date | string
    initial_state: string
    MAC: string
    state: string
    created_at?: Date | string
    updated_at: Date | string
    DispotiveIssue?: DispoIssueCreateNestedManyWithoutDispositiveInput
    Product: ProductCreateNestedOneWithoutDispositiveInput
    User?: UserCreateNestedOneWithoutDispositiveInput
    Intervention?: InterventionCreateNestedManyWithoutDispositiveInput
    ProductTransaction?: ProductTransactionCreateNestedManyWithoutDispositiveInput
  }

  export type DispositiveUncheckedCreateInput = {
    id?: number
    type: string
    start_date: Date | string
    end_date: Date | string
    initial_state: string
    MAC: string
    state: string
    user_id?: number | null
    product_id: number
    created_at?: Date | string
    updated_at: Date | string
    DispotiveIssue?: DispoIssueUncheckedCreateNestedManyWithoutDispositiveInput
    Intervention?: InterventionUncheckedCreateNestedManyWithoutDispositiveInput
    ProductTransaction?: ProductTransactionUncheckedCreateNestedManyWithoutDispositiveInput
  }

  export type DispositiveUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    initial_state?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    DispotiveIssue?: DispoIssueUpdateManyWithoutDispositiveNestedInput
    Product?: ProductUpdateOneRequiredWithoutDispositiveNestedInput
    User?: UserUpdateOneWithoutDispositiveNestedInput
    Intervention?: InterventionUpdateManyWithoutDispositiveNestedInput
    ProductTransaction?: ProductTransactionUpdateManyWithoutDispositiveNestedInput
  }

  export type DispositiveUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    initial_state?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    product_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    DispotiveIssue?: DispoIssueUncheckedUpdateManyWithoutDispositiveNestedInput
    Intervention?: InterventionUncheckedUpdateManyWithoutDispositiveNestedInput
    ProductTransaction?: ProductTransactionUncheckedUpdateManyWithoutDispositiveNestedInput
  }

  export type DispositiveCreateManyInput = {
    id?: number
    type: string
    start_date: Date | string
    end_date: Date | string
    initial_state: string
    MAC: string
    state: string
    user_id?: number | null
    product_id: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type DispositiveUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    initial_state?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispositiveUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    initial_state?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    product_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelperCreateInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    User?: UserCreateNestedManyWithoutHelperInput
  }

  export type HelperUncheckedCreateInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    User?: UserUncheckedCreateNestedManyWithoutHelperInput
  }

  export type HelperUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateManyWithoutHelperNestedInput
  }

  export type HelperUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUncheckedUpdateManyWithoutHelperNestedInput
  }

  export type HelperCreateManyInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
  }

  export type HelperUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HelperUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InterventionCreateInput = {
    description: string
    type: string
    end_date: Date | string
    start_date?: Date | string
    status?: $Enums.InterventionStatus
    Dispositive: DispositiveCreateNestedOneWithoutInterventionInput
    Maintainer: MaintainerCreateNestedOneWithoutInterventionInput
    InterventionReport?: InterventionReportCreateNestedOneWithoutInterventionInput
  }

  export type InterventionUncheckedCreateInput = {
    idMaintainer: number
    description: string
    type: string
    end_date: Date | string
    start_date?: Date | string
    id?: number
    status?: $Enums.InterventionStatus
    idDispositive: number
    InterventionReport?: InterventionReportUncheckedCreateNestedOneWithoutInterventionInput
  }

  export type InterventionUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    Dispositive?: DispositiveUpdateOneRequiredWithoutInterventionNestedInput
    Maintainer?: MaintainerUpdateOneRequiredWithoutInterventionNestedInput
    InterventionReport?: InterventionReportUpdateOneWithoutInterventionNestedInput
  }

  export type InterventionUncheckedUpdateInput = {
    idMaintainer?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    idDispositive?: IntFieldUpdateOperationsInput | number
    InterventionReport?: InterventionReportUncheckedUpdateOneWithoutInterventionNestedInput
  }

  export type InterventionCreateManyInput = {
    idMaintainer: number
    description: string
    type: string
    end_date: Date | string
    start_date?: Date | string
    id?: number
    status?: $Enums.InterventionStatus
    idDispositive: number
  }

  export type InterventionUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
  }

  export type InterventionUncheckedUpdateManyInput = {
    idMaintainer?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    idDispositive?: IntFieldUpdateOperationsInput | number
  }

  export type MaintainerCreateInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    DispoIssue?: DispoIssueCreateNestedManyWithoutMaintainerInput
    Intervention?: InterventionCreateNestedManyWithoutMaintainerInput
  }

  export type MaintainerUncheckedCreateInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    DispoIssue?: DispoIssueUncheckedCreateNestedManyWithoutMaintainerInput
    Intervention?: InterventionUncheckedCreateNestedManyWithoutMaintainerInput
  }

  export type MaintainerUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    DispoIssue?: DispoIssueUpdateManyWithoutMaintainerNestedInput
    Intervention?: InterventionUpdateManyWithoutMaintainerNestedInput
  }

  export type MaintainerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    DispoIssue?: DispoIssueUncheckedUpdateManyWithoutMaintainerNestedInput
    Intervention?: InterventionUncheckedUpdateManyWithoutMaintainerNestedInput
  }

  export type MaintainerCreateManyInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
  }

  export type MaintainerUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintainerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    name: string
    description?: string | null
    price: number
    created_at?: Date | string
    updated_at: Date | string
    Dispositive?: DispositiveCreateNestedManyWithoutProductInput
    ProductQuotation?: ProductQuotationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    price: number
    created_at?: Date | string
    updated_at: Date | string
    Dispositive?: DispositiveUncheckedCreateNestedManyWithoutProductInput
    ProductQuotation?: ProductQuotationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Dispositive?: DispositiveUpdateManyWithoutProductNestedInput
    ProductQuotation?: ProductQuotationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Dispositive?: DispositiveUncheckedUpdateManyWithoutProductNestedInput
    ProductQuotation?: ProductQuotationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    price: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductQuotationCreateInput = {
    count: number
    created_at?: Date | string
    updated_at: Date | string
    Product: ProductCreateNestedOneWithoutProductQuotationInput
    Quotation: QuotationCreateNestedOneWithoutProductQuotationInput
  }

  export type ProductQuotationUncheckedCreateInput = {
    quotation_id: number
    product_id: number
    count: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ProductQuotationUpdateInput = {
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutProductQuotationNestedInput
    Quotation?: QuotationUpdateOneRequiredWithoutProductQuotationNestedInput
  }

  export type ProductQuotationUncheckedUpdateInput = {
    quotation_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductQuotationCreateManyInput = {
    quotation_id: number
    product_id: number
    count: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ProductQuotationUpdateManyMutationInput = {
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductQuotationUncheckedUpdateManyInput = {
    quotation_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTransactionCreateInput = {
    isConfirmed?: boolean
    created_at?: Date | string
    updated_at: Date | string
    Dispositive: DispositiveCreateNestedOneWithoutProductTransactionInput
    Transaction: TransactionCreateNestedOneWithoutProductTransactionInput
  }

  export type ProductTransactionUncheckedCreateInput = {
    transaction_id: number
    dispositive_id: number
    isConfirmed?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ProductTransactionUpdateInput = {
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Dispositive?: DispositiveUpdateOneRequiredWithoutProductTransactionNestedInput
    Transaction?: TransactionUpdateOneRequiredWithoutProductTransactionNestedInput
  }

  export type ProductTransactionUncheckedUpdateInput = {
    transaction_id?: IntFieldUpdateOperationsInput | number
    dispositive_id?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTransactionCreateManyInput = {
    transaction_id: number
    dispositive_id: number
    isConfirmed?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ProductTransactionUpdateManyMutationInput = {
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTransactionUncheckedUpdateManyInput = {
    transaction_id?: IntFieldUpdateOperationsInput | number
    dispositive_id?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationCreateInput = {
    created_at?: Date | string
    updated_at: Date | string
    ProductQuotation?: ProductQuotationCreateNestedManyWithoutQuotationInput
    User: UserCreateNestedOneWithoutQuotationInput
  }

  export type QuotationUncheckedCreateInput = {
    id?: number
    user_id: number
    created_at?: Date | string
    updated_at: Date | string
    ProductQuotation?: ProductQuotationUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductQuotation?: ProductQuotationUpdateManyWithoutQuotationNestedInput
    User?: UserUpdateOneRequiredWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductQuotation?: ProductQuotationUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationCreateManyInput = {
    id?: number
    user_id: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type QuotationUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuperAdminCreateInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    Admin?: AdminCreateNestedManyWithoutSuperAdminInput
  }

  export type SuperAdminUncheckedCreateInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    Admin?: AdminUncheckedCreateNestedManyWithoutSuperAdminInput
  }

  export type SuperAdminUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    Admin?: AdminUpdateManyWithoutSuperAdminNestedInput
  }

  export type SuperAdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    Admin?: AdminUncheckedUpdateManyWithoutSuperAdminNestedInput
  }

  export type SuperAdminCreateManyInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
  }

  export type SuperAdminUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SuperAdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionCreateInput = {
    created_at?: Date | string
    updated_at: Date | string
    ProductTransaction?: ProductTransactionCreateNestedManyWithoutTransactionInput
    Commercial: CommercialCreateNestedOneWithoutTransactionInput
    User: UserCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    user_id: number
    commercial_id: number
    created_at?: Date | string
    updated_at: Date | string
    ProductTransaction?: ProductTransactionUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductTransaction?: ProductTransactionUpdateManyWithoutTransactionNestedInput
    Commercial?: CommercialUpdateOneRequiredWithoutTransactionNestedInput
    User?: UserUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    commercial_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductTransaction?: ProductTransactionUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: number
    user_id: number
    commercial_id: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    commercial_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    email: string
    first_name: string
    last_name: string
    password: string
    phone?: string | null
    created_at?: Date | string
    Dispositive?: DispositiveCreateNestedManyWithoutUserInput
    Quotation?: QuotationCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    Helper?: HelperCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    first_name: string
    last_name: string
    password: string
    phone?: string | null
    created_at?: Date | string
    Dispositive?: DispositiveUncheckedCreateNestedManyWithoutUserInput
    Quotation?: QuotationUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    Helper?: HelperUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Dispositive?: DispositiveUpdateManyWithoutUserNestedInput
    Quotation?: QuotationUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    Helper?: HelperUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Dispositive?: DispositiveUncheckedUpdateManyWithoutUserNestedInput
    Quotation?: QuotationUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    Helper?: HelperUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    first_name: string
    last_name: string
    password: string
    phone?: string | null
    created_at?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionReportCreateInput = {
    title: string
    description: string
    created_at?: Date | string
    Intervention: InterventionCreateNestedOneWithoutInterventionReportInput
  }

  export type InterventionReportUncheckedCreateInput = {
    id?: number
    interventionId: number
    title: string
    description: string
    created_at?: Date | string
  }

  export type InterventionReportUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Intervention?: InterventionUpdateOneRequiredWithoutInterventionReportNestedInput
  }

  export type InterventionReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    interventionId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionReportCreateManyInput = {
    id?: number
    interventionId: number
    title: string
    description: string
    created_at?: Date | string
  }

  export type InterventionReportUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    interventionId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    type?: string | null
    channel?: string | null
    title: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean
    status?: string
    created_at?: Date | string
    sent_at?: Date | string | null
    read_at?: Date | string | null
    User: UserCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    user_id: number
    type?: string | null
    channel?: string | null
    title: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean
    status?: string
    created_at?: Date | string
    sent_at?: Date | string | null
    read_at?: Date | string | null
  }

  export type NotificationUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyInput = {
    id?: number
    user_id: number
    type?: string | null
    channel?: string | null
    title: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean
    status?: string
    created_at?: Date | string
    sent_at?: Date | string | null
    read_at?: Date | string | null
  }

  export type NotificationUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SuperAdminScalarRelationFilter = {
    is?: SuperAdminWhereInput
    isNot?: SuperAdminWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    add_by?: SortOrder
    privilege?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
    add_by?: SortOrder
    privilege?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    add_by?: SortOrder
    privilege?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    add_by?: SortOrder
    privilege?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
    add_by?: SortOrder
    privilege?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommercialCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
  }

  export type CommercialAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CommercialMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
  }

  export type CommercialMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
  }

  export type CommercialSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeciderCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
  }

  export type DeciderAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeciderMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
  }

  export type DeciderMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
  }

  export type DeciderSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DispositiveScalarRelationFilter = {
    is?: DispositiveWhereInput
    isNot?: DispositiveWhereInput
  }

  export type MaintainerNullableScalarRelationFilter = {
    is?: MaintainerWhereInput | null
    isNot?: MaintainerWhereInput | null
  }

  export type DispoIssueCountOrderByAggregateInput = {
    id?: SortOrder
    dispositiveId?: SortOrder
    description?: SortOrder
    date?: SortOrder
    status?: SortOrder
    maintainerId?: SortOrder
  }

  export type DispoIssueAvgOrderByAggregateInput = {
    id?: SortOrder
    dispositiveId?: SortOrder
    maintainerId?: SortOrder
  }

  export type DispoIssueMaxOrderByAggregateInput = {
    id?: SortOrder
    dispositiveId?: SortOrder
    description?: SortOrder
    date?: SortOrder
    status?: SortOrder
    maintainerId?: SortOrder
  }

  export type DispoIssueMinOrderByAggregateInput = {
    id?: SortOrder
    dispositiveId?: SortOrder
    description?: SortOrder
    date?: SortOrder
    status?: SortOrder
    maintainerId?: SortOrder
  }

  export type DispoIssueSumOrderByAggregateInput = {
    id?: SortOrder
    dispositiveId?: SortOrder
    maintainerId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DispoIssueListRelationFilter = {
    every?: DispoIssueWhereInput
    some?: DispoIssueWhereInput
    none?: DispoIssueWhereInput
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type InterventionListRelationFilter = {
    every?: InterventionWhereInput
    some?: InterventionWhereInput
    none?: InterventionWhereInput
  }

  export type ProductTransactionListRelationFilter = {
    every?: ProductTransactionWhereInput
    some?: ProductTransactionWhereInput
    none?: ProductTransactionWhereInput
  }

  export type DispoIssueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterventionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DispositiveCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    initial_state?: SortOrder
    MAC?: SortOrder
    state?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DispositiveAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
  }

  export type DispositiveMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    initial_state?: SortOrder
    MAC?: SortOrder
    state?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DispositiveMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    initial_state?: SortOrder
    MAC?: SortOrder
    state?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DispositiveSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    product_id?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HelperCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
  }

  export type HelperAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HelperMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
  }

  export type HelperMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
  }

  export type HelperSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumInterventionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionStatus | EnumInterventionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionStatusFilter<$PrismaModel> | $Enums.InterventionStatus
  }

  export type MaintainerScalarRelationFilter = {
    is?: MaintainerWhereInput
    isNot?: MaintainerWhereInput
  }

  export type InterventionReportNullableScalarRelationFilter = {
    is?: InterventionReportWhereInput | null
    isNot?: InterventionReportWhereInput | null
  }

  export type InterventionCountOrderByAggregateInput = {
    idMaintainer?: SortOrder
    description?: SortOrder
    type?: SortOrder
    end_date?: SortOrder
    start_date?: SortOrder
    id?: SortOrder
    status?: SortOrder
    idDispositive?: SortOrder
  }

  export type InterventionAvgOrderByAggregateInput = {
    idMaintainer?: SortOrder
    id?: SortOrder
    idDispositive?: SortOrder
  }

  export type InterventionMaxOrderByAggregateInput = {
    idMaintainer?: SortOrder
    description?: SortOrder
    type?: SortOrder
    end_date?: SortOrder
    start_date?: SortOrder
    id?: SortOrder
    status?: SortOrder
    idDispositive?: SortOrder
  }

  export type InterventionMinOrderByAggregateInput = {
    idMaintainer?: SortOrder
    description?: SortOrder
    type?: SortOrder
    end_date?: SortOrder
    start_date?: SortOrder
    id?: SortOrder
    status?: SortOrder
    idDispositive?: SortOrder
  }

  export type InterventionSumOrderByAggregateInput = {
    idMaintainer?: SortOrder
    id?: SortOrder
    idDispositive?: SortOrder
  }

  export type EnumInterventionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionStatus | EnumInterventionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionStatusWithAggregatesFilter<$PrismaModel> | $Enums.InterventionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterventionStatusFilter<$PrismaModel>
    _max?: NestedEnumInterventionStatusFilter<$PrismaModel>
  }

  export type MaintainerCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
  }

  export type MaintainerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MaintainerMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
  }

  export type MaintainerMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
  }

  export type MaintainerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DispositiveListRelationFilter = {
    every?: DispositiveWhereInput
    some?: DispositiveWhereInput
    none?: DispositiveWhereInput
  }

  export type ProductQuotationListRelationFilter = {
    every?: ProductQuotationWhereInput
    some?: ProductQuotationWhereInput
    none?: ProductQuotationWhereInput
  }

  export type DispositiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductQuotationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type QuotationScalarRelationFilter = {
    is?: QuotationWhereInput
    isNot?: QuotationWhereInput
  }

  export type ProductQuotationQuotation_idProduct_idCompoundUniqueInput = {
    quotation_id: number
    product_id: number
  }

  export type ProductQuotationCountOrderByAggregateInput = {
    quotation_id?: SortOrder
    product_id?: SortOrder
    count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductQuotationAvgOrderByAggregateInput = {
    quotation_id?: SortOrder
    product_id?: SortOrder
    count?: SortOrder
  }

  export type ProductQuotationMaxOrderByAggregateInput = {
    quotation_id?: SortOrder
    product_id?: SortOrder
    count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductQuotationMinOrderByAggregateInput = {
    quotation_id?: SortOrder
    product_id?: SortOrder
    count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductQuotationSumOrderByAggregateInput = {
    quotation_id?: SortOrder
    product_id?: SortOrder
    count?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type TransactionScalarRelationFilter = {
    is?: TransactionWhereInput
    isNot?: TransactionWhereInput
  }

  export type ProductTransactionTransaction_idDispositive_idCompoundUniqueInput = {
    transaction_id: number
    dispositive_id: number
  }

  export type ProductTransactionCountOrderByAggregateInput = {
    transaction_id?: SortOrder
    dispositive_id?: SortOrder
    isConfirmed?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductTransactionAvgOrderByAggregateInput = {
    transaction_id?: SortOrder
    dispositive_id?: SortOrder
  }

  export type ProductTransactionMaxOrderByAggregateInput = {
    transaction_id?: SortOrder
    dispositive_id?: SortOrder
    isConfirmed?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductTransactionMinOrderByAggregateInput = {
    transaction_id?: SortOrder
    dispositive_id?: SortOrder
    isConfirmed?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductTransactionSumOrderByAggregateInput = {
    transaction_id?: SortOrder
    dispositive_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type QuotationCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type QuotationAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type QuotationMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type QuotationMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type QuotationSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type AdminListRelationFilter = {
    every?: AdminWhereInput
    some?: AdminWhereInput
    none?: AdminWhereInput
  }

  export type AdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SuperAdminCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
  }

  export type SuperAdminAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SuperAdminMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
  }

  export type SuperAdminMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
  }

  export type SuperAdminSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CommercialScalarRelationFilter = {
    is?: CommercialWhereInput
    isNot?: CommercialWhereInput
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    commercial_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    commercial_id?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    commercial_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    commercial_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    commercial_id?: SortOrder
  }

  export type QuotationListRelationFilter = {
    every?: QuotationWhereInput
    some?: QuotationWhereInput
    none?: QuotationWhereInput
  }

  export type HelperListRelationFilter = {
    every?: HelperWhereInput
    some?: HelperWhereInput
    none?: HelperWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type QuotationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HelperOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InterventionScalarRelationFilter = {
    is?: InterventionWhereInput
    isNot?: InterventionWhereInput
  }

  export type InterventionReportCountOrderByAggregateInput = {
    id?: SortOrder
    interventionId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type InterventionReportAvgOrderByAggregateInput = {
    id?: SortOrder
    interventionId?: SortOrder
  }

  export type InterventionReportMaxOrderByAggregateInput = {
    id?: SortOrder
    interventionId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type InterventionReportMinOrderByAggregateInput = {
    id?: SortOrder
    interventionId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type InterventionReportSumOrderByAggregateInput = {
    id?: SortOrder
    interventionId?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    channel?: SortOrder
    title?: SortOrder
    message?: SortOrder
    metadata?: SortOrder
    is_read?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    sent_at?: SortOrder
    read_at?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    channel?: SortOrder
    title?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    sent_at?: SortOrder
    read_at?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    channel?: SortOrder
    title?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    sent_at?: SortOrder
    read_at?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type SuperAdminCreateNestedOneWithoutAdminInput = {
    create?: XOR<SuperAdminCreateWithoutAdminInput, SuperAdminUncheckedCreateWithoutAdminInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutAdminInput
    connect?: SuperAdminWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SuperAdminUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<SuperAdminCreateWithoutAdminInput, SuperAdminUncheckedCreateWithoutAdminInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutAdminInput
    upsert?: SuperAdminUpsertWithoutAdminInput
    connect?: SuperAdminWhereUniqueInput
    update?: XOR<XOR<SuperAdminUpdateToOneWithWhereWithoutAdminInput, SuperAdminUpdateWithoutAdminInput>, SuperAdminUncheckedUpdateWithoutAdminInput>
  }

  export type TransactionCreateNestedManyWithoutCommercialInput = {
    create?: XOR<TransactionCreateWithoutCommercialInput, TransactionUncheckedCreateWithoutCommercialInput> | TransactionCreateWithoutCommercialInput[] | TransactionUncheckedCreateWithoutCommercialInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCommercialInput | TransactionCreateOrConnectWithoutCommercialInput[]
    createMany?: TransactionCreateManyCommercialInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCommercialInput = {
    create?: XOR<TransactionCreateWithoutCommercialInput, TransactionUncheckedCreateWithoutCommercialInput> | TransactionCreateWithoutCommercialInput[] | TransactionUncheckedCreateWithoutCommercialInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCommercialInput | TransactionCreateOrConnectWithoutCommercialInput[]
    createMany?: TransactionCreateManyCommercialInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUpdateManyWithoutCommercialNestedInput = {
    create?: XOR<TransactionCreateWithoutCommercialInput, TransactionUncheckedCreateWithoutCommercialInput> | TransactionCreateWithoutCommercialInput[] | TransactionUncheckedCreateWithoutCommercialInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCommercialInput | TransactionCreateOrConnectWithoutCommercialInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCommercialInput | TransactionUpsertWithWhereUniqueWithoutCommercialInput[]
    createMany?: TransactionCreateManyCommercialInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCommercialInput | TransactionUpdateWithWhereUniqueWithoutCommercialInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCommercialInput | TransactionUpdateManyWithWhereWithoutCommercialInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCommercialNestedInput = {
    create?: XOR<TransactionCreateWithoutCommercialInput, TransactionUncheckedCreateWithoutCommercialInput> | TransactionCreateWithoutCommercialInput[] | TransactionUncheckedCreateWithoutCommercialInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCommercialInput | TransactionCreateOrConnectWithoutCommercialInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCommercialInput | TransactionUpsertWithWhereUniqueWithoutCommercialInput[]
    createMany?: TransactionCreateManyCommercialInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCommercialInput | TransactionUpdateWithWhereUniqueWithoutCommercialInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCommercialInput | TransactionUpdateManyWithWhereWithoutCommercialInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type DispositiveCreateNestedOneWithoutDispotiveIssueInput = {
    create?: XOR<DispositiveCreateWithoutDispotiveIssueInput, DispositiveUncheckedCreateWithoutDispotiveIssueInput>
    connectOrCreate?: DispositiveCreateOrConnectWithoutDispotiveIssueInput
    connect?: DispositiveWhereUniqueInput
  }

  export type MaintainerCreateNestedOneWithoutDispoIssueInput = {
    create?: XOR<MaintainerCreateWithoutDispoIssueInput, MaintainerUncheckedCreateWithoutDispoIssueInput>
    connectOrCreate?: MaintainerCreateOrConnectWithoutDispoIssueInput
    connect?: MaintainerWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DispositiveUpdateOneRequiredWithoutDispotiveIssueNestedInput = {
    create?: XOR<DispositiveCreateWithoutDispotiveIssueInput, DispositiveUncheckedCreateWithoutDispotiveIssueInput>
    connectOrCreate?: DispositiveCreateOrConnectWithoutDispotiveIssueInput
    upsert?: DispositiveUpsertWithoutDispotiveIssueInput
    connect?: DispositiveWhereUniqueInput
    update?: XOR<XOR<DispositiveUpdateToOneWithWhereWithoutDispotiveIssueInput, DispositiveUpdateWithoutDispotiveIssueInput>, DispositiveUncheckedUpdateWithoutDispotiveIssueInput>
  }

  export type MaintainerUpdateOneWithoutDispoIssueNestedInput = {
    create?: XOR<MaintainerCreateWithoutDispoIssueInput, MaintainerUncheckedCreateWithoutDispoIssueInput>
    connectOrCreate?: MaintainerCreateOrConnectWithoutDispoIssueInput
    upsert?: MaintainerUpsertWithoutDispoIssueInput
    disconnect?: MaintainerWhereInput | boolean
    delete?: MaintainerWhereInput | boolean
    connect?: MaintainerWhereUniqueInput
    update?: XOR<XOR<MaintainerUpdateToOneWithWhereWithoutDispoIssueInput, MaintainerUpdateWithoutDispoIssueInput>, MaintainerUncheckedUpdateWithoutDispoIssueInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DispoIssueCreateNestedManyWithoutDispositiveInput = {
    create?: XOR<DispoIssueCreateWithoutDispositiveInput, DispoIssueUncheckedCreateWithoutDispositiveInput> | DispoIssueCreateWithoutDispositiveInput[] | DispoIssueUncheckedCreateWithoutDispositiveInput[]
    connectOrCreate?: DispoIssueCreateOrConnectWithoutDispositiveInput | DispoIssueCreateOrConnectWithoutDispositiveInput[]
    createMany?: DispoIssueCreateManyDispositiveInputEnvelope
    connect?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
  }

  export type ProductCreateNestedOneWithoutDispositiveInput = {
    create?: XOR<ProductCreateWithoutDispositiveInput, ProductUncheckedCreateWithoutDispositiveInput>
    connectOrCreate?: ProductCreateOrConnectWithoutDispositiveInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDispositiveInput = {
    create?: XOR<UserCreateWithoutDispositiveInput, UserUncheckedCreateWithoutDispositiveInput>
    connectOrCreate?: UserCreateOrConnectWithoutDispositiveInput
    connect?: UserWhereUniqueInput
  }

  export type InterventionCreateNestedManyWithoutDispositiveInput = {
    create?: XOR<InterventionCreateWithoutDispositiveInput, InterventionUncheckedCreateWithoutDispositiveInput> | InterventionCreateWithoutDispositiveInput[] | InterventionUncheckedCreateWithoutDispositiveInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutDispositiveInput | InterventionCreateOrConnectWithoutDispositiveInput[]
    createMany?: InterventionCreateManyDispositiveInputEnvelope
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
  }

  export type ProductTransactionCreateNestedManyWithoutDispositiveInput = {
    create?: XOR<ProductTransactionCreateWithoutDispositiveInput, ProductTransactionUncheckedCreateWithoutDispositiveInput> | ProductTransactionCreateWithoutDispositiveInput[] | ProductTransactionUncheckedCreateWithoutDispositiveInput[]
    connectOrCreate?: ProductTransactionCreateOrConnectWithoutDispositiveInput | ProductTransactionCreateOrConnectWithoutDispositiveInput[]
    createMany?: ProductTransactionCreateManyDispositiveInputEnvelope
    connect?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
  }

  export type DispoIssueUncheckedCreateNestedManyWithoutDispositiveInput = {
    create?: XOR<DispoIssueCreateWithoutDispositiveInput, DispoIssueUncheckedCreateWithoutDispositiveInput> | DispoIssueCreateWithoutDispositiveInput[] | DispoIssueUncheckedCreateWithoutDispositiveInput[]
    connectOrCreate?: DispoIssueCreateOrConnectWithoutDispositiveInput | DispoIssueCreateOrConnectWithoutDispositiveInput[]
    createMany?: DispoIssueCreateManyDispositiveInputEnvelope
    connect?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
  }

  export type InterventionUncheckedCreateNestedManyWithoutDispositiveInput = {
    create?: XOR<InterventionCreateWithoutDispositiveInput, InterventionUncheckedCreateWithoutDispositiveInput> | InterventionCreateWithoutDispositiveInput[] | InterventionUncheckedCreateWithoutDispositiveInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutDispositiveInput | InterventionCreateOrConnectWithoutDispositiveInput[]
    createMany?: InterventionCreateManyDispositiveInputEnvelope
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
  }

  export type ProductTransactionUncheckedCreateNestedManyWithoutDispositiveInput = {
    create?: XOR<ProductTransactionCreateWithoutDispositiveInput, ProductTransactionUncheckedCreateWithoutDispositiveInput> | ProductTransactionCreateWithoutDispositiveInput[] | ProductTransactionUncheckedCreateWithoutDispositiveInput[]
    connectOrCreate?: ProductTransactionCreateOrConnectWithoutDispositiveInput | ProductTransactionCreateOrConnectWithoutDispositiveInput[]
    createMany?: ProductTransactionCreateManyDispositiveInputEnvelope
    connect?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
  }

  export type DispoIssueUpdateManyWithoutDispositiveNestedInput = {
    create?: XOR<DispoIssueCreateWithoutDispositiveInput, DispoIssueUncheckedCreateWithoutDispositiveInput> | DispoIssueCreateWithoutDispositiveInput[] | DispoIssueUncheckedCreateWithoutDispositiveInput[]
    connectOrCreate?: DispoIssueCreateOrConnectWithoutDispositiveInput | DispoIssueCreateOrConnectWithoutDispositiveInput[]
    upsert?: DispoIssueUpsertWithWhereUniqueWithoutDispositiveInput | DispoIssueUpsertWithWhereUniqueWithoutDispositiveInput[]
    createMany?: DispoIssueCreateManyDispositiveInputEnvelope
    set?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
    disconnect?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
    delete?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
    connect?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
    update?: DispoIssueUpdateWithWhereUniqueWithoutDispositiveInput | DispoIssueUpdateWithWhereUniqueWithoutDispositiveInput[]
    updateMany?: DispoIssueUpdateManyWithWhereWithoutDispositiveInput | DispoIssueUpdateManyWithWhereWithoutDispositiveInput[]
    deleteMany?: DispoIssueScalarWhereInput | DispoIssueScalarWhereInput[]
  }

  export type ProductUpdateOneRequiredWithoutDispositiveNestedInput = {
    create?: XOR<ProductCreateWithoutDispositiveInput, ProductUncheckedCreateWithoutDispositiveInput>
    connectOrCreate?: ProductCreateOrConnectWithoutDispositiveInput
    upsert?: ProductUpsertWithoutDispositiveInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutDispositiveInput, ProductUpdateWithoutDispositiveInput>, ProductUncheckedUpdateWithoutDispositiveInput>
  }

  export type UserUpdateOneWithoutDispositiveNestedInput = {
    create?: XOR<UserCreateWithoutDispositiveInput, UserUncheckedCreateWithoutDispositiveInput>
    connectOrCreate?: UserCreateOrConnectWithoutDispositiveInput
    upsert?: UserUpsertWithoutDispositiveInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDispositiveInput, UserUpdateWithoutDispositiveInput>, UserUncheckedUpdateWithoutDispositiveInput>
  }

  export type InterventionUpdateManyWithoutDispositiveNestedInput = {
    create?: XOR<InterventionCreateWithoutDispositiveInput, InterventionUncheckedCreateWithoutDispositiveInput> | InterventionCreateWithoutDispositiveInput[] | InterventionUncheckedCreateWithoutDispositiveInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutDispositiveInput | InterventionCreateOrConnectWithoutDispositiveInput[]
    upsert?: InterventionUpsertWithWhereUniqueWithoutDispositiveInput | InterventionUpsertWithWhereUniqueWithoutDispositiveInput[]
    createMany?: InterventionCreateManyDispositiveInputEnvelope
    set?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    disconnect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    delete?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    update?: InterventionUpdateWithWhereUniqueWithoutDispositiveInput | InterventionUpdateWithWhereUniqueWithoutDispositiveInput[]
    updateMany?: InterventionUpdateManyWithWhereWithoutDispositiveInput | InterventionUpdateManyWithWhereWithoutDispositiveInput[]
    deleteMany?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
  }

  export type ProductTransactionUpdateManyWithoutDispositiveNestedInput = {
    create?: XOR<ProductTransactionCreateWithoutDispositiveInput, ProductTransactionUncheckedCreateWithoutDispositiveInput> | ProductTransactionCreateWithoutDispositiveInput[] | ProductTransactionUncheckedCreateWithoutDispositiveInput[]
    connectOrCreate?: ProductTransactionCreateOrConnectWithoutDispositiveInput | ProductTransactionCreateOrConnectWithoutDispositiveInput[]
    upsert?: ProductTransactionUpsertWithWhereUniqueWithoutDispositiveInput | ProductTransactionUpsertWithWhereUniqueWithoutDispositiveInput[]
    createMany?: ProductTransactionCreateManyDispositiveInputEnvelope
    set?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
    disconnect?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
    delete?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
    connect?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
    update?: ProductTransactionUpdateWithWhereUniqueWithoutDispositiveInput | ProductTransactionUpdateWithWhereUniqueWithoutDispositiveInput[]
    updateMany?: ProductTransactionUpdateManyWithWhereWithoutDispositiveInput | ProductTransactionUpdateManyWithWhereWithoutDispositiveInput[]
    deleteMany?: ProductTransactionScalarWhereInput | ProductTransactionScalarWhereInput[]
  }

  export type DispoIssueUncheckedUpdateManyWithoutDispositiveNestedInput = {
    create?: XOR<DispoIssueCreateWithoutDispositiveInput, DispoIssueUncheckedCreateWithoutDispositiveInput> | DispoIssueCreateWithoutDispositiveInput[] | DispoIssueUncheckedCreateWithoutDispositiveInput[]
    connectOrCreate?: DispoIssueCreateOrConnectWithoutDispositiveInput | DispoIssueCreateOrConnectWithoutDispositiveInput[]
    upsert?: DispoIssueUpsertWithWhereUniqueWithoutDispositiveInput | DispoIssueUpsertWithWhereUniqueWithoutDispositiveInput[]
    createMany?: DispoIssueCreateManyDispositiveInputEnvelope
    set?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
    disconnect?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
    delete?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
    connect?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
    update?: DispoIssueUpdateWithWhereUniqueWithoutDispositiveInput | DispoIssueUpdateWithWhereUniqueWithoutDispositiveInput[]
    updateMany?: DispoIssueUpdateManyWithWhereWithoutDispositiveInput | DispoIssueUpdateManyWithWhereWithoutDispositiveInput[]
    deleteMany?: DispoIssueScalarWhereInput | DispoIssueScalarWhereInput[]
  }

  export type InterventionUncheckedUpdateManyWithoutDispositiveNestedInput = {
    create?: XOR<InterventionCreateWithoutDispositiveInput, InterventionUncheckedCreateWithoutDispositiveInput> | InterventionCreateWithoutDispositiveInput[] | InterventionUncheckedCreateWithoutDispositiveInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutDispositiveInput | InterventionCreateOrConnectWithoutDispositiveInput[]
    upsert?: InterventionUpsertWithWhereUniqueWithoutDispositiveInput | InterventionUpsertWithWhereUniqueWithoutDispositiveInput[]
    createMany?: InterventionCreateManyDispositiveInputEnvelope
    set?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    disconnect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    delete?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    update?: InterventionUpdateWithWhereUniqueWithoutDispositiveInput | InterventionUpdateWithWhereUniqueWithoutDispositiveInput[]
    updateMany?: InterventionUpdateManyWithWhereWithoutDispositiveInput | InterventionUpdateManyWithWhereWithoutDispositiveInput[]
    deleteMany?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
  }

  export type ProductTransactionUncheckedUpdateManyWithoutDispositiveNestedInput = {
    create?: XOR<ProductTransactionCreateWithoutDispositiveInput, ProductTransactionUncheckedCreateWithoutDispositiveInput> | ProductTransactionCreateWithoutDispositiveInput[] | ProductTransactionUncheckedCreateWithoutDispositiveInput[]
    connectOrCreate?: ProductTransactionCreateOrConnectWithoutDispositiveInput | ProductTransactionCreateOrConnectWithoutDispositiveInput[]
    upsert?: ProductTransactionUpsertWithWhereUniqueWithoutDispositiveInput | ProductTransactionUpsertWithWhereUniqueWithoutDispositiveInput[]
    createMany?: ProductTransactionCreateManyDispositiveInputEnvelope
    set?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
    disconnect?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
    delete?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
    connect?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
    update?: ProductTransactionUpdateWithWhereUniqueWithoutDispositiveInput | ProductTransactionUpdateWithWhereUniqueWithoutDispositiveInput[]
    updateMany?: ProductTransactionUpdateManyWithWhereWithoutDispositiveInput | ProductTransactionUpdateManyWithWhereWithoutDispositiveInput[]
    deleteMany?: ProductTransactionScalarWhereInput | ProductTransactionScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutHelperInput = {
    create?: XOR<UserCreateWithoutHelperInput, UserUncheckedCreateWithoutHelperInput> | UserCreateWithoutHelperInput[] | UserUncheckedCreateWithoutHelperInput[]
    connectOrCreate?: UserCreateOrConnectWithoutHelperInput | UserCreateOrConnectWithoutHelperInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutHelperInput = {
    create?: XOR<UserCreateWithoutHelperInput, UserUncheckedCreateWithoutHelperInput> | UserCreateWithoutHelperInput[] | UserUncheckedCreateWithoutHelperInput[]
    connectOrCreate?: UserCreateOrConnectWithoutHelperInput | UserCreateOrConnectWithoutHelperInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutHelperNestedInput = {
    create?: XOR<UserCreateWithoutHelperInput, UserUncheckedCreateWithoutHelperInput> | UserCreateWithoutHelperInput[] | UserUncheckedCreateWithoutHelperInput[]
    connectOrCreate?: UserCreateOrConnectWithoutHelperInput | UserCreateOrConnectWithoutHelperInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutHelperInput | UserUpsertWithWhereUniqueWithoutHelperInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutHelperInput | UserUpdateWithWhereUniqueWithoutHelperInput[]
    updateMany?: UserUpdateManyWithWhereWithoutHelperInput | UserUpdateManyWithWhereWithoutHelperInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutHelperNestedInput = {
    create?: XOR<UserCreateWithoutHelperInput, UserUncheckedCreateWithoutHelperInput> | UserCreateWithoutHelperInput[] | UserUncheckedCreateWithoutHelperInput[]
    connectOrCreate?: UserCreateOrConnectWithoutHelperInput | UserCreateOrConnectWithoutHelperInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutHelperInput | UserUpsertWithWhereUniqueWithoutHelperInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutHelperInput | UserUpdateWithWhereUniqueWithoutHelperInput[]
    updateMany?: UserUpdateManyWithWhereWithoutHelperInput | UserUpdateManyWithWhereWithoutHelperInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DispositiveCreateNestedOneWithoutInterventionInput = {
    create?: XOR<DispositiveCreateWithoutInterventionInput, DispositiveUncheckedCreateWithoutInterventionInput>
    connectOrCreate?: DispositiveCreateOrConnectWithoutInterventionInput
    connect?: DispositiveWhereUniqueInput
  }

  export type MaintainerCreateNestedOneWithoutInterventionInput = {
    create?: XOR<MaintainerCreateWithoutInterventionInput, MaintainerUncheckedCreateWithoutInterventionInput>
    connectOrCreate?: MaintainerCreateOrConnectWithoutInterventionInput
    connect?: MaintainerWhereUniqueInput
  }

  export type InterventionReportCreateNestedOneWithoutInterventionInput = {
    create?: XOR<InterventionReportCreateWithoutInterventionInput, InterventionReportUncheckedCreateWithoutInterventionInput>
    connectOrCreate?: InterventionReportCreateOrConnectWithoutInterventionInput
    connect?: InterventionReportWhereUniqueInput
  }

  export type InterventionReportUncheckedCreateNestedOneWithoutInterventionInput = {
    create?: XOR<InterventionReportCreateWithoutInterventionInput, InterventionReportUncheckedCreateWithoutInterventionInput>
    connectOrCreate?: InterventionReportCreateOrConnectWithoutInterventionInput
    connect?: InterventionReportWhereUniqueInput
  }

  export type EnumInterventionStatusFieldUpdateOperationsInput = {
    set?: $Enums.InterventionStatus
  }

  export type DispositiveUpdateOneRequiredWithoutInterventionNestedInput = {
    create?: XOR<DispositiveCreateWithoutInterventionInput, DispositiveUncheckedCreateWithoutInterventionInput>
    connectOrCreate?: DispositiveCreateOrConnectWithoutInterventionInput
    upsert?: DispositiveUpsertWithoutInterventionInput
    connect?: DispositiveWhereUniqueInput
    update?: XOR<XOR<DispositiveUpdateToOneWithWhereWithoutInterventionInput, DispositiveUpdateWithoutInterventionInput>, DispositiveUncheckedUpdateWithoutInterventionInput>
  }

  export type MaintainerUpdateOneRequiredWithoutInterventionNestedInput = {
    create?: XOR<MaintainerCreateWithoutInterventionInput, MaintainerUncheckedCreateWithoutInterventionInput>
    connectOrCreate?: MaintainerCreateOrConnectWithoutInterventionInput
    upsert?: MaintainerUpsertWithoutInterventionInput
    connect?: MaintainerWhereUniqueInput
    update?: XOR<XOR<MaintainerUpdateToOneWithWhereWithoutInterventionInput, MaintainerUpdateWithoutInterventionInput>, MaintainerUncheckedUpdateWithoutInterventionInput>
  }

  export type InterventionReportUpdateOneWithoutInterventionNestedInput = {
    create?: XOR<InterventionReportCreateWithoutInterventionInput, InterventionReportUncheckedCreateWithoutInterventionInput>
    connectOrCreate?: InterventionReportCreateOrConnectWithoutInterventionInput
    upsert?: InterventionReportUpsertWithoutInterventionInput
    disconnect?: InterventionReportWhereInput | boolean
    delete?: InterventionReportWhereInput | boolean
    connect?: InterventionReportWhereUniqueInput
    update?: XOR<XOR<InterventionReportUpdateToOneWithWhereWithoutInterventionInput, InterventionReportUpdateWithoutInterventionInput>, InterventionReportUncheckedUpdateWithoutInterventionInput>
  }

  export type InterventionReportUncheckedUpdateOneWithoutInterventionNestedInput = {
    create?: XOR<InterventionReportCreateWithoutInterventionInput, InterventionReportUncheckedCreateWithoutInterventionInput>
    connectOrCreate?: InterventionReportCreateOrConnectWithoutInterventionInput
    upsert?: InterventionReportUpsertWithoutInterventionInput
    disconnect?: InterventionReportWhereInput | boolean
    delete?: InterventionReportWhereInput | boolean
    connect?: InterventionReportWhereUniqueInput
    update?: XOR<XOR<InterventionReportUpdateToOneWithWhereWithoutInterventionInput, InterventionReportUpdateWithoutInterventionInput>, InterventionReportUncheckedUpdateWithoutInterventionInput>
  }

  export type DispoIssueCreateNestedManyWithoutMaintainerInput = {
    create?: XOR<DispoIssueCreateWithoutMaintainerInput, DispoIssueUncheckedCreateWithoutMaintainerInput> | DispoIssueCreateWithoutMaintainerInput[] | DispoIssueUncheckedCreateWithoutMaintainerInput[]
    connectOrCreate?: DispoIssueCreateOrConnectWithoutMaintainerInput | DispoIssueCreateOrConnectWithoutMaintainerInput[]
    createMany?: DispoIssueCreateManyMaintainerInputEnvelope
    connect?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
  }

  export type InterventionCreateNestedManyWithoutMaintainerInput = {
    create?: XOR<InterventionCreateWithoutMaintainerInput, InterventionUncheckedCreateWithoutMaintainerInput> | InterventionCreateWithoutMaintainerInput[] | InterventionUncheckedCreateWithoutMaintainerInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutMaintainerInput | InterventionCreateOrConnectWithoutMaintainerInput[]
    createMany?: InterventionCreateManyMaintainerInputEnvelope
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
  }

  export type DispoIssueUncheckedCreateNestedManyWithoutMaintainerInput = {
    create?: XOR<DispoIssueCreateWithoutMaintainerInput, DispoIssueUncheckedCreateWithoutMaintainerInput> | DispoIssueCreateWithoutMaintainerInput[] | DispoIssueUncheckedCreateWithoutMaintainerInput[]
    connectOrCreate?: DispoIssueCreateOrConnectWithoutMaintainerInput | DispoIssueCreateOrConnectWithoutMaintainerInput[]
    createMany?: DispoIssueCreateManyMaintainerInputEnvelope
    connect?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
  }

  export type InterventionUncheckedCreateNestedManyWithoutMaintainerInput = {
    create?: XOR<InterventionCreateWithoutMaintainerInput, InterventionUncheckedCreateWithoutMaintainerInput> | InterventionCreateWithoutMaintainerInput[] | InterventionUncheckedCreateWithoutMaintainerInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutMaintainerInput | InterventionCreateOrConnectWithoutMaintainerInput[]
    createMany?: InterventionCreateManyMaintainerInputEnvelope
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
  }

  export type DispoIssueUpdateManyWithoutMaintainerNestedInput = {
    create?: XOR<DispoIssueCreateWithoutMaintainerInput, DispoIssueUncheckedCreateWithoutMaintainerInput> | DispoIssueCreateWithoutMaintainerInput[] | DispoIssueUncheckedCreateWithoutMaintainerInput[]
    connectOrCreate?: DispoIssueCreateOrConnectWithoutMaintainerInput | DispoIssueCreateOrConnectWithoutMaintainerInput[]
    upsert?: DispoIssueUpsertWithWhereUniqueWithoutMaintainerInput | DispoIssueUpsertWithWhereUniqueWithoutMaintainerInput[]
    createMany?: DispoIssueCreateManyMaintainerInputEnvelope
    set?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
    disconnect?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
    delete?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
    connect?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
    update?: DispoIssueUpdateWithWhereUniqueWithoutMaintainerInput | DispoIssueUpdateWithWhereUniqueWithoutMaintainerInput[]
    updateMany?: DispoIssueUpdateManyWithWhereWithoutMaintainerInput | DispoIssueUpdateManyWithWhereWithoutMaintainerInput[]
    deleteMany?: DispoIssueScalarWhereInput | DispoIssueScalarWhereInput[]
  }

  export type InterventionUpdateManyWithoutMaintainerNestedInput = {
    create?: XOR<InterventionCreateWithoutMaintainerInput, InterventionUncheckedCreateWithoutMaintainerInput> | InterventionCreateWithoutMaintainerInput[] | InterventionUncheckedCreateWithoutMaintainerInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutMaintainerInput | InterventionCreateOrConnectWithoutMaintainerInput[]
    upsert?: InterventionUpsertWithWhereUniqueWithoutMaintainerInput | InterventionUpsertWithWhereUniqueWithoutMaintainerInput[]
    createMany?: InterventionCreateManyMaintainerInputEnvelope
    set?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    disconnect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    delete?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    update?: InterventionUpdateWithWhereUniqueWithoutMaintainerInput | InterventionUpdateWithWhereUniqueWithoutMaintainerInput[]
    updateMany?: InterventionUpdateManyWithWhereWithoutMaintainerInput | InterventionUpdateManyWithWhereWithoutMaintainerInput[]
    deleteMany?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
  }

  export type DispoIssueUncheckedUpdateManyWithoutMaintainerNestedInput = {
    create?: XOR<DispoIssueCreateWithoutMaintainerInput, DispoIssueUncheckedCreateWithoutMaintainerInput> | DispoIssueCreateWithoutMaintainerInput[] | DispoIssueUncheckedCreateWithoutMaintainerInput[]
    connectOrCreate?: DispoIssueCreateOrConnectWithoutMaintainerInput | DispoIssueCreateOrConnectWithoutMaintainerInput[]
    upsert?: DispoIssueUpsertWithWhereUniqueWithoutMaintainerInput | DispoIssueUpsertWithWhereUniqueWithoutMaintainerInput[]
    createMany?: DispoIssueCreateManyMaintainerInputEnvelope
    set?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
    disconnect?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
    delete?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
    connect?: DispoIssueWhereUniqueInput | DispoIssueWhereUniqueInput[]
    update?: DispoIssueUpdateWithWhereUniqueWithoutMaintainerInput | DispoIssueUpdateWithWhereUniqueWithoutMaintainerInput[]
    updateMany?: DispoIssueUpdateManyWithWhereWithoutMaintainerInput | DispoIssueUpdateManyWithWhereWithoutMaintainerInput[]
    deleteMany?: DispoIssueScalarWhereInput | DispoIssueScalarWhereInput[]
  }

  export type InterventionUncheckedUpdateManyWithoutMaintainerNestedInput = {
    create?: XOR<InterventionCreateWithoutMaintainerInput, InterventionUncheckedCreateWithoutMaintainerInput> | InterventionCreateWithoutMaintainerInput[] | InterventionUncheckedCreateWithoutMaintainerInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutMaintainerInput | InterventionCreateOrConnectWithoutMaintainerInput[]
    upsert?: InterventionUpsertWithWhereUniqueWithoutMaintainerInput | InterventionUpsertWithWhereUniqueWithoutMaintainerInput[]
    createMany?: InterventionCreateManyMaintainerInputEnvelope
    set?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    disconnect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    delete?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    update?: InterventionUpdateWithWhereUniqueWithoutMaintainerInput | InterventionUpdateWithWhereUniqueWithoutMaintainerInput[]
    updateMany?: InterventionUpdateManyWithWhereWithoutMaintainerInput | InterventionUpdateManyWithWhereWithoutMaintainerInput[]
    deleteMany?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
  }

  export type DispositiveCreateNestedManyWithoutProductInput = {
    create?: XOR<DispositiveCreateWithoutProductInput, DispositiveUncheckedCreateWithoutProductInput> | DispositiveCreateWithoutProductInput[] | DispositiveUncheckedCreateWithoutProductInput[]
    connectOrCreate?: DispositiveCreateOrConnectWithoutProductInput | DispositiveCreateOrConnectWithoutProductInput[]
    createMany?: DispositiveCreateManyProductInputEnvelope
    connect?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
  }

  export type ProductQuotationCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductQuotationCreateWithoutProductInput, ProductQuotationUncheckedCreateWithoutProductInput> | ProductQuotationCreateWithoutProductInput[] | ProductQuotationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductQuotationCreateOrConnectWithoutProductInput | ProductQuotationCreateOrConnectWithoutProductInput[]
    createMany?: ProductQuotationCreateManyProductInputEnvelope
    connect?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
  }

  export type DispositiveUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<DispositiveCreateWithoutProductInput, DispositiveUncheckedCreateWithoutProductInput> | DispositiveCreateWithoutProductInput[] | DispositiveUncheckedCreateWithoutProductInput[]
    connectOrCreate?: DispositiveCreateOrConnectWithoutProductInput | DispositiveCreateOrConnectWithoutProductInput[]
    createMany?: DispositiveCreateManyProductInputEnvelope
    connect?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
  }

  export type ProductQuotationUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductQuotationCreateWithoutProductInput, ProductQuotationUncheckedCreateWithoutProductInput> | ProductQuotationCreateWithoutProductInput[] | ProductQuotationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductQuotationCreateOrConnectWithoutProductInput | ProductQuotationCreateOrConnectWithoutProductInput[]
    createMany?: ProductQuotationCreateManyProductInputEnvelope
    connect?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DispositiveUpdateManyWithoutProductNestedInput = {
    create?: XOR<DispositiveCreateWithoutProductInput, DispositiveUncheckedCreateWithoutProductInput> | DispositiveCreateWithoutProductInput[] | DispositiveUncheckedCreateWithoutProductInput[]
    connectOrCreate?: DispositiveCreateOrConnectWithoutProductInput | DispositiveCreateOrConnectWithoutProductInput[]
    upsert?: DispositiveUpsertWithWhereUniqueWithoutProductInput | DispositiveUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: DispositiveCreateManyProductInputEnvelope
    set?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
    disconnect?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
    delete?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
    connect?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
    update?: DispositiveUpdateWithWhereUniqueWithoutProductInput | DispositiveUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: DispositiveUpdateManyWithWhereWithoutProductInput | DispositiveUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: DispositiveScalarWhereInput | DispositiveScalarWhereInput[]
  }

  export type ProductQuotationUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductQuotationCreateWithoutProductInput, ProductQuotationUncheckedCreateWithoutProductInput> | ProductQuotationCreateWithoutProductInput[] | ProductQuotationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductQuotationCreateOrConnectWithoutProductInput | ProductQuotationCreateOrConnectWithoutProductInput[]
    upsert?: ProductQuotationUpsertWithWhereUniqueWithoutProductInput | ProductQuotationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductQuotationCreateManyProductInputEnvelope
    set?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
    disconnect?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
    delete?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
    connect?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
    update?: ProductQuotationUpdateWithWhereUniqueWithoutProductInput | ProductQuotationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductQuotationUpdateManyWithWhereWithoutProductInput | ProductQuotationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductQuotationScalarWhereInput | ProductQuotationScalarWhereInput[]
  }

  export type DispositiveUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<DispositiveCreateWithoutProductInput, DispositiveUncheckedCreateWithoutProductInput> | DispositiveCreateWithoutProductInput[] | DispositiveUncheckedCreateWithoutProductInput[]
    connectOrCreate?: DispositiveCreateOrConnectWithoutProductInput | DispositiveCreateOrConnectWithoutProductInput[]
    upsert?: DispositiveUpsertWithWhereUniqueWithoutProductInput | DispositiveUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: DispositiveCreateManyProductInputEnvelope
    set?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
    disconnect?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
    delete?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
    connect?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
    update?: DispositiveUpdateWithWhereUniqueWithoutProductInput | DispositiveUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: DispositiveUpdateManyWithWhereWithoutProductInput | DispositiveUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: DispositiveScalarWhereInput | DispositiveScalarWhereInput[]
  }

  export type ProductQuotationUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductQuotationCreateWithoutProductInput, ProductQuotationUncheckedCreateWithoutProductInput> | ProductQuotationCreateWithoutProductInput[] | ProductQuotationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductQuotationCreateOrConnectWithoutProductInput | ProductQuotationCreateOrConnectWithoutProductInput[]
    upsert?: ProductQuotationUpsertWithWhereUniqueWithoutProductInput | ProductQuotationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductQuotationCreateManyProductInputEnvelope
    set?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
    disconnect?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
    delete?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
    connect?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
    update?: ProductQuotationUpdateWithWhereUniqueWithoutProductInput | ProductQuotationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductQuotationUpdateManyWithWhereWithoutProductInput | ProductQuotationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductQuotationScalarWhereInput | ProductQuotationScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutProductQuotationInput = {
    create?: XOR<ProductCreateWithoutProductQuotationInput, ProductUncheckedCreateWithoutProductQuotationInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductQuotationInput
    connect?: ProductWhereUniqueInput
  }

  export type QuotationCreateNestedOneWithoutProductQuotationInput = {
    create?: XOR<QuotationCreateWithoutProductQuotationInput, QuotationUncheckedCreateWithoutProductQuotationInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutProductQuotationInput
    connect?: QuotationWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutProductQuotationNestedInput = {
    create?: XOR<ProductCreateWithoutProductQuotationInput, ProductUncheckedCreateWithoutProductQuotationInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductQuotationInput
    upsert?: ProductUpsertWithoutProductQuotationInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductQuotationInput, ProductUpdateWithoutProductQuotationInput>, ProductUncheckedUpdateWithoutProductQuotationInput>
  }

  export type QuotationUpdateOneRequiredWithoutProductQuotationNestedInput = {
    create?: XOR<QuotationCreateWithoutProductQuotationInput, QuotationUncheckedCreateWithoutProductQuotationInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutProductQuotationInput
    upsert?: QuotationUpsertWithoutProductQuotationInput
    connect?: QuotationWhereUniqueInput
    update?: XOR<XOR<QuotationUpdateToOneWithWhereWithoutProductQuotationInput, QuotationUpdateWithoutProductQuotationInput>, QuotationUncheckedUpdateWithoutProductQuotationInput>
  }

  export type DispositiveCreateNestedOneWithoutProductTransactionInput = {
    create?: XOR<DispositiveCreateWithoutProductTransactionInput, DispositiveUncheckedCreateWithoutProductTransactionInput>
    connectOrCreate?: DispositiveCreateOrConnectWithoutProductTransactionInput
    connect?: DispositiveWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutProductTransactionInput = {
    create?: XOR<TransactionCreateWithoutProductTransactionInput, TransactionUncheckedCreateWithoutProductTransactionInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutProductTransactionInput
    connect?: TransactionWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DispositiveUpdateOneRequiredWithoutProductTransactionNestedInput = {
    create?: XOR<DispositiveCreateWithoutProductTransactionInput, DispositiveUncheckedCreateWithoutProductTransactionInput>
    connectOrCreate?: DispositiveCreateOrConnectWithoutProductTransactionInput
    upsert?: DispositiveUpsertWithoutProductTransactionInput
    connect?: DispositiveWhereUniqueInput
    update?: XOR<XOR<DispositiveUpdateToOneWithWhereWithoutProductTransactionInput, DispositiveUpdateWithoutProductTransactionInput>, DispositiveUncheckedUpdateWithoutProductTransactionInput>
  }

  export type TransactionUpdateOneRequiredWithoutProductTransactionNestedInput = {
    create?: XOR<TransactionCreateWithoutProductTransactionInput, TransactionUncheckedCreateWithoutProductTransactionInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutProductTransactionInput
    upsert?: TransactionUpsertWithoutProductTransactionInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutProductTransactionInput, TransactionUpdateWithoutProductTransactionInput>, TransactionUncheckedUpdateWithoutProductTransactionInput>
  }

  export type ProductQuotationCreateNestedManyWithoutQuotationInput = {
    create?: XOR<ProductQuotationCreateWithoutQuotationInput, ProductQuotationUncheckedCreateWithoutQuotationInput> | ProductQuotationCreateWithoutQuotationInput[] | ProductQuotationUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: ProductQuotationCreateOrConnectWithoutQuotationInput | ProductQuotationCreateOrConnectWithoutQuotationInput[]
    createMany?: ProductQuotationCreateManyQuotationInputEnvelope
    connect?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutQuotationInput = {
    create?: XOR<UserCreateWithoutQuotationInput, UserUncheckedCreateWithoutQuotationInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuotationInput
    connect?: UserWhereUniqueInput
  }

  export type ProductQuotationUncheckedCreateNestedManyWithoutQuotationInput = {
    create?: XOR<ProductQuotationCreateWithoutQuotationInput, ProductQuotationUncheckedCreateWithoutQuotationInput> | ProductQuotationCreateWithoutQuotationInput[] | ProductQuotationUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: ProductQuotationCreateOrConnectWithoutQuotationInput | ProductQuotationCreateOrConnectWithoutQuotationInput[]
    createMany?: ProductQuotationCreateManyQuotationInputEnvelope
    connect?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
  }

  export type ProductQuotationUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<ProductQuotationCreateWithoutQuotationInput, ProductQuotationUncheckedCreateWithoutQuotationInput> | ProductQuotationCreateWithoutQuotationInput[] | ProductQuotationUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: ProductQuotationCreateOrConnectWithoutQuotationInput | ProductQuotationCreateOrConnectWithoutQuotationInput[]
    upsert?: ProductQuotationUpsertWithWhereUniqueWithoutQuotationInput | ProductQuotationUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: ProductQuotationCreateManyQuotationInputEnvelope
    set?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
    disconnect?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
    delete?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
    connect?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
    update?: ProductQuotationUpdateWithWhereUniqueWithoutQuotationInput | ProductQuotationUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: ProductQuotationUpdateManyWithWhereWithoutQuotationInput | ProductQuotationUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: ProductQuotationScalarWhereInput | ProductQuotationScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutQuotationNestedInput = {
    create?: XOR<UserCreateWithoutQuotationInput, UserUncheckedCreateWithoutQuotationInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuotationInput
    upsert?: UserUpsertWithoutQuotationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuotationInput, UserUpdateWithoutQuotationInput>, UserUncheckedUpdateWithoutQuotationInput>
  }

  export type ProductQuotationUncheckedUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<ProductQuotationCreateWithoutQuotationInput, ProductQuotationUncheckedCreateWithoutQuotationInput> | ProductQuotationCreateWithoutQuotationInput[] | ProductQuotationUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: ProductQuotationCreateOrConnectWithoutQuotationInput | ProductQuotationCreateOrConnectWithoutQuotationInput[]
    upsert?: ProductQuotationUpsertWithWhereUniqueWithoutQuotationInput | ProductQuotationUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: ProductQuotationCreateManyQuotationInputEnvelope
    set?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
    disconnect?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
    delete?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
    connect?: ProductQuotationWhereUniqueInput | ProductQuotationWhereUniqueInput[]
    update?: ProductQuotationUpdateWithWhereUniqueWithoutQuotationInput | ProductQuotationUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: ProductQuotationUpdateManyWithWhereWithoutQuotationInput | ProductQuotationUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: ProductQuotationScalarWhereInput | ProductQuotationScalarWhereInput[]
  }

  export type AdminCreateNestedManyWithoutSuperAdminInput = {
    create?: XOR<AdminCreateWithoutSuperAdminInput, AdminUncheckedCreateWithoutSuperAdminInput> | AdminCreateWithoutSuperAdminInput[] | AdminUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSuperAdminInput | AdminCreateOrConnectWithoutSuperAdminInput[]
    createMany?: AdminCreateManySuperAdminInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutSuperAdminInput = {
    create?: XOR<AdminCreateWithoutSuperAdminInput, AdminUncheckedCreateWithoutSuperAdminInput> | AdminCreateWithoutSuperAdminInput[] | AdminUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSuperAdminInput | AdminCreateOrConnectWithoutSuperAdminInput[]
    createMany?: AdminCreateManySuperAdminInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type AdminUpdateManyWithoutSuperAdminNestedInput = {
    create?: XOR<AdminCreateWithoutSuperAdminInput, AdminUncheckedCreateWithoutSuperAdminInput> | AdminCreateWithoutSuperAdminInput[] | AdminUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSuperAdminInput | AdminCreateOrConnectWithoutSuperAdminInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutSuperAdminInput | AdminUpsertWithWhereUniqueWithoutSuperAdminInput[]
    createMany?: AdminCreateManySuperAdminInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutSuperAdminInput | AdminUpdateWithWhereUniqueWithoutSuperAdminInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutSuperAdminInput | AdminUpdateManyWithWhereWithoutSuperAdminInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutSuperAdminNestedInput = {
    create?: XOR<AdminCreateWithoutSuperAdminInput, AdminUncheckedCreateWithoutSuperAdminInput> | AdminCreateWithoutSuperAdminInput[] | AdminUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSuperAdminInput | AdminCreateOrConnectWithoutSuperAdminInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutSuperAdminInput | AdminUpsertWithWhereUniqueWithoutSuperAdminInput[]
    createMany?: AdminCreateManySuperAdminInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutSuperAdminInput | AdminUpdateWithWhereUniqueWithoutSuperAdminInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutSuperAdminInput | AdminUpdateManyWithWhereWithoutSuperAdminInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type ProductTransactionCreateNestedManyWithoutTransactionInput = {
    create?: XOR<ProductTransactionCreateWithoutTransactionInput, ProductTransactionUncheckedCreateWithoutTransactionInput> | ProductTransactionCreateWithoutTransactionInput[] | ProductTransactionUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ProductTransactionCreateOrConnectWithoutTransactionInput | ProductTransactionCreateOrConnectWithoutTransactionInput[]
    createMany?: ProductTransactionCreateManyTransactionInputEnvelope
    connect?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
  }

  export type CommercialCreateNestedOneWithoutTransactionInput = {
    create?: XOR<CommercialCreateWithoutTransactionInput, CommercialUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: CommercialCreateOrConnectWithoutTransactionInput
    connect?: CommercialWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionInput = {
    create?: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInput
    connect?: UserWhereUniqueInput
  }

  export type ProductTransactionUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<ProductTransactionCreateWithoutTransactionInput, ProductTransactionUncheckedCreateWithoutTransactionInput> | ProductTransactionCreateWithoutTransactionInput[] | ProductTransactionUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ProductTransactionCreateOrConnectWithoutTransactionInput | ProductTransactionCreateOrConnectWithoutTransactionInput[]
    createMany?: ProductTransactionCreateManyTransactionInputEnvelope
    connect?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
  }

  export type ProductTransactionUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<ProductTransactionCreateWithoutTransactionInput, ProductTransactionUncheckedCreateWithoutTransactionInput> | ProductTransactionCreateWithoutTransactionInput[] | ProductTransactionUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ProductTransactionCreateOrConnectWithoutTransactionInput | ProductTransactionCreateOrConnectWithoutTransactionInput[]
    upsert?: ProductTransactionUpsertWithWhereUniqueWithoutTransactionInput | ProductTransactionUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: ProductTransactionCreateManyTransactionInputEnvelope
    set?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
    disconnect?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
    delete?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
    connect?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
    update?: ProductTransactionUpdateWithWhereUniqueWithoutTransactionInput | ProductTransactionUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: ProductTransactionUpdateManyWithWhereWithoutTransactionInput | ProductTransactionUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: ProductTransactionScalarWhereInput | ProductTransactionScalarWhereInput[]
  }

  export type CommercialUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<CommercialCreateWithoutTransactionInput, CommercialUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: CommercialCreateOrConnectWithoutTransactionInput
    upsert?: CommercialUpsertWithoutTransactionInput
    connect?: CommercialWhereUniqueInput
    update?: XOR<XOR<CommercialUpdateToOneWithWhereWithoutTransactionInput, CommercialUpdateWithoutTransactionInput>, CommercialUncheckedUpdateWithoutTransactionInput>
  }

  export type UserUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInput
    upsert?: UserUpsertWithoutTransactionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionInput, UserUpdateWithoutTransactionInput>, UserUncheckedUpdateWithoutTransactionInput>
  }

  export type ProductTransactionUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<ProductTransactionCreateWithoutTransactionInput, ProductTransactionUncheckedCreateWithoutTransactionInput> | ProductTransactionCreateWithoutTransactionInput[] | ProductTransactionUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ProductTransactionCreateOrConnectWithoutTransactionInput | ProductTransactionCreateOrConnectWithoutTransactionInput[]
    upsert?: ProductTransactionUpsertWithWhereUniqueWithoutTransactionInput | ProductTransactionUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: ProductTransactionCreateManyTransactionInputEnvelope
    set?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
    disconnect?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
    delete?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
    connect?: ProductTransactionWhereUniqueInput | ProductTransactionWhereUniqueInput[]
    update?: ProductTransactionUpdateWithWhereUniqueWithoutTransactionInput | ProductTransactionUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: ProductTransactionUpdateManyWithWhereWithoutTransactionInput | ProductTransactionUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: ProductTransactionScalarWhereInput | ProductTransactionScalarWhereInput[]
  }

  export type DispositiveCreateNestedManyWithoutUserInput = {
    create?: XOR<DispositiveCreateWithoutUserInput, DispositiveUncheckedCreateWithoutUserInput> | DispositiveCreateWithoutUserInput[] | DispositiveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DispositiveCreateOrConnectWithoutUserInput | DispositiveCreateOrConnectWithoutUserInput[]
    createMany?: DispositiveCreateManyUserInputEnvelope
    connect?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
  }

  export type QuotationCreateNestedManyWithoutUserInput = {
    create?: XOR<QuotationCreateWithoutUserInput, QuotationUncheckedCreateWithoutUserInput> | QuotationCreateWithoutUserInput[] | QuotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutUserInput | QuotationCreateOrConnectWithoutUserInput[]
    createMany?: QuotationCreateManyUserInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type HelperCreateNestedManyWithoutUserInput = {
    create?: XOR<HelperCreateWithoutUserInput, HelperUncheckedCreateWithoutUserInput> | HelperCreateWithoutUserInput[] | HelperUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HelperCreateOrConnectWithoutUserInput | HelperCreateOrConnectWithoutUserInput[]
    connect?: HelperWhereUniqueInput | HelperWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type DispositiveUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DispositiveCreateWithoutUserInput, DispositiveUncheckedCreateWithoutUserInput> | DispositiveCreateWithoutUserInput[] | DispositiveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DispositiveCreateOrConnectWithoutUserInput | DispositiveCreateOrConnectWithoutUserInput[]
    createMany?: DispositiveCreateManyUserInputEnvelope
    connect?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
  }

  export type QuotationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuotationCreateWithoutUserInput, QuotationUncheckedCreateWithoutUserInput> | QuotationCreateWithoutUserInput[] | QuotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutUserInput | QuotationCreateOrConnectWithoutUserInput[]
    createMany?: QuotationCreateManyUserInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type HelperUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<HelperCreateWithoutUserInput, HelperUncheckedCreateWithoutUserInput> | HelperCreateWithoutUserInput[] | HelperUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HelperCreateOrConnectWithoutUserInput | HelperCreateOrConnectWithoutUserInput[]
    connect?: HelperWhereUniqueInput | HelperWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type DispositiveUpdateManyWithoutUserNestedInput = {
    create?: XOR<DispositiveCreateWithoutUserInput, DispositiveUncheckedCreateWithoutUserInput> | DispositiveCreateWithoutUserInput[] | DispositiveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DispositiveCreateOrConnectWithoutUserInput | DispositiveCreateOrConnectWithoutUserInput[]
    upsert?: DispositiveUpsertWithWhereUniqueWithoutUserInput | DispositiveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DispositiveCreateManyUserInputEnvelope
    set?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
    disconnect?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
    delete?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
    connect?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
    update?: DispositiveUpdateWithWhereUniqueWithoutUserInput | DispositiveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DispositiveUpdateManyWithWhereWithoutUserInput | DispositiveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DispositiveScalarWhereInput | DispositiveScalarWhereInput[]
  }

  export type QuotationUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuotationCreateWithoutUserInput, QuotationUncheckedCreateWithoutUserInput> | QuotationCreateWithoutUserInput[] | QuotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutUserInput | QuotationCreateOrConnectWithoutUserInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutUserInput | QuotationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuotationCreateManyUserInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutUserInput | QuotationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutUserInput | QuotationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type HelperUpdateManyWithoutUserNestedInput = {
    create?: XOR<HelperCreateWithoutUserInput, HelperUncheckedCreateWithoutUserInput> | HelperCreateWithoutUserInput[] | HelperUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HelperCreateOrConnectWithoutUserInput | HelperCreateOrConnectWithoutUserInput[]
    upsert?: HelperUpsertWithWhereUniqueWithoutUserInput | HelperUpsertWithWhereUniqueWithoutUserInput[]
    set?: HelperWhereUniqueInput | HelperWhereUniqueInput[]
    disconnect?: HelperWhereUniqueInput | HelperWhereUniqueInput[]
    delete?: HelperWhereUniqueInput | HelperWhereUniqueInput[]
    connect?: HelperWhereUniqueInput | HelperWhereUniqueInput[]
    update?: HelperUpdateWithWhereUniqueWithoutUserInput | HelperUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HelperUpdateManyWithWhereWithoutUserInput | HelperUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HelperScalarWhereInput | HelperScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type DispositiveUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DispositiveCreateWithoutUserInput, DispositiveUncheckedCreateWithoutUserInput> | DispositiveCreateWithoutUserInput[] | DispositiveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DispositiveCreateOrConnectWithoutUserInput | DispositiveCreateOrConnectWithoutUserInput[]
    upsert?: DispositiveUpsertWithWhereUniqueWithoutUserInput | DispositiveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DispositiveCreateManyUserInputEnvelope
    set?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
    disconnect?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
    delete?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
    connect?: DispositiveWhereUniqueInput | DispositiveWhereUniqueInput[]
    update?: DispositiveUpdateWithWhereUniqueWithoutUserInput | DispositiveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DispositiveUpdateManyWithWhereWithoutUserInput | DispositiveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DispositiveScalarWhereInput | DispositiveScalarWhereInput[]
  }

  export type QuotationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuotationCreateWithoutUserInput, QuotationUncheckedCreateWithoutUserInput> | QuotationCreateWithoutUserInput[] | QuotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutUserInput | QuotationCreateOrConnectWithoutUserInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutUserInput | QuotationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuotationCreateManyUserInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutUserInput | QuotationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutUserInput | QuotationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type HelperUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<HelperCreateWithoutUserInput, HelperUncheckedCreateWithoutUserInput> | HelperCreateWithoutUserInput[] | HelperUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HelperCreateOrConnectWithoutUserInput | HelperCreateOrConnectWithoutUserInput[]
    upsert?: HelperUpsertWithWhereUniqueWithoutUserInput | HelperUpsertWithWhereUniqueWithoutUserInput[]
    set?: HelperWhereUniqueInput | HelperWhereUniqueInput[]
    disconnect?: HelperWhereUniqueInput | HelperWhereUniqueInput[]
    delete?: HelperWhereUniqueInput | HelperWhereUniqueInput[]
    connect?: HelperWhereUniqueInput | HelperWhereUniqueInput[]
    update?: HelperUpdateWithWhereUniqueWithoutUserInput | HelperUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HelperUpdateManyWithWhereWithoutUserInput | HelperUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HelperScalarWhereInput | HelperScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type InterventionCreateNestedOneWithoutInterventionReportInput = {
    create?: XOR<InterventionCreateWithoutInterventionReportInput, InterventionUncheckedCreateWithoutInterventionReportInput>
    connectOrCreate?: InterventionCreateOrConnectWithoutInterventionReportInput
    connect?: InterventionWhereUniqueInput
  }

  export type InterventionUpdateOneRequiredWithoutInterventionReportNestedInput = {
    create?: XOR<InterventionCreateWithoutInterventionReportInput, InterventionUncheckedCreateWithoutInterventionReportInput>
    connectOrCreate?: InterventionCreateOrConnectWithoutInterventionReportInput
    upsert?: InterventionUpsertWithoutInterventionReportInput
    connect?: InterventionWhereUniqueInput
    update?: XOR<XOR<InterventionUpdateToOneWithWhereWithoutInterventionReportInput, InterventionUpdateWithoutInterventionReportInput>, InterventionUncheckedUpdateWithoutInterventionReportInput>
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationInput, UserUpdateWithoutNotificationInput>, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumInterventionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionStatus | EnumInterventionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionStatusFilter<$PrismaModel> | $Enums.InterventionStatus
  }

  export type NestedEnumInterventionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionStatus | EnumInterventionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionStatusWithAggregatesFilter<$PrismaModel> | $Enums.InterventionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterventionStatusFilter<$PrismaModel>
    _max?: NestedEnumInterventionStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type SuperAdminCreateWithoutAdminInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
  }

  export type SuperAdminUncheckedCreateWithoutAdminInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
  }

  export type SuperAdminCreateOrConnectWithoutAdminInput = {
    where: SuperAdminWhereUniqueInput
    create: XOR<SuperAdminCreateWithoutAdminInput, SuperAdminUncheckedCreateWithoutAdminInput>
  }

  export type SuperAdminUpsertWithoutAdminInput = {
    update: XOR<SuperAdminUpdateWithoutAdminInput, SuperAdminUncheckedUpdateWithoutAdminInput>
    create: XOR<SuperAdminCreateWithoutAdminInput, SuperAdminUncheckedCreateWithoutAdminInput>
    where?: SuperAdminWhereInput
  }

  export type SuperAdminUpdateToOneWithWhereWithoutAdminInput = {
    where?: SuperAdminWhereInput
    data: XOR<SuperAdminUpdateWithoutAdminInput, SuperAdminUncheckedUpdateWithoutAdminInput>
  }

  export type SuperAdminUpdateWithoutAdminInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SuperAdminUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionCreateWithoutCommercialInput = {
    created_at?: Date | string
    updated_at: Date | string
    ProductTransaction?: ProductTransactionCreateNestedManyWithoutTransactionInput
    User: UserCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCommercialInput = {
    id?: number
    user_id: number
    created_at?: Date | string
    updated_at: Date | string
    ProductTransaction?: ProductTransactionUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutCommercialInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCommercialInput, TransactionUncheckedCreateWithoutCommercialInput>
  }

  export type TransactionCreateManyCommercialInputEnvelope = {
    data: TransactionCreateManyCommercialInput | TransactionCreateManyCommercialInput[]
    skipDuplicates?: boolean
  }

  export type TransactionUpsertWithWhereUniqueWithoutCommercialInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCommercialInput, TransactionUncheckedUpdateWithoutCommercialInput>
    create: XOR<TransactionCreateWithoutCommercialInput, TransactionUncheckedCreateWithoutCommercialInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCommercialInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCommercialInput, TransactionUncheckedUpdateWithoutCommercialInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCommercialInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCommercialInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: IntFilter<"Transaction"> | number
    user_id?: IntFilter<"Transaction"> | number
    commercial_id?: IntFilter<"Transaction"> | number
    created_at?: DateTimeFilter<"Transaction"> | Date | string
    updated_at?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type DispositiveCreateWithoutDispotiveIssueInput = {
    type: string
    start_date: Date | string
    end_date: Date | string
    initial_state: string
    MAC: string
    state: string
    created_at?: Date | string
    updated_at: Date | string
    Product: ProductCreateNestedOneWithoutDispositiveInput
    User?: UserCreateNestedOneWithoutDispositiveInput
    Intervention?: InterventionCreateNestedManyWithoutDispositiveInput
    ProductTransaction?: ProductTransactionCreateNestedManyWithoutDispositiveInput
  }

  export type DispositiveUncheckedCreateWithoutDispotiveIssueInput = {
    id?: number
    type: string
    start_date: Date | string
    end_date: Date | string
    initial_state: string
    MAC: string
    state: string
    user_id?: number | null
    product_id: number
    created_at?: Date | string
    updated_at: Date | string
    Intervention?: InterventionUncheckedCreateNestedManyWithoutDispositiveInput
    ProductTransaction?: ProductTransactionUncheckedCreateNestedManyWithoutDispositiveInput
  }

  export type DispositiveCreateOrConnectWithoutDispotiveIssueInput = {
    where: DispositiveWhereUniqueInput
    create: XOR<DispositiveCreateWithoutDispotiveIssueInput, DispositiveUncheckedCreateWithoutDispotiveIssueInput>
  }

  export type MaintainerCreateWithoutDispoIssueInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    Intervention?: InterventionCreateNestedManyWithoutMaintainerInput
  }

  export type MaintainerUncheckedCreateWithoutDispoIssueInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    Intervention?: InterventionUncheckedCreateNestedManyWithoutMaintainerInput
  }

  export type MaintainerCreateOrConnectWithoutDispoIssueInput = {
    where: MaintainerWhereUniqueInput
    create: XOR<MaintainerCreateWithoutDispoIssueInput, MaintainerUncheckedCreateWithoutDispoIssueInput>
  }

  export type DispositiveUpsertWithoutDispotiveIssueInput = {
    update: XOR<DispositiveUpdateWithoutDispotiveIssueInput, DispositiveUncheckedUpdateWithoutDispotiveIssueInput>
    create: XOR<DispositiveCreateWithoutDispotiveIssueInput, DispositiveUncheckedCreateWithoutDispotiveIssueInput>
    where?: DispositiveWhereInput
  }

  export type DispositiveUpdateToOneWithWhereWithoutDispotiveIssueInput = {
    where?: DispositiveWhereInput
    data: XOR<DispositiveUpdateWithoutDispotiveIssueInput, DispositiveUncheckedUpdateWithoutDispotiveIssueInput>
  }

  export type DispositiveUpdateWithoutDispotiveIssueInput = {
    type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    initial_state?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutDispositiveNestedInput
    User?: UserUpdateOneWithoutDispositiveNestedInput
    Intervention?: InterventionUpdateManyWithoutDispositiveNestedInput
    ProductTransaction?: ProductTransactionUpdateManyWithoutDispositiveNestedInput
  }

  export type DispositiveUncheckedUpdateWithoutDispotiveIssueInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    initial_state?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    product_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Intervention?: InterventionUncheckedUpdateManyWithoutDispositiveNestedInput
    ProductTransaction?: ProductTransactionUncheckedUpdateManyWithoutDispositiveNestedInput
  }

  export type MaintainerUpsertWithoutDispoIssueInput = {
    update: XOR<MaintainerUpdateWithoutDispoIssueInput, MaintainerUncheckedUpdateWithoutDispoIssueInput>
    create: XOR<MaintainerCreateWithoutDispoIssueInput, MaintainerUncheckedCreateWithoutDispoIssueInput>
    where?: MaintainerWhereInput
  }

  export type MaintainerUpdateToOneWithWhereWithoutDispoIssueInput = {
    where?: MaintainerWhereInput
    data: XOR<MaintainerUpdateWithoutDispoIssueInput, MaintainerUncheckedUpdateWithoutDispoIssueInput>
  }

  export type MaintainerUpdateWithoutDispoIssueInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    Intervention?: InterventionUpdateManyWithoutMaintainerNestedInput
  }

  export type MaintainerUncheckedUpdateWithoutDispoIssueInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    Intervention?: InterventionUncheckedUpdateManyWithoutMaintainerNestedInput
  }

  export type DispoIssueCreateWithoutDispositiveInput = {
    description: string
    date?: Date | string
    status?: string
    Maintainer?: MaintainerCreateNestedOneWithoutDispoIssueInput
  }

  export type DispoIssueUncheckedCreateWithoutDispositiveInput = {
    id?: number
    description: string
    date?: Date | string
    status?: string
    maintainerId?: number | null
  }

  export type DispoIssueCreateOrConnectWithoutDispositiveInput = {
    where: DispoIssueWhereUniqueInput
    create: XOR<DispoIssueCreateWithoutDispositiveInput, DispoIssueUncheckedCreateWithoutDispositiveInput>
  }

  export type DispoIssueCreateManyDispositiveInputEnvelope = {
    data: DispoIssueCreateManyDispositiveInput | DispoIssueCreateManyDispositiveInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutDispositiveInput = {
    name: string
    description?: string | null
    price: number
    created_at?: Date | string
    updated_at: Date | string
    ProductQuotation?: ProductQuotationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutDispositiveInput = {
    id?: number
    name: string
    description?: string | null
    price: number
    created_at?: Date | string
    updated_at: Date | string
    ProductQuotation?: ProductQuotationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutDispositiveInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutDispositiveInput, ProductUncheckedCreateWithoutDispositiveInput>
  }

  export type UserCreateWithoutDispositiveInput = {
    email: string
    first_name: string
    last_name: string
    password: string
    phone?: string | null
    created_at?: Date | string
    Quotation?: QuotationCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    Helper?: HelperCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDispositiveInput = {
    id?: number
    email: string
    first_name: string
    last_name: string
    password: string
    phone?: string | null
    created_at?: Date | string
    Quotation?: QuotationUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    Helper?: HelperUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDispositiveInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDispositiveInput, UserUncheckedCreateWithoutDispositiveInput>
  }

  export type InterventionCreateWithoutDispositiveInput = {
    description: string
    type: string
    end_date: Date | string
    start_date?: Date | string
    status?: $Enums.InterventionStatus
    Maintainer: MaintainerCreateNestedOneWithoutInterventionInput
    InterventionReport?: InterventionReportCreateNestedOneWithoutInterventionInput
  }

  export type InterventionUncheckedCreateWithoutDispositiveInput = {
    idMaintainer: number
    description: string
    type: string
    end_date: Date | string
    start_date?: Date | string
    id?: number
    status?: $Enums.InterventionStatus
    InterventionReport?: InterventionReportUncheckedCreateNestedOneWithoutInterventionInput
  }

  export type InterventionCreateOrConnectWithoutDispositiveInput = {
    where: InterventionWhereUniqueInput
    create: XOR<InterventionCreateWithoutDispositiveInput, InterventionUncheckedCreateWithoutDispositiveInput>
  }

  export type InterventionCreateManyDispositiveInputEnvelope = {
    data: InterventionCreateManyDispositiveInput | InterventionCreateManyDispositiveInput[]
    skipDuplicates?: boolean
  }

  export type ProductTransactionCreateWithoutDispositiveInput = {
    isConfirmed?: boolean
    created_at?: Date | string
    updated_at: Date | string
    Transaction: TransactionCreateNestedOneWithoutProductTransactionInput
  }

  export type ProductTransactionUncheckedCreateWithoutDispositiveInput = {
    transaction_id: number
    isConfirmed?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ProductTransactionCreateOrConnectWithoutDispositiveInput = {
    where: ProductTransactionWhereUniqueInput
    create: XOR<ProductTransactionCreateWithoutDispositiveInput, ProductTransactionUncheckedCreateWithoutDispositiveInput>
  }

  export type ProductTransactionCreateManyDispositiveInputEnvelope = {
    data: ProductTransactionCreateManyDispositiveInput | ProductTransactionCreateManyDispositiveInput[]
    skipDuplicates?: boolean
  }

  export type DispoIssueUpsertWithWhereUniqueWithoutDispositiveInput = {
    where: DispoIssueWhereUniqueInput
    update: XOR<DispoIssueUpdateWithoutDispositiveInput, DispoIssueUncheckedUpdateWithoutDispositiveInput>
    create: XOR<DispoIssueCreateWithoutDispositiveInput, DispoIssueUncheckedCreateWithoutDispositiveInput>
  }

  export type DispoIssueUpdateWithWhereUniqueWithoutDispositiveInput = {
    where: DispoIssueWhereUniqueInput
    data: XOR<DispoIssueUpdateWithoutDispositiveInput, DispoIssueUncheckedUpdateWithoutDispositiveInput>
  }

  export type DispoIssueUpdateManyWithWhereWithoutDispositiveInput = {
    where: DispoIssueScalarWhereInput
    data: XOR<DispoIssueUpdateManyMutationInput, DispoIssueUncheckedUpdateManyWithoutDispositiveInput>
  }

  export type DispoIssueScalarWhereInput = {
    AND?: DispoIssueScalarWhereInput | DispoIssueScalarWhereInput[]
    OR?: DispoIssueScalarWhereInput[]
    NOT?: DispoIssueScalarWhereInput | DispoIssueScalarWhereInput[]
    id?: IntFilter<"DispoIssue"> | number
    dispositiveId?: IntFilter<"DispoIssue"> | number
    description?: StringFilter<"DispoIssue"> | string
    date?: DateTimeFilter<"DispoIssue"> | Date | string
    status?: StringFilter<"DispoIssue"> | string
    maintainerId?: IntNullableFilter<"DispoIssue"> | number | null
  }

  export type ProductUpsertWithoutDispositiveInput = {
    update: XOR<ProductUpdateWithoutDispositiveInput, ProductUncheckedUpdateWithoutDispositiveInput>
    create: XOR<ProductCreateWithoutDispositiveInput, ProductUncheckedCreateWithoutDispositiveInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutDispositiveInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutDispositiveInput, ProductUncheckedUpdateWithoutDispositiveInput>
  }

  export type ProductUpdateWithoutDispositiveInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductQuotation?: ProductQuotationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutDispositiveInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductQuotation?: ProductQuotationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutDispositiveInput = {
    update: XOR<UserUpdateWithoutDispositiveInput, UserUncheckedUpdateWithoutDispositiveInput>
    create: XOR<UserCreateWithoutDispositiveInput, UserUncheckedCreateWithoutDispositiveInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDispositiveInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDispositiveInput, UserUncheckedUpdateWithoutDispositiveInput>
  }

  export type UserUpdateWithoutDispositiveInput = {
    email?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Quotation?: QuotationUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    Helper?: HelperUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDispositiveInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Quotation?: QuotationUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    Helper?: HelperUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InterventionUpsertWithWhereUniqueWithoutDispositiveInput = {
    where: InterventionWhereUniqueInput
    update: XOR<InterventionUpdateWithoutDispositiveInput, InterventionUncheckedUpdateWithoutDispositiveInput>
    create: XOR<InterventionCreateWithoutDispositiveInput, InterventionUncheckedCreateWithoutDispositiveInput>
  }

  export type InterventionUpdateWithWhereUniqueWithoutDispositiveInput = {
    where: InterventionWhereUniqueInput
    data: XOR<InterventionUpdateWithoutDispositiveInput, InterventionUncheckedUpdateWithoutDispositiveInput>
  }

  export type InterventionUpdateManyWithWhereWithoutDispositiveInput = {
    where: InterventionScalarWhereInput
    data: XOR<InterventionUpdateManyMutationInput, InterventionUncheckedUpdateManyWithoutDispositiveInput>
  }

  export type InterventionScalarWhereInput = {
    AND?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
    OR?: InterventionScalarWhereInput[]
    NOT?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
    idMaintainer?: IntFilter<"Intervention"> | number
    description?: StringFilter<"Intervention"> | string
    type?: StringFilter<"Intervention"> | string
    end_date?: DateTimeFilter<"Intervention"> | Date | string
    start_date?: DateTimeFilter<"Intervention"> | Date | string
    id?: IntFilter<"Intervention"> | number
    status?: EnumInterventionStatusFilter<"Intervention"> | $Enums.InterventionStatus
    idDispositive?: IntFilter<"Intervention"> | number
  }

  export type ProductTransactionUpsertWithWhereUniqueWithoutDispositiveInput = {
    where: ProductTransactionWhereUniqueInput
    update: XOR<ProductTransactionUpdateWithoutDispositiveInput, ProductTransactionUncheckedUpdateWithoutDispositiveInput>
    create: XOR<ProductTransactionCreateWithoutDispositiveInput, ProductTransactionUncheckedCreateWithoutDispositiveInput>
  }

  export type ProductTransactionUpdateWithWhereUniqueWithoutDispositiveInput = {
    where: ProductTransactionWhereUniqueInput
    data: XOR<ProductTransactionUpdateWithoutDispositiveInput, ProductTransactionUncheckedUpdateWithoutDispositiveInput>
  }

  export type ProductTransactionUpdateManyWithWhereWithoutDispositiveInput = {
    where: ProductTransactionScalarWhereInput
    data: XOR<ProductTransactionUpdateManyMutationInput, ProductTransactionUncheckedUpdateManyWithoutDispositiveInput>
  }

  export type ProductTransactionScalarWhereInput = {
    AND?: ProductTransactionScalarWhereInput | ProductTransactionScalarWhereInput[]
    OR?: ProductTransactionScalarWhereInput[]
    NOT?: ProductTransactionScalarWhereInput | ProductTransactionScalarWhereInput[]
    transaction_id?: IntFilter<"ProductTransaction"> | number
    dispositive_id?: IntFilter<"ProductTransaction"> | number
    isConfirmed?: BoolFilter<"ProductTransaction"> | boolean
    created_at?: DateTimeFilter<"ProductTransaction"> | Date | string
    updated_at?: DateTimeFilter<"ProductTransaction"> | Date | string
  }

  export type UserCreateWithoutHelperInput = {
    email: string
    first_name: string
    last_name: string
    password: string
    phone?: string | null
    created_at?: Date | string
    Dispositive?: DispositiveCreateNestedManyWithoutUserInput
    Quotation?: QuotationCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHelperInput = {
    id?: number
    email: string
    first_name: string
    last_name: string
    password: string
    phone?: string | null
    created_at?: Date | string
    Dispositive?: DispositiveUncheckedCreateNestedManyWithoutUserInput
    Quotation?: QuotationUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHelperInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHelperInput, UserUncheckedCreateWithoutHelperInput>
  }

  export type UserUpsertWithWhereUniqueWithoutHelperInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutHelperInput, UserUncheckedUpdateWithoutHelperInput>
    create: XOR<UserCreateWithoutHelperInput, UserUncheckedCreateWithoutHelperInput>
  }

  export type UserUpdateWithWhereUniqueWithoutHelperInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutHelperInput, UserUncheckedUpdateWithoutHelperInput>
  }

  export type UserUpdateManyWithWhereWithoutHelperInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutHelperInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    first_name?: StringFilter<"User"> | string
    last_name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
  }

  export type DispositiveCreateWithoutInterventionInput = {
    type: string
    start_date: Date | string
    end_date: Date | string
    initial_state: string
    MAC: string
    state: string
    created_at?: Date | string
    updated_at: Date | string
    DispotiveIssue?: DispoIssueCreateNestedManyWithoutDispositiveInput
    Product: ProductCreateNestedOneWithoutDispositiveInput
    User?: UserCreateNestedOneWithoutDispositiveInput
    ProductTransaction?: ProductTransactionCreateNestedManyWithoutDispositiveInput
  }

  export type DispositiveUncheckedCreateWithoutInterventionInput = {
    id?: number
    type: string
    start_date: Date | string
    end_date: Date | string
    initial_state: string
    MAC: string
    state: string
    user_id?: number | null
    product_id: number
    created_at?: Date | string
    updated_at: Date | string
    DispotiveIssue?: DispoIssueUncheckedCreateNestedManyWithoutDispositiveInput
    ProductTransaction?: ProductTransactionUncheckedCreateNestedManyWithoutDispositiveInput
  }

  export type DispositiveCreateOrConnectWithoutInterventionInput = {
    where: DispositiveWhereUniqueInput
    create: XOR<DispositiveCreateWithoutInterventionInput, DispositiveUncheckedCreateWithoutInterventionInput>
  }

  export type MaintainerCreateWithoutInterventionInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    DispoIssue?: DispoIssueCreateNestedManyWithoutMaintainerInput
  }

  export type MaintainerUncheckedCreateWithoutInterventionInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    DispoIssue?: DispoIssueUncheckedCreateNestedManyWithoutMaintainerInput
  }

  export type MaintainerCreateOrConnectWithoutInterventionInput = {
    where: MaintainerWhereUniqueInput
    create: XOR<MaintainerCreateWithoutInterventionInput, MaintainerUncheckedCreateWithoutInterventionInput>
  }

  export type InterventionReportCreateWithoutInterventionInput = {
    title: string
    description: string
    created_at?: Date | string
  }

  export type InterventionReportUncheckedCreateWithoutInterventionInput = {
    id?: number
    title: string
    description: string
    created_at?: Date | string
  }

  export type InterventionReportCreateOrConnectWithoutInterventionInput = {
    where: InterventionReportWhereUniqueInput
    create: XOR<InterventionReportCreateWithoutInterventionInput, InterventionReportUncheckedCreateWithoutInterventionInput>
  }

  export type DispositiveUpsertWithoutInterventionInput = {
    update: XOR<DispositiveUpdateWithoutInterventionInput, DispositiveUncheckedUpdateWithoutInterventionInput>
    create: XOR<DispositiveCreateWithoutInterventionInput, DispositiveUncheckedCreateWithoutInterventionInput>
    where?: DispositiveWhereInput
  }

  export type DispositiveUpdateToOneWithWhereWithoutInterventionInput = {
    where?: DispositiveWhereInput
    data: XOR<DispositiveUpdateWithoutInterventionInput, DispositiveUncheckedUpdateWithoutInterventionInput>
  }

  export type DispositiveUpdateWithoutInterventionInput = {
    type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    initial_state?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    DispotiveIssue?: DispoIssueUpdateManyWithoutDispositiveNestedInput
    Product?: ProductUpdateOneRequiredWithoutDispositiveNestedInput
    User?: UserUpdateOneWithoutDispositiveNestedInput
    ProductTransaction?: ProductTransactionUpdateManyWithoutDispositiveNestedInput
  }

  export type DispositiveUncheckedUpdateWithoutInterventionInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    initial_state?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    product_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    DispotiveIssue?: DispoIssueUncheckedUpdateManyWithoutDispositiveNestedInput
    ProductTransaction?: ProductTransactionUncheckedUpdateManyWithoutDispositiveNestedInput
  }

  export type MaintainerUpsertWithoutInterventionInput = {
    update: XOR<MaintainerUpdateWithoutInterventionInput, MaintainerUncheckedUpdateWithoutInterventionInput>
    create: XOR<MaintainerCreateWithoutInterventionInput, MaintainerUncheckedCreateWithoutInterventionInput>
    where?: MaintainerWhereInput
  }

  export type MaintainerUpdateToOneWithWhereWithoutInterventionInput = {
    where?: MaintainerWhereInput
    data: XOR<MaintainerUpdateWithoutInterventionInput, MaintainerUncheckedUpdateWithoutInterventionInput>
  }

  export type MaintainerUpdateWithoutInterventionInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    DispoIssue?: DispoIssueUpdateManyWithoutMaintainerNestedInput
  }

  export type MaintainerUncheckedUpdateWithoutInterventionInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    DispoIssue?: DispoIssueUncheckedUpdateManyWithoutMaintainerNestedInput
  }

  export type InterventionReportUpsertWithoutInterventionInput = {
    update: XOR<InterventionReportUpdateWithoutInterventionInput, InterventionReportUncheckedUpdateWithoutInterventionInput>
    create: XOR<InterventionReportCreateWithoutInterventionInput, InterventionReportUncheckedCreateWithoutInterventionInput>
    where?: InterventionReportWhereInput
  }

  export type InterventionReportUpdateToOneWithWhereWithoutInterventionInput = {
    where?: InterventionReportWhereInput
    data: XOR<InterventionReportUpdateWithoutInterventionInput, InterventionReportUncheckedUpdateWithoutInterventionInput>
  }

  export type InterventionReportUpdateWithoutInterventionInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionReportUncheckedUpdateWithoutInterventionInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispoIssueCreateWithoutMaintainerInput = {
    description: string
    date?: Date | string
    status?: string
    Dispositive: DispositiveCreateNestedOneWithoutDispotiveIssueInput
  }

  export type DispoIssueUncheckedCreateWithoutMaintainerInput = {
    id?: number
    dispositiveId: number
    description: string
    date?: Date | string
    status?: string
  }

  export type DispoIssueCreateOrConnectWithoutMaintainerInput = {
    where: DispoIssueWhereUniqueInput
    create: XOR<DispoIssueCreateWithoutMaintainerInput, DispoIssueUncheckedCreateWithoutMaintainerInput>
  }

  export type DispoIssueCreateManyMaintainerInputEnvelope = {
    data: DispoIssueCreateManyMaintainerInput | DispoIssueCreateManyMaintainerInput[]
    skipDuplicates?: boolean
  }

  export type InterventionCreateWithoutMaintainerInput = {
    description: string
    type: string
    end_date: Date | string
    start_date?: Date | string
    status?: $Enums.InterventionStatus
    Dispositive: DispositiveCreateNestedOneWithoutInterventionInput
    InterventionReport?: InterventionReportCreateNestedOneWithoutInterventionInput
  }

  export type InterventionUncheckedCreateWithoutMaintainerInput = {
    description: string
    type: string
    end_date: Date | string
    start_date?: Date | string
    id?: number
    status?: $Enums.InterventionStatus
    idDispositive: number
    InterventionReport?: InterventionReportUncheckedCreateNestedOneWithoutInterventionInput
  }

  export type InterventionCreateOrConnectWithoutMaintainerInput = {
    where: InterventionWhereUniqueInput
    create: XOR<InterventionCreateWithoutMaintainerInput, InterventionUncheckedCreateWithoutMaintainerInput>
  }

  export type InterventionCreateManyMaintainerInputEnvelope = {
    data: InterventionCreateManyMaintainerInput | InterventionCreateManyMaintainerInput[]
    skipDuplicates?: boolean
  }

  export type DispoIssueUpsertWithWhereUniqueWithoutMaintainerInput = {
    where: DispoIssueWhereUniqueInput
    update: XOR<DispoIssueUpdateWithoutMaintainerInput, DispoIssueUncheckedUpdateWithoutMaintainerInput>
    create: XOR<DispoIssueCreateWithoutMaintainerInput, DispoIssueUncheckedCreateWithoutMaintainerInput>
  }

  export type DispoIssueUpdateWithWhereUniqueWithoutMaintainerInput = {
    where: DispoIssueWhereUniqueInput
    data: XOR<DispoIssueUpdateWithoutMaintainerInput, DispoIssueUncheckedUpdateWithoutMaintainerInput>
  }

  export type DispoIssueUpdateManyWithWhereWithoutMaintainerInput = {
    where: DispoIssueScalarWhereInput
    data: XOR<DispoIssueUpdateManyMutationInput, DispoIssueUncheckedUpdateManyWithoutMaintainerInput>
  }

  export type InterventionUpsertWithWhereUniqueWithoutMaintainerInput = {
    where: InterventionWhereUniqueInput
    update: XOR<InterventionUpdateWithoutMaintainerInput, InterventionUncheckedUpdateWithoutMaintainerInput>
    create: XOR<InterventionCreateWithoutMaintainerInput, InterventionUncheckedCreateWithoutMaintainerInput>
  }

  export type InterventionUpdateWithWhereUniqueWithoutMaintainerInput = {
    where: InterventionWhereUniqueInput
    data: XOR<InterventionUpdateWithoutMaintainerInput, InterventionUncheckedUpdateWithoutMaintainerInput>
  }

  export type InterventionUpdateManyWithWhereWithoutMaintainerInput = {
    where: InterventionScalarWhereInput
    data: XOR<InterventionUpdateManyMutationInput, InterventionUncheckedUpdateManyWithoutMaintainerInput>
  }

  export type DispositiveCreateWithoutProductInput = {
    type: string
    start_date: Date | string
    end_date: Date | string
    initial_state: string
    MAC: string
    state: string
    created_at?: Date | string
    updated_at: Date | string
    DispotiveIssue?: DispoIssueCreateNestedManyWithoutDispositiveInput
    User?: UserCreateNestedOneWithoutDispositiveInput
    Intervention?: InterventionCreateNestedManyWithoutDispositiveInput
    ProductTransaction?: ProductTransactionCreateNestedManyWithoutDispositiveInput
  }

  export type DispositiveUncheckedCreateWithoutProductInput = {
    id?: number
    type: string
    start_date: Date | string
    end_date: Date | string
    initial_state: string
    MAC: string
    state: string
    user_id?: number | null
    created_at?: Date | string
    updated_at: Date | string
    DispotiveIssue?: DispoIssueUncheckedCreateNestedManyWithoutDispositiveInput
    Intervention?: InterventionUncheckedCreateNestedManyWithoutDispositiveInput
    ProductTransaction?: ProductTransactionUncheckedCreateNestedManyWithoutDispositiveInput
  }

  export type DispositiveCreateOrConnectWithoutProductInput = {
    where: DispositiveWhereUniqueInput
    create: XOR<DispositiveCreateWithoutProductInput, DispositiveUncheckedCreateWithoutProductInput>
  }

  export type DispositiveCreateManyProductInputEnvelope = {
    data: DispositiveCreateManyProductInput | DispositiveCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductQuotationCreateWithoutProductInput = {
    count: number
    created_at?: Date | string
    updated_at: Date | string
    Quotation: QuotationCreateNestedOneWithoutProductQuotationInput
  }

  export type ProductQuotationUncheckedCreateWithoutProductInput = {
    quotation_id: number
    count: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ProductQuotationCreateOrConnectWithoutProductInput = {
    where: ProductQuotationWhereUniqueInput
    create: XOR<ProductQuotationCreateWithoutProductInput, ProductQuotationUncheckedCreateWithoutProductInput>
  }

  export type ProductQuotationCreateManyProductInputEnvelope = {
    data: ProductQuotationCreateManyProductInput | ProductQuotationCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type DispositiveUpsertWithWhereUniqueWithoutProductInput = {
    where: DispositiveWhereUniqueInput
    update: XOR<DispositiveUpdateWithoutProductInput, DispositiveUncheckedUpdateWithoutProductInput>
    create: XOR<DispositiveCreateWithoutProductInput, DispositiveUncheckedCreateWithoutProductInput>
  }

  export type DispositiveUpdateWithWhereUniqueWithoutProductInput = {
    where: DispositiveWhereUniqueInput
    data: XOR<DispositiveUpdateWithoutProductInput, DispositiveUncheckedUpdateWithoutProductInput>
  }

  export type DispositiveUpdateManyWithWhereWithoutProductInput = {
    where: DispositiveScalarWhereInput
    data: XOR<DispositiveUpdateManyMutationInput, DispositiveUncheckedUpdateManyWithoutProductInput>
  }

  export type DispositiveScalarWhereInput = {
    AND?: DispositiveScalarWhereInput | DispositiveScalarWhereInput[]
    OR?: DispositiveScalarWhereInput[]
    NOT?: DispositiveScalarWhereInput | DispositiveScalarWhereInput[]
    id?: IntFilter<"Dispositive"> | number
    type?: StringFilter<"Dispositive"> | string
    start_date?: DateTimeFilter<"Dispositive"> | Date | string
    end_date?: DateTimeFilter<"Dispositive"> | Date | string
    initial_state?: StringFilter<"Dispositive"> | string
    MAC?: StringFilter<"Dispositive"> | string
    state?: StringFilter<"Dispositive"> | string
    user_id?: IntNullableFilter<"Dispositive"> | number | null
    product_id?: IntFilter<"Dispositive"> | number
    created_at?: DateTimeFilter<"Dispositive"> | Date | string
    updated_at?: DateTimeFilter<"Dispositive"> | Date | string
  }

  export type ProductQuotationUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductQuotationWhereUniqueInput
    update: XOR<ProductQuotationUpdateWithoutProductInput, ProductQuotationUncheckedUpdateWithoutProductInput>
    create: XOR<ProductQuotationCreateWithoutProductInput, ProductQuotationUncheckedCreateWithoutProductInput>
  }

  export type ProductQuotationUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductQuotationWhereUniqueInput
    data: XOR<ProductQuotationUpdateWithoutProductInput, ProductQuotationUncheckedUpdateWithoutProductInput>
  }

  export type ProductQuotationUpdateManyWithWhereWithoutProductInput = {
    where: ProductQuotationScalarWhereInput
    data: XOR<ProductQuotationUpdateManyMutationInput, ProductQuotationUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductQuotationScalarWhereInput = {
    AND?: ProductQuotationScalarWhereInput | ProductQuotationScalarWhereInput[]
    OR?: ProductQuotationScalarWhereInput[]
    NOT?: ProductQuotationScalarWhereInput | ProductQuotationScalarWhereInput[]
    quotation_id?: IntFilter<"ProductQuotation"> | number
    product_id?: IntFilter<"ProductQuotation"> | number
    count?: IntFilter<"ProductQuotation"> | number
    created_at?: DateTimeFilter<"ProductQuotation"> | Date | string
    updated_at?: DateTimeFilter<"ProductQuotation"> | Date | string
  }

  export type ProductCreateWithoutProductQuotationInput = {
    name: string
    description?: string | null
    price: number
    created_at?: Date | string
    updated_at: Date | string
    Dispositive?: DispositiveCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductQuotationInput = {
    id?: number
    name: string
    description?: string | null
    price: number
    created_at?: Date | string
    updated_at: Date | string
    Dispositive?: DispositiveUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductQuotationInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductQuotationInput, ProductUncheckedCreateWithoutProductQuotationInput>
  }

  export type QuotationCreateWithoutProductQuotationInput = {
    created_at?: Date | string
    updated_at: Date | string
    User: UserCreateNestedOneWithoutQuotationInput
  }

  export type QuotationUncheckedCreateWithoutProductQuotationInput = {
    id?: number
    user_id: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type QuotationCreateOrConnectWithoutProductQuotationInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutProductQuotationInput, QuotationUncheckedCreateWithoutProductQuotationInput>
  }

  export type ProductUpsertWithoutProductQuotationInput = {
    update: XOR<ProductUpdateWithoutProductQuotationInput, ProductUncheckedUpdateWithoutProductQuotationInput>
    create: XOR<ProductCreateWithoutProductQuotationInput, ProductUncheckedCreateWithoutProductQuotationInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductQuotationInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductQuotationInput, ProductUncheckedUpdateWithoutProductQuotationInput>
  }

  export type ProductUpdateWithoutProductQuotationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Dispositive?: DispositiveUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductQuotationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Dispositive?: DispositiveUncheckedUpdateManyWithoutProductNestedInput
  }

  export type QuotationUpsertWithoutProductQuotationInput = {
    update: XOR<QuotationUpdateWithoutProductQuotationInput, QuotationUncheckedUpdateWithoutProductQuotationInput>
    create: XOR<QuotationCreateWithoutProductQuotationInput, QuotationUncheckedCreateWithoutProductQuotationInput>
    where?: QuotationWhereInput
  }

  export type QuotationUpdateToOneWithWhereWithoutProductQuotationInput = {
    where?: QuotationWhereInput
    data: XOR<QuotationUpdateWithoutProductQuotationInput, QuotationUncheckedUpdateWithoutProductQuotationInput>
  }

  export type QuotationUpdateWithoutProductQuotationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateWithoutProductQuotationInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispositiveCreateWithoutProductTransactionInput = {
    type: string
    start_date: Date | string
    end_date: Date | string
    initial_state: string
    MAC: string
    state: string
    created_at?: Date | string
    updated_at: Date | string
    DispotiveIssue?: DispoIssueCreateNestedManyWithoutDispositiveInput
    Product: ProductCreateNestedOneWithoutDispositiveInput
    User?: UserCreateNestedOneWithoutDispositiveInput
    Intervention?: InterventionCreateNestedManyWithoutDispositiveInput
  }

  export type DispositiveUncheckedCreateWithoutProductTransactionInput = {
    id?: number
    type: string
    start_date: Date | string
    end_date: Date | string
    initial_state: string
    MAC: string
    state: string
    user_id?: number | null
    product_id: number
    created_at?: Date | string
    updated_at: Date | string
    DispotiveIssue?: DispoIssueUncheckedCreateNestedManyWithoutDispositiveInput
    Intervention?: InterventionUncheckedCreateNestedManyWithoutDispositiveInput
  }

  export type DispositiveCreateOrConnectWithoutProductTransactionInput = {
    where: DispositiveWhereUniqueInput
    create: XOR<DispositiveCreateWithoutProductTransactionInput, DispositiveUncheckedCreateWithoutProductTransactionInput>
  }

  export type TransactionCreateWithoutProductTransactionInput = {
    created_at?: Date | string
    updated_at: Date | string
    Commercial: CommercialCreateNestedOneWithoutTransactionInput
    User: UserCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutProductTransactionInput = {
    id?: number
    user_id: number
    commercial_id: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type TransactionCreateOrConnectWithoutProductTransactionInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutProductTransactionInput, TransactionUncheckedCreateWithoutProductTransactionInput>
  }

  export type DispositiveUpsertWithoutProductTransactionInput = {
    update: XOR<DispositiveUpdateWithoutProductTransactionInput, DispositiveUncheckedUpdateWithoutProductTransactionInput>
    create: XOR<DispositiveCreateWithoutProductTransactionInput, DispositiveUncheckedCreateWithoutProductTransactionInput>
    where?: DispositiveWhereInput
  }

  export type DispositiveUpdateToOneWithWhereWithoutProductTransactionInput = {
    where?: DispositiveWhereInput
    data: XOR<DispositiveUpdateWithoutProductTransactionInput, DispositiveUncheckedUpdateWithoutProductTransactionInput>
  }

  export type DispositiveUpdateWithoutProductTransactionInput = {
    type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    initial_state?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    DispotiveIssue?: DispoIssueUpdateManyWithoutDispositiveNestedInput
    Product?: ProductUpdateOneRequiredWithoutDispositiveNestedInput
    User?: UserUpdateOneWithoutDispositiveNestedInput
    Intervention?: InterventionUpdateManyWithoutDispositiveNestedInput
  }

  export type DispositiveUncheckedUpdateWithoutProductTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    initial_state?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    product_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    DispotiveIssue?: DispoIssueUncheckedUpdateManyWithoutDispositiveNestedInput
    Intervention?: InterventionUncheckedUpdateManyWithoutDispositiveNestedInput
  }

  export type TransactionUpsertWithoutProductTransactionInput = {
    update: XOR<TransactionUpdateWithoutProductTransactionInput, TransactionUncheckedUpdateWithoutProductTransactionInput>
    create: XOR<TransactionCreateWithoutProductTransactionInput, TransactionUncheckedCreateWithoutProductTransactionInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutProductTransactionInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutProductTransactionInput, TransactionUncheckedUpdateWithoutProductTransactionInput>
  }

  export type TransactionUpdateWithoutProductTransactionInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Commercial?: CommercialUpdateOneRequiredWithoutTransactionNestedInput
    User?: UserUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutProductTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    commercial_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductQuotationCreateWithoutQuotationInput = {
    count: number
    created_at?: Date | string
    updated_at: Date | string
    Product: ProductCreateNestedOneWithoutProductQuotationInput
  }

  export type ProductQuotationUncheckedCreateWithoutQuotationInput = {
    product_id: number
    count: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ProductQuotationCreateOrConnectWithoutQuotationInput = {
    where: ProductQuotationWhereUniqueInput
    create: XOR<ProductQuotationCreateWithoutQuotationInput, ProductQuotationUncheckedCreateWithoutQuotationInput>
  }

  export type ProductQuotationCreateManyQuotationInputEnvelope = {
    data: ProductQuotationCreateManyQuotationInput | ProductQuotationCreateManyQuotationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutQuotationInput = {
    email: string
    first_name: string
    last_name: string
    password: string
    phone?: string | null
    created_at?: Date | string
    Dispositive?: DispositiveCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    Helper?: HelperCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuotationInput = {
    id?: number
    email: string
    first_name: string
    last_name: string
    password: string
    phone?: string | null
    created_at?: Date | string
    Dispositive?: DispositiveUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    Helper?: HelperUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuotationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuotationInput, UserUncheckedCreateWithoutQuotationInput>
  }

  export type ProductQuotationUpsertWithWhereUniqueWithoutQuotationInput = {
    where: ProductQuotationWhereUniqueInput
    update: XOR<ProductQuotationUpdateWithoutQuotationInput, ProductQuotationUncheckedUpdateWithoutQuotationInput>
    create: XOR<ProductQuotationCreateWithoutQuotationInput, ProductQuotationUncheckedCreateWithoutQuotationInput>
  }

  export type ProductQuotationUpdateWithWhereUniqueWithoutQuotationInput = {
    where: ProductQuotationWhereUniqueInput
    data: XOR<ProductQuotationUpdateWithoutQuotationInput, ProductQuotationUncheckedUpdateWithoutQuotationInput>
  }

  export type ProductQuotationUpdateManyWithWhereWithoutQuotationInput = {
    where: ProductQuotationScalarWhereInput
    data: XOR<ProductQuotationUpdateManyMutationInput, ProductQuotationUncheckedUpdateManyWithoutQuotationInput>
  }

  export type UserUpsertWithoutQuotationInput = {
    update: XOR<UserUpdateWithoutQuotationInput, UserUncheckedUpdateWithoutQuotationInput>
    create: XOR<UserCreateWithoutQuotationInput, UserUncheckedCreateWithoutQuotationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuotationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuotationInput, UserUncheckedUpdateWithoutQuotationInput>
  }

  export type UserUpdateWithoutQuotationInput = {
    email?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Dispositive?: DispositiveUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    Helper?: HelperUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuotationInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Dispositive?: DispositiveUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    Helper?: HelperUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AdminCreateWithoutSuperAdminInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    privilege: number
  }

  export type AdminUncheckedCreateWithoutSuperAdminInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    privilege: number
  }

  export type AdminCreateOrConnectWithoutSuperAdminInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutSuperAdminInput, AdminUncheckedCreateWithoutSuperAdminInput>
  }

  export type AdminCreateManySuperAdminInputEnvelope = {
    data: AdminCreateManySuperAdminInput | AdminCreateManySuperAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithWhereUniqueWithoutSuperAdminInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutSuperAdminInput, AdminUncheckedUpdateWithoutSuperAdminInput>
    create: XOR<AdminCreateWithoutSuperAdminInput, AdminUncheckedCreateWithoutSuperAdminInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutSuperAdminInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutSuperAdminInput, AdminUncheckedUpdateWithoutSuperAdminInput>
  }

  export type AdminUpdateManyWithWhereWithoutSuperAdminInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutSuperAdminInput>
  }

  export type AdminScalarWhereInput = {
    AND?: AdminScalarWhereInput | AdminScalarWhereInput[]
    OR?: AdminScalarWhereInput[]
    NOT?: AdminScalarWhereInput | AdminScalarWhereInput[]
    id?: IntFilter<"Admin"> | number
    first_name?: StringFilter<"Admin"> | string
    last_name?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    phone?: StringNullableFilter<"Admin"> | string | null
    add_by?: IntFilter<"Admin"> | number
    privilege?: IntFilter<"Admin"> | number
  }

  export type ProductTransactionCreateWithoutTransactionInput = {
    isConfirmed?: boolean
    created_at?: Date | string
    updated_at: Date | string
    Dispositive: DispositiveCreateNestedOneWithoutProductTransactionInput
  }

  export type ProductTransactionUncheckedCreateWithoutTransactionInput = {
    dispositive_id: number
    isConfirmed?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ProductTransactionCreateOrConnectWithoutTransactionInput = {
    where: ProductTransactionWhereUniqueInput
    create: XOR<ProductTransactionCreateWithoutTransactionInput, ProductTransactionUncheckedCreateWithoutTransactionInput>
  }

  export type ProductTransactionCreateManyTransactionInputEnvelope = {
    data: ProductTransactionCreateManyTransactionInput | ProductTransactionCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type CommercialCreateWithoutTransactionInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
  }

  export type CommercialUncheckedCreateWithoutTransactionInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
  }

  export type CommercialCreateOrConnectWithoutTransactionInput = {
    where: CommercialWhereUniqueInput
    create: XOR<CommercialCreateWithoutTransactionInput, CommercialUncheckedCreateWithoutTransactionInput>
  }

  export type UserCreateWithoutTransactionInput = {
    email: string
    first_name: string
    last_name: string
    password: string
    phone?: string | null
    created_at?: Date | string
    Dispositive?: DispositiveCreateNestedManyWithoutUserInput
    Quotation?: QuotationCreateNestedManyWithoutUserInput
    Helper?: HelperCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionInput = {
    id?: number
    email: string
    first_name: string
    last_name: string
    password: string
    phone?: string | null
    created_at?: Date | string
    Dispositive?: DispositiveUncheckedCreateNestedManyWithoutUserInput
    Quotation?: QuotationUncheckedCreateNestedManyWithoutUserInput
    Helper?: HelperUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
  }

  export type ProductTransactionUpsertWithWhereUniqueWithoutTransactionInput = {
    where: ProductTransactionWhereUniqueInput
    update: XOR<ProductTransactionUpdateWithoutTransactionInput, ProductTransactionUncheckedUpdateWithoutTransactionInput>
    create: XOR<ProductTransactionCreateWithoutTransactionInput, ProductTransactionUncheckedCreateWithoutTransactionInput>
  }

  export type ProductTransactionUpdateWithWhereUniqueWithoutTransactionInput = {
    where: ProductTransactionWhereUniqueInput
    data: XOR<ProductTransactionUpdateWithoutTransactionInput, ProductTransactionUncheckedUpdateWithoutTransactionInput>
  }

  export type ProductTransactionUpdateManyWithWhereWithoutTransactionInput = {
    where: ProductTransactionScalarWhereInput
    data: XOR<ProductTransactionUpdateManyMutationInput, ProductTransactionUncheckedUpdateManyWithoutTransactionInput>
  }

  export type CommercialUpsertWithoutTransactionInput = {
    update: XOR<CommercialUpdateWithoutTransactionInput, CommercialUncheckedUpdateWithoutTransactionInput>
    create: XOR<CommercialCreateWithoutTransactionInput, CommercialUncheckedCreateWithoutTransactionInput>
    where?: CommercialWhereInput
  }

  export type CommercialUpdateToOneWithWhereWithoutTransactionInput = {
    where?: CommercialWhereInput
    data: XOR<CommercialUpdateWithoutTransactionInput, CommercialUncheckedUpdateWithoutTransactionInput>
  }

  export type CommercialUpdateWithoutTransactionInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommercialUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutTransactionInput = {
    update: XOR<UserUpdateWithoutTransactionInput, UserUncheckedUpdateWithoutTransactionInput>
    create: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionInput, UserUncheckedUpdateWithoutTransactionInput>
  }

  export type UserUpdateWithoutTransactionInput = {
    email?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Dispositive?: DispositiveUpdateManyWithoutUserNestedInput
    Quotation?: QuotationUpdateManyWithoutUserNestedInput
    Helper?: HelperUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Dispositive?: DispositiveUncheckedUpdateManyWithoutUserNestedInput
    Quotation?: QuotationUncheckedUpdateManyWithoutUserNestedInput
    Helper?: HelperUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DispositiveCreateWithoutUserInput = {
    type: string
    start_date: Date | string
    end_date: Date | string
    initial_state: string
    MAC: string
    state: string
    created_at?: Date | string
    updated_at: Date | string
    DispotiveIssue?: DispoIssueCreateNestedManyWithoutDispositiveInput
    Product: ProductCreateNestedOneWithoutDispositiveInput
    Intervention?: InterventionCreateNestedManyWithoutDispositiveInput
    ProductTransaction?: ProductTransactionCreateNestedManyWithoutDispositiveInput
  }

  export type DispositiveUncheckedCreateWithoutUserInput = {
    id?: number
    type: string
    start_date: Date | string
    end_date: Date | string
    initial_state: string
    MAC: string
    state: string
    product_id: number
    created_at?: Date | string
    updated_at: Date | string
    DispotiveIssue?: DispoIssueUncheckedCreateNestedManyWithoutDispositiveInput
    Intervention?: InterventionUncheckedCreateNestedManyWithoutDispositiveInput
    ProductTransaction?: ProductTransactionUncheckedCreateNestedManyWithoutDispositiveInput
  }

  export type DispositiveCreateOrConnectWithoutUserInput = {
    where: DispositiveWhereUniqueInput
    create: XOR<DispositiveCreateWithoutUserInput, DispositiveUncheckedCreateWithoutUserInput>
  }

  export type DispositiveCreateManyUserInputEnvelope = {
    data: DispositiveCreateManyUserInput | DispositiveCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuotationCreateWithoutUserInput = {
    created_at?: Date | string
    updated_at: Date | string
    ProductQuotation?: ProductQuotationCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUncheckedCreateWithoutUserInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    ProductQuotation?: ProductQuotationUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutUserInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutUserInput, QuotationUncheckedCreateWithoutUserInput>
  }

  export type QuotationCreateManyUserInputEnvelope = {
    data: QuotationCreateManyUserInput | QuotationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    created_at?: Date | string
    updated_at: Date | string
    ProductTransaction?: ProductTransactionCreateNestedManyWithoutTransactionInput
    Commercial: CommercialCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: number
    commercial_id: number
    created_at?: Date | string
    updated_at: Date | string
    ProductTransaction?: ProductTransactionUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type HelperCreateWithoutUserInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
  }

  export type HelperUncheckedCreateWithoutUserInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
  }

  export type HelperCreateOrConnectWithoutUserInput = {
    where: HelperWhereUniqueInput
    create: XOR<HelperCreateWithoutUserInput, HelperUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateWithoutUserInput = {
    type?: string | null
    channel?: string | null
    title: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean
    status?: string
    created_at?: Date | string
    sent_at?: Date | string | null
    read_at?: Date | string | null
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    type?: string | null
    channel?: string | null
    title: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean
    status?: string
    created_at?: Date | string
    sent_at?: Date | string | null
    read_at?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DispositiveUpsertWithWhereUniqueWithoutUserInput = {
    where: DispositiveWhereUniqueInput
    update: XOR<DispositiveUpdateWithoutUserInput, DispositiveUncheckedUpdateWithoutUserInput>
    create: XOR<DispositiveCreateWithoutUserInput, DispositiveUncheckedCreateWithoutUserInput>
  }

  export type DispositiveUpdateWithWhereUniqueWithoutUserInput = {
    where: DispositiveWhereUniqueInput
    data: XOR<DispositiveUpdateWithoutUserInput, DispositiveUncheckedUpdateWithoutUserInput>
  }

  export type DispositiveUpdateManyWithWhereWithoutUserInput = {
    where: DispositiveScalarWhereInput
    data: XOR<DispositiveUpdateManyMutationInput, DispositiveUncheckedUpdateManyWithoutUserInput>
  }

  export type QuotationUpsertWithWhereUniqueWithoutUserInput = {
    where: QuotationWhereUniqueInput
    update: XOR<QuotationUpdateWithoutUserInput, QuotationUncheckedUpdateWithoutUserInput>
    create: XOR<QuotationCreateWithoutUserInput, QuotationUncheckedCreateWithoutUserInput>
  }

  export type QuotationUpdateWithWhereUniqueWithoutUserInput = {
    where: QuotationWhereUniqueInput
    data: XOR<QuotationUpdateWithoutUserInput, QuotationUncheckedUpdateWithoutUserInput>
  }

  export type QuotationUpdateManyWithWhereWithoutUserInput = {
    where: QuotationScalarWhereInput
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyWithoutUserInput>
  }

  export type QuotationScalarWhereInput = {
    AND?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
    OR?: QuotationScalarWhereInput[]
    NOT?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
    id?: IntFilter<"Quotation"> | number
    user_id?: IntFilter<"Quotation"> | number
    created_at?: DateTimeFilter<"Quotation"> | Date | string
    updated_at?: DateTimeFilter<"Quotation"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type HelperUpsertWithWhereUniqueWithoutUserInput = {
    where: HelperWhereUniqueInput
    update: XOR<HelperUpdateWithoutUserInput, HelperUncheckedUpdateWithoutUserInput>
    create: XOR<HelperCreateWithoutUserInput, HelperUncheckedCreateWithoutUserInput>
  }

  export type HelperUpdateWithWhereUniqueWithoutUserInput = {
    where: HelperWhereUniqueInput
    data: XOR<HelperUpdateWithoutUserInput, HelperUncheckedUpdateWithoutUserInput>
  }

  export type HelperUpdateManyWithWhereWithoutUserInput = {
    where: HelperScalarWhereInput
    data: XOR<HelperUpdateManyMutationInput, HelperUncheckedUpdateManyWithoutUserInput>
  }

  export type HelperScalarWhereInput = {
    AND?: HelperScalarWhereInput | HelperScalarWhereInput[]
    OR?: HelperScalarWhereInput[]
    NOT?: HelperScalarWhereInput | HelperScalarWhereInput[]
    id?: IntFilter<"Helper"> | number
    first_name?: StringFilter<"Helper"> | string
    last_name?: StringFilter<"Helper"> | string
    email?: StringFilter<"Helper"> | string
    password?: StringFilter<"Helper"> | string
    phone?: StringNullableFilter<"Helper"> | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    user_id?: IntFilter<"Notification"> | number
    type?: StringNullableFilter<"Notification"> | string | null
    channel?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    metadata?: JsonNullableFilter<"Notification">
    is_read?: BoolFilter<"Notification"> | boolean
    status?: StringFilter<"Notification"> | string
    created_at?: DateTimeFilter<"Notification"> | Date | string
    sent_at?: DateTimeNullableFilter<"Notification"> | Date | string | null
    read_at?: DateTimeNullableFilter<"Notification"> | Date | string | null
  }

  export type InterventionCreateWithoutInterventionReportInput = {
    description: string
    type: string
    end_date: Date | string
    start_date?: Date | string
    status?: $Enums.InterventionStatus
    Dispositive: DispositiveCreateNestedOneWithoutInterventionInput
    Maintainer: MaintainerCreateNestedOneWithoutInterventionInput
  }

  export type InterventionUncheckedCreateWithoutInterventionReportInput = {
    idMaintainer: number
    description: string
    type: string
    end_date: Date | string
    start_date?: Date | string
    id?: number
    status?: $Enums.InterventionStatus
    idDispositive: number
  }

  export type InterventionCreateOrConnectWithoutInterventionReportInput = {
    where: InterventionWhereUniqueInput
    create: XOR<InterventionCreateWithoutInterventionReportInput, InterventionUncheckedCreateWithoutInterventionReportInput>
  }

  export type InterventionUpsertWithoutInterventionReportInput = {
    update: XOR<InterventionUpdateWithoutInterventionReportInput, InterventionUncheckedUpdateWithoutInterventionReportInput>
    create: XOR<InterventionCreateWithoutInterventionReportInput, InterventionUncheckedCreateWithoutInterventionReportInput>
    where?: InterventionWhereInput
  }

  export type InterventionUpdateToOneWithWhereWithoutInterventionReportInput = {
    where?: InterventionWhereInput
    data: XOR<InterventionUpdateWithoutInterventionReportInput, InterventionUncheckedUpdateWithoutInterventionReportInput>
  }

  export type InterventionUpdateWithoutInterventionReportInput = {
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    Dispositive?: DispositiveUpdateOneRequiredWithoutInterventionNestedInput
    Maintainer?: MaintainerUpdateOneRequiredWithoutInterventionNestedInput
  }

  export type InterventionUncheckedUpdateWithoutInterventionReportInput = {
    idMaintainer?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    idDispositive?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutNotificationInput = {
    email: string
    first_name: string
    last_name: string
    password: string
    phone?: string | null
    created_at?: Date | string
    Dispositive?: DispositiveCreateNestedManyWithoutUserInput
    Quotation?: QuotationCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    Helper?: HelperCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    id?: number
    email: string
    first_name: string
    last_name: string
    password: string
    phone?: string | null
    created_at?: Date | string
    Dispositive?: DispositiveUncheckedCreateNestedManyWithoutUserInput
    Quotation?: QuotationUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    Helper?: HelperUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    email?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Dispositive?: DispositiveUpdateManyWithoutUserNestedInput
    Quotation?: QuotationUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    Helper?: HelperUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Dispositive?: DispositiveUncheckedUpdateManyWithoutUserNestedInput
    Quotation?: QuotationUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    Helper?: HelperUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionCreateManyCommercialInput = {
    id?: number
    user_id: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type TransactionUpdateWithoutCommercialInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductTransaction?: ProductTransactionUpdateManyWithoutTransactionNestedInput
    User?: UserUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCommercialInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductTransaction?: ProductTransactionUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutCommercialInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispoIssueCreateManyDispositiveInput = {
    id?: number
    description: string
    date?: Date | string
    status?: string
    maintainerId?: number | null
  }

  export type InterventionCreateManyDispositiveInput = {
    idMaintainer: number
    description: string
    type: string
    end_date: Date | string
    start_date?: Date | string
    id?: number
    status?: $Enums.InterventionStatus
  }

  export type ProductTransactionCreateManyDispositiveInput = {
    transaction_id: number
    isConfirmed?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type DispoIssueUpdateWithoutDispositiveInput = {
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    Maintainer?: MaintainerUpdateOneWithoutDispoIssueNestedInput
  }

  export type DispoIssueUncheckedUpdateWithoutDispositiveInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    maintainerId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DispoIssueUncheckedUpdateManyWithoutDispositiveInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    maintainerId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InterventionUpdateWithoutDispositiveInput = {
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    Maintainer?: MaintainerUpdateOneRequiredWithoutInterventionNestedInput
    InterventionReport?: InterventionReportUpdateOneWithoutInterventionNestedInput
  }

  export type InterventionUncheckedUpdateWithoutDispositiveInput = {
    idMaintainer?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    InterventionReport?: InterventionReportUncheckedUpdateOneWithoutInterventionNestedInput
  }

  export type InterventionUncheckedUpdateManyWithoutDispositiveInput = {
    idMaintainer?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
  }

  export type ProductTransactionUpdateWithoutDispositiveInput = {
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Transaction?: TransactionUpdateOneRequiredWithoutProductTransactionNestedInput
  }

  export type ProductTransactionUncheckedUpdateWithoutDispositiveInput = {
    transaction_id?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTransactionUncheckedUpdateManyWithoutDispositiveInput = {
    transaction_id?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutHelperInput = {
    email?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Dispositive?: DispositiveUpdateManyWithoutUserNestedInput
    Quotation?: QuotationUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHelperInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Dispositive?: DispositiveUncheckedUpdateManyWithoutUserNestedInput
    Quotation?: QuotationUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutHelperInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispoIssueCreateManyMaintainerInput = {
    id?: number
    dispositiveId: number
    description: string
    date?: Date | string
    status?: string
  }

  export type InterventionCreateManyMaintainerInput = {
    description: string
    type: string
    end_date: Date | string
    start_date?: Date | string
    id?: number
    status?: $Enums.InterventionStatus
    idDispositive: number
  }

  export type DispoIssueUpdateWithoutMaintainerInput = {
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    Dispositive?: DispositiveUpdateOneRequiredWithoutDispotiveIssueNestedInput
  }

  export type DispoIssueUncheckedUpdateWithoutMaintainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    dispositiveId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type DispoIssueUncheckedUpdateManyWithoutMaintainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    dispositiveId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type InterventionUpdateWithoutMaintainerInput = {
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    Dispositive?: DispositiveUpdateOneRequiredWithoutInterventionNestedInput
    InterventionReport?: InterventionReportUpdateOneWithoutInterventionNestedInput
  }

  export type InterventionUncheckedUpdateWithoutMaintainerInput = {
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    idDispositive?: IntFieldUpdateOperationsInput | number
    InterventionReport?: InterventionReportUncheckedUpdateOneWithoutInterventionNestedInput
  }

  export type InterventionUncheckedUpdateManyWithoutMaintainerInput = {
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    idDispositive?: IntFieldUpdateOperationsInput | number
  }

  export type DispositiveCreateManyProductInput = {
    id?: number
    type: string
    start_date: Date | string
    end_date: Date | string
    initial_state: string
    MAC: string
    state: string
    user_id?: number | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ProductQuotationCreateManyProductInput = {
    quotation_id: number
    count: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type DispositiveUpdateWithoutProductInput = {
    type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    initial_state?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    DispotiveIssue?: DispoIssueUpdateManyWithoutDispositiveNestedInput
    User?: UserUpdateOneWithoutDispositiveNestedInput
    Intervention?: InterventionUpdateManyWithoutDispositiveNestedInput
    ProductTransaction?: ProductTransactionUpdateManyWithoutDispositiveNestedInput
  }

  export type DispositiveUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    initial_state?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    DispotiveIssue?: DispoIssueUncheckedUpdateManyWithoutDispositiveNestedInput
    Intervention?: InterventionUncheckedUpdateManyWithoutDispositiveNestedInput
    ProductTransaction?: ProductTransactionUncheckedUpdateManyWithoutDispositiveNestedInput
  }

  export type DispositiveUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    initial_state?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductQuotationUpdateWithoutProductInput = {
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Quotation?: QuotationUpdateOneRequiredWithoutProductQuotationNestedInput
  }

  export type ProductQuotationUncheckedUpdateWithoutProductInput = {
    quotation_id?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductQuotationUncheckedUpdateManyWithoutProductInput = {
    quotation_id?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductQuotationCreateManyQuotationInput = {
    product_id: number
    count: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ProductQuotationUpdateWithoutQuotationInput = {
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutProductQuotationNestedInput
  }

  export type ProductQuotationUncheckedUpdateWithoutQuotationInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductQuotationUncheckedUpdateManyWithoutQuotationInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateManySuperAdminInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone?: string | null
    privilege: number
  }

  export type AdminUpdateWithoutSuperAdminInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    privilege?: IntFieldUpdateOperationsInput | number
  }

  export type AdminUncheckedUpdateWithoutSuperAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    privilege?: IntFieldUpdateOperationsInput | number
  }

  export type AdminUncheckedUpdateManyWithoutSuperAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    privilege?: IntFieldUpdateOperationsInput | number
  }

  export type ProductTransactionCreateManyTransactionInput = {
    dispositive_id: number
    isConfirmed?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ProductTransactionUpdateWithoutTransactionInput = {
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Dispositive?: DispositiveUpdateOneRequiredWithoutProductTransactionNestedInput
  }

  export type ProductTransactionUncheckedUpdateWithoutTransactionInput = {
    dispositive_id?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTransactionUncheckedUpdateManyWithoutTransactionInput = {
    dispositive_id?: IntFieldUpdateOperationsInput | number
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispositiveCreateManyUserInput = {
    id?: number
    type: string
    start_date: Date | string
    end_date: Date | string
    initial_state: string
    MAC: string
    state: string
    product_id: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type QuotationCreateManyUserInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: number
    commercial_id: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    type?: string | null
    channel?: string | null
    title: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean
    status?: string
    created_at?: Date | string
    sent_at?: Date | string | null
    read_at?: Date | string | null
  }

  export type DispositiveUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    initial_state?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    DispotiveIssue?: DispoIssueUpdateManyWithoutDispositiveNestedInput
    Product?: ProductUpdateOneRequiredWithoutDispositiveNestedInput
    Intervention?: InterventionUpdateManyWithoutDispositiveNestedInput
    ProductTransaction?: ProductTransactionUpdateManyWithoutDispositiveNestedInput
  }

  export type DispositiveUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    initial_state?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    DispotiveIssue?: DispoIssueUncheckedUpdateManyWithoutDispositiveNestedInput
    Intervention?: InterventionUncheckedUpdateManyWithoutDispositiveNestedInput
    ProductTransaction?: ProductTransactionUncheckedUpdateManyWithoutDispositiveNestedInput
  }

  export type DispositiveUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    initial_state?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductQuotation?: ProductQuotationUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductQuotation?: ProductQuotationUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductTransaction?: ProductTransactionUpdateManyWithoutTransactionNestedInput
    Commercial?: CommercialUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    commercial_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductTransaction?: ProductTransactionUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    commercial_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelperUpdateWithoutUserInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HelperUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HelperUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}